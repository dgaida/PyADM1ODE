{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyADM1ODE Documentation","text":"<p>Welcome to PyADM1ODE - A Python framework for modeling, simulating, and optimizing agricultural biogas plants based on the Anaerobic Digestion Model No. 1 (ADM1).</p>"},{"location":"#quick-links","title":"\ud83c\udfaf Quick Links","text":"<ul> <li> <p> Quick Start</p> <p>Get started in minutes with your first biogas plant simulation</p> <p> Quickstart Guide</p> </li> <li> <p> Installation</p> <p>Install PyADM1ODE on Windows, Linux, or macOS</p> <p> Installation Guide</p> </li> <li> <p> Components Guide</p> <p>Learn about digesters, CHP units, pumps, and more</p> <p> Component Documentation</p> </li> <li> <p> Examples</p> <p>Real-world examples from basic to advanced plants</p> <p> Examples</p> </li> </ul>"},{"location":"#what-is-pyadm1ode","title":"What is PyADM1ODE?","text":"<p>PyADM1ODE is a comprehensive Python framework for agricultural biogas plant modeling that combines:</p> <ul> <li>Scientific accuracy: Based on IWA's ADM1 model, the international standard for anaerobic digestion</li> <li>Modular architecture: Mix and match components (digesters, CHP units, pumps, mixers) to build any plant configuration</li> <li>Real-world applicability: Validated with data from operating biogas plants</li> <li>Python ecosystem: Integrates with NumPy, SciPy, Pandas, and visualization libraries</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<p>\u2728 Comprehensive Component Library </p> <ul> <li>Biological: Single/multi-stage digesters, hydrolysis tanks, separators  </li> <li>Energy: CHP units, heating systems, gas storage, flares  </li> <li>Mechanical: Pumps, mixers with realistic power consumption  </li> <li>Feeding: Substrate storage, automated dosing systems</li> </ul> <p>\ud83d\udd27 Flexible Plant Configuration </p> <ul> <li>Build complex plants programmatically or via templates  </li> <li>Automatic component connection and validation  </li> <li>Save/load configurations as JSON</li> </ul> <p>\ud83d\udcca Advanced Simulation </p> <ul> <li>Parallel execution for parameter sweeps and Monte Carlo analysis  </li> <li>Adaptive ODE solvers optimized for stiff biogas systems  </li> <li>Time-series data handling and result analysis</li> </ul> <p>\ud83c\udf93 Educational &amp; Professional </p> <ul> <li>Suitable for teaching biogas plant design  </li> <li>Research tool for process optimization  </li> <li>Engineering applications for plant planning</li> </ul>"},{"location":"#system-architecture","title":"System Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     PyADM1ODE Framework                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n\u2502  \u2502   Biological \u2502  \u2502    Energy    \u2502  \u2502  Mechanical  \u2502         \u2502\n\u2502  \u2502  Components  \u2502  \u2502  Components  \u2502  \u2502  Components  \u2502         \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524         \u2502\n\u2502  \u2502 \u2022 Digesters  \u2502  \u2502 \u2022 CHP Units  \u2502  \u2502 \u2022 Pumps      \u2502         \u2502\n\u2502  \u2502 \u2022 Hydrolysis \u2502  \u2502 \u2022 Heating    \u2502  \u2502 \u2022 Mixers     \u2502         \u2502\n\u2502  \u2502 \u2022 Separators \u2502  \u2502 \u2022 Storage    \u2502  \u2502              \u2502         \u2502\n\u2502  \u2502              \u2502  \u2502 \u2022 Flares     \u2502  \u2502              \u2502         \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n\u2502  \u2502   Feeding    \u2502  \u2502   Sensors    \u2502  \u2502 Configurator \u2502         \u2502\n\u2502  \u2502  Components  \u2502  \u2502  (planned)   \u2502  \u2502              \u2502         \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524         \u2502\n\u2502  \u2502 \u2022 Storage    \u2502  \u2502 \u2022 pH         \u2502  \u2502 \u2022 Builder    \u2502         \u2502\n\u2502  \u2502 \u2022 Feeders    \u2502  \u2502 \u2022 VFA        \u2502  \u2502 \u2022 Templates  \u2502         \u2502\n\u2502  \u2502              \u2502  \u2502 \u2022 Gas        \u2502  \u2502 \u2022 Validator  \u2502         \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502\n\u2502                                                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                       Core ADM1 Engine                           \u2502\n\u2502  \u2022 37 state variables \u2022 pH dynamics \u2022 Gas-liquid transfer       \u2502\n\u2502  \u2022 Temperature-dependent kinetics \u2022 Inhibition modeling         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                    Substrate Management                          \u2502\n\u2502  \u2022 10 pre-configured agricultural substrates                    \u2502\n\u2502  \u2022 Automatic ADM1 input stream generation                       \u2502\n\u2502  \u2022 Time-varying feed schedules                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Build and simulate a complete biogas plant in just a few lines:</p> <pre><code>from pyadm1.configurator import BiogasPlant, PlantConfigurator\nfrom pyadm1.substrates import Feedstock\n\n# Create plant\nfeedstock = Feedstock(feeding_freq=48)\nplant = BiogasPlant(\"My Biogas Plant\")\nconfigurator = PlantConfigurator(plant, feedstock)\n\n# Add digester (automatically creates gas storage)\nconfigurator.add_digester(\n    digester_id=\"main_digester\",\n    V_liq=2000.0,              # 2000 m\u00b3 liquid volume\n    V_gas=300.0,               # 300 m\u00b3 gas headspace\n    T_ad=308.15,               # 35\u00b0C mesophilic\n    Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0]  # Corn silage + manure\n)\n\n# Add CHP and heating (automatically creates flare)\nconfigurator.add_chp(\"chp_main\", P_el_nom=500.0)\nconfigurator.add_heating(\"heating_main\", target_temperature=308.15)\n\n# Connect components\nconfigurator.auto_connect_digester_to_chp(\"main_digester\", \"chp_main\")\nconfigurator.auto_connect_chp_to_heating(\"chp_main\", \"heating_main\")\n\n# Simulate\nplant.initialize()\nresults = plant.simulate(duration=30, dt=1/24, save_interval=1.0)\n\n# Analyze\nfinal = results[-1][\"components\"][\"main_digester\"]\nprint(f\"Biogas: {final['Q_gas']:.1f} m\u00b3/d\")\nprint(f\"Methane: {final['Q_ch4']:.1f} m\u00b3/d\")\nprint(f\"pH: {final['pH']:.2f}\")\n</code></pre> <p>Output: <pre><code>Biogas: 1245.3 m\u00b3/d\nMethane: 748.2 m\u00b3/d\npH: 7.28\n</code></pre></p>"},{"location":"#typical-applications","title":"Typical Applications","text":""},{"location":"#1-plant-design-and-optimization","title":"1. Plant Design and Optimization","text":"<pre><code># Test different digester sizes\nfor V_liq in [1500, 2000, 2500]:\n    plant = BiogasPlant(f\"Plant_{V_liq}\")\n    configurator = PlantConfigurator(plant, feedstock)\n    configurator.add_digester(\"dig1\", V_liq=V_liq, Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0])\n\n    plant.initialize()\n    results = plant.simulate(duration=30, dt=1/24)\n\n    final = results[-1][\"components\"][\"dig1\"]\n    print(f\"V={V_liq} m\u00b3 \u2192 CH4={final['Q_ch4']:.1f} m\u00b3/d\")\n</code></pre>"},{"location":"#2-substrate-optimization","title":"2. Substrate Optimization","text":"<pre><code># Compare different substrate mixes\nmixes = {\n    'high_energy': [20, 5, 0, 0, 0, 0, 0, 0, 0, 0],\n    'balanced': [15, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n    'waste_based': [0, 15, 0, 0, 0, 0, 0, 0, 10, 5]\n}\n\nfor name, Q in mixes.items():\n    # ... configure and simulate ...\n    print(f\"{name}: {final['Q_ch4']:.1f} m\u00b3/d methane\")\n</code></pre>"},{"location":"#3-energy-balance-analysis","title":"3. Energy Balance Analysis","text":"<pre><code># Calculate net energy production\nchp_power = results[-1][\"components\"][\"chp_main\"][\"P_el\"]\nmixer_power = results[-1][\"components\"][\"mixer_1\"][\"P_consumed\"]\npump_power = results[-1][\"components\"][\"pump_1\"][\"P_consumed\"]\n\nparasitic_load = mixer_power + pump_power\nnet_power = chp_power - parasitic_load\n\nprint(f\"Net power: {net_power:.1f} kW\")\nprint(f\"Parasitic ratio: {parasitic_load/chp_power:.1%}\")\n</code></pre>"},{"location":"#4-two-stage-process-design","title":"4. Two-Stage Process Design","text":"<pre><code># Temperature-phased anaerobic digestion (TPAD)\nconfigurator.add_digester(\"hydrolysis\", V_liq=500, T_ad=318.15)  # 45\u00b0C\nconfigurator.add_digester(\"main\", V_liq=2000, T_ad=308.15)       # 35\u00b0C\nconfigurator.connect(\"hydrolysis\", \"main\", \"liquid\")\n\n# Enhanced hydrolysis in stage 1, stable methanogenesis in stage 2\n</code></pre>"},{"location":"#component-categories","title":"Component Categories","text":""},{"location":"#biological-components","title":"Biological Components","text":"<p>Model the core biological processes:</p> <ul> <li>Digester: Main fermenter with ADM1 model</li> <li>Single or multi-stage configurations</li> <li>Temperature control (psychrophilic, mesophilic, thermophilic)</li> <li>Automatic gas storage creation</li> <li> <p>Calibration parameter support (using PyADM1ODE_calibration)</p> </li> <li> <p>Hydrolysis: Pre-treatment tank (planned)</p> </li> <li>Separator: Digestate processing (planned)</li> </ul>"},{"location":"#energy-components","title":"Energy Components","text":"<p>Complete energy integration:</p> <ul> <li> <p>CHP: Combined heat and power generation</p> <ul> <li>Variable efficiency curves</li> <li>Load-following operation</li> <li>Automatic flare creation</li> </ul> </li> <li> <p>Heating: Temperature control systems</p> <ul> <li>CHP waste heat utilization</li> <li>Auxiliary heating calculation</li> </ul> </li> <li> <p>Gas Storage: Biogas buffering</p> <ul> <li>Low-pressure (membrane, dome) and high-pressure options</li> <li>Automatic pressure management</li> <li>Safety venting</li> </ul> </li> <li> <p>Flare: Safety gas combustion</p> <ul> <li>98% methane destruction efficiency</li> <li>Automatic activation on overpressure</li> </ul> </li> </ul>"},{"location":"#mechanical-components","title":"Mechanical Components","text":"<p>Material handling and process control:</p> <ul> <li> <p>Pump: Substrate and digestate transfer</p> <ul> <li>Progressive cavity, centrifugal, piston types</li> <li>Power consumption modeling</li> <li>Variable frequency drive support</li> </ul> </li> <li> <p>Mixer: Digester agitation</p> <ul> <li>Propeller, paddle, jet mixer types</li> <li>Intermittent operation for energy savings</li> <li>Reynolds number and mixing time calculation</li> </ul> </li> </ul>"},{"location":"#feeding-components","title":"Feeding Components","text":"<p>Substrate management:</p> <ul> <li> <p>Substrate Storage: Material inventory</p> <ul> <li>Multiple storage types (silos, tanks, bunkers)</li> <li>Quality degradation modeling</li> <li>Capacity and utilization tracking</li> </ul> </li> <li> <p>Feeder: Automated dosing</p> <ul> <li>Screw, piston, progressive cavity feeders</li> <li>Realistic dosing accuracy and noise</li> <li>Blockage detection</li> </ul> </li> </ul>"},{"location":"#pre-configured-substrates","title":"Pre-configured Substrates","text":"<p>PyADM1ODE includes 10 agricultural substrates with literature-validated parameters:</p> Substrate Type Typical Use Biogas Potential Corn silage Energy crop Main feedstock High (600-700 L/kg VS) Liquid manure Animal waste Co-substrate Medium (200-400 L/kg VS) Green rye Energy crop Early harvest Medium-High Grass silage Grassland Renewable Medium (400-550 L/kg VS) Wheat Cereal Energy crop High GPS Grain silage Whole-crop High CCM Corn-cob-mix Energy crop High Feed lime Additive pH buffer N/A Cow manure Animal waste Co-substrate Medium (200-350 L/kg VS) Onions Waste Vegetable waste Medium-High <p>All substrates are characterized with: - Dry matter (DM) and volatile solids (VS) content - ADM1 fractionation (carbohydrates, proteins, lipids) - Biochemical methane potential (BMP) - pH and alkalinity</p>"},{"location":"#advanced-features","title":"Advanced Features","text":""},{"location":"#parallel-simulation","title":"Parallel Simulation","text":"<p>Run multiple scenarios concurrently (see Example: Parallel Simulation):</p> <pre><code>from pyadm1.simulation import ParallelSimulator\n\n# Parameter sweep\nparallel = ParallelSimulator(adm1, n_workers=4)\nscenarios = [\n    {\"k_dis\": 0.5, \"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]},\n    {\"k_dis\": 0.6, \"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]},\n    {\"k_dis\": 0.7, \"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]}\n]\n\nresults = parallel.run_scenarios(scenarios, duration=30, initial_state=state)\n</code></pre>"},{"location":"#configuration-management","title":"Configuration Management","text":"<p>Save and reuse plant designs:</p> <pre><code># Save configuration\nplant.to_json(\"two_stage_plant.json\")\n\n# Load later\nplant = BiogasPlant.from_json(\"two_stage_plant.json\", feedstock)\nplant.initialize()\nresults = plant.simulate(duration=30, dt=1/24)\n</code></pre>"},{"location":"#scientific-foundation","title":"Scientific Foundation","text":"<p>PyADM1ODE is based on the Anaerobic Digestion Model No. 1 (ADM1), developed by the International Water Association (IWA) Task Group:</p> <ul> <li>37 state variables: Complete representation of liquid and gas phases</li> <li>19 biochemical processes: Disintegration, hydrolysis, acidogenesis, acetogenesis, methanogenesis</li> <li>Temperature-dependent kinetics: Arrhenius relationships for all rate constants</li> <li>pH dynamics: Full acid-base equilibrium with 6 ionic species</li> <li>Gas-liquid transfer: Henry's law implementation for H\u2082, CH\u2084, CO\u2082</li> <li>Inhibition modeling: pH, ammonia, and hydrogen inhibition</li> </ul> <p>Key References:</p> <ul> <li>Batstone, D.J., et al. (2002). Anaerobic Digestion Model No. 1 (ADM1). IWA Publishing.</li> <li>Sadrimajd, P., et al. (2021). PyADM1: a Python implementation of Anaerobic Digestion Model No. 1. bioRxiv.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install PyADM1ODE via pip (not yet existing):</p> <pre><code>pip install pyadm1ode\n</code></pre> <p>For development or the latest features:</p> <pre><code>git clone https://github.com/dgaida/PyADM1ODE.git\ncd PyADM1ODE\npip install -e .\n</code></pre> <p>Platform-specific requirements: - Linux/macOS: Mono runtime (for C# DLLs) - Windows: .NET Framework (usually pre-installed)</p> <p>See the Installation Guide for detailed instructions.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install PyADM1ODE on your system</li> <li>Follow the Quickstart to run your first simulation</li> <li>Explore Components to understand available building blocks</li> <li>Study Examples for real-world applications</li> </ol>"},{"location":"#extension-packages","title":"Extension Packages","text":""},{"location":"#pyadm1ode_mcp-llm-driven-plant-design","title":"PyADM1ODE_mcp - LLM-Driven Plant Design","text":"<p>Natural language interface for biogas plant modeling:</p> <pre><code>git clone https://github.com/dgaida/PyADM1ODE_mcp.git\ncd PyADM1ODE_mcp\npip install -e .\n</code></pre> <p>Features: - Interact with Claude or other LLMs to design plants via natural language - MCP server for seamless LLM integration - Automated configuration parsing and validation</p> <p>Use case: \"Design a two-stage biogas plant with 2000 m\u00b3 main digester, 500 m\u00b3 hydrolysis tank at 45\u00b0C, and a 500 kW CHP unit. Use corn silage and cattle manure as substrates.\"</p>"},{"location":"#pyadm1ode_calibration-parameter-estimation","title":"PyADM1ODE_calibration - Parameter Estimation","text":"<p>Automated model calibration from measurement data:</p> <pre><code>git clone https://github.com/dgaida/PyADM1ODE_calibration.git\ncd PyADM1ODE_calibration\npip install -e .\n</code></pre> <p>Features: - Initial calibration from historical data - Online re-calibration during operation - Multiple optimization algorithms (Differential Evolution, PSO, Nelder-Mead) - Comprehensive validation metrics</p> <p>Use case: Fit ADM1 parameters to real plant measurements for accurate predictions.</p>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>GitHub Repository: dgaida/PyADM1ODE</li> <li>Issue Tracker: Report bugs or request features</li> <li>Discussions: Ask questions and share ideas</li> <li>Email: daniel.gaida@th-koeln.de</li> </ul>"},{"location":"#license","title":"License","text":"<p>PyADM1ODE is open-source software licensed under the MIT License.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use PyADM1ODE in your research, please cite:</p> <pre><code>@software{gaida2025pyadm1ode,\n  author = {Gaida, Daniel; Nordhoff, Tim Yago},\n  title = {PyADM1ODE: Python Framework for Agricultural Biogas Plant Modeling},\n  year = {2026},\n  url = {https://github.com/dgaida/PyADM1ODE}\n}\n</code></pre>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>PyADM1ODE builds upon:</p> <ul> <li>IWA ADM1 Task Group - Original model development</li> <li>PyADM1 by Sadrimajd et al. - Initial Python implementation</li> <li>SIMBA#biogas - Substrate characterization and validation data</li> </ul> <p>Ready to start? Head over to the Quickstart Guide and build your first biogas plant in minutes! \ud83d\ude80</p>"},{"location":"api_reference/components/biological/","title":"Biological","text":"<p>Biological Process Components</p> <p>Components for biological conversion processes in biogas plants.</p> <p>Modules:</p> <pre><code>digester: Main fermenter component implementing ADM1 model for anaerobic digestion,\n         supporting single or multiple fermenters in series/parallel, with flexible\n         volume, temperature, and retention time configuration.\n\nhydrolysis: Pre-treatment tank for hydrolysis-dominated processes, useful for\n           substrates with high lignocellulosic content, can operate at different\n           temperatures and retention times than main digester.\n\nseparator: Solid-liquid separation component for digestate processing, models\n          mechanical (screw press, centrifuge) or gravitational separation with\n          configurable separation efficiency and dry matter content.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.components.biological import Digester, Hydrolysis, Separator\n    &gt;&gt;&gt; from pyadm1.substrates import Feedstock\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; feedstock = Feedstock(feeding_freq=48)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Two-stage digestion with hydrolysis pre-treatment\n    &gt;&gt;&gt; hydrolysis = Hydrolysis(\"hydro1\", feedstock, V_liq=500, T_ad=318.15)\n    &gt;&gt;&gt; digester = Digester(\"dig1\", feedstock, V_liq=2000, T_ad=308.15)\n    &gt;&gt;&gt; separator = Separator(\"sep1\", separation_efficiency=0.95)\n</code></pre>"},{"location":"api_reference/components/biological/#classes","title":"Classes","text":"<ul> <li>Digester</li> <li>Hydrolysis</li> <li>Separator</li> </ul>"},{"location":"api_reference/components/biological/#digester","title":"Digester","text":"<pre><code>from pyadm1.components.biological import Digester\n</code></pre> <p>Digester component using ADM1 model.</p> <p>This component wraps the ADM1 implementation and can be connected to other digesters or components in series/parallel.</p> <p>Attributes:</p> <pre><code>feedstock (Feedstock): Feedstock object for substrate management.\nV_liq (float): Liquid volume in m\u00b3.\nV_gas (float): Gas volume in m\u00b3.\nT_ad (float): Operating temperature in K.\nadm1 (ADM1): ADM1 model instance.\nsimulator (Simulator): Simulator for ADM1.\nadm1_state (List[float]): Current ADM1 state vector (37 dimensions).\nQ_substrates (List[float]): Substrate feed rates in m\u00b3/d.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; feedstock = Feedstock(feeding_freq=48)\n    &gt;&gt;&gt; digester = Digester(\"dig1\", feedstock, V_liq=2000, V_gas=300)\n    &gt;&gt;&gt; digester.initialize({\"adm1_state\": initial_state, \"Q_substrates\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]})\n</code></pre> <p>Signature:</p> <pre><code>Digester(\n    component_id,\n    feedstock,\n    V_liq=1977.0,\n    V_gas=304.0,\n    T_ad=308.15,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/biological/#add_input","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/biological/#add_output","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/biological/#apply_calibration_parameters","title":"<code>apply_calibration_parameters()</code>","text":"<pre><code>apply_calibration_parameters(parameters)\n</code></pre> <p>Apply calibration parameters to this digester.</p> <p>Stores parameters for use during simulation. These override the substrate-dependent parameters calculated from feedstock.</p> <p>Args:</p> <pre><code>parameters: Parameter values as {param_name: value}.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; digester.apply_calibration_parameters({\n    ...     'k_dis': 0.55,\n    ...     'Y_su': 0.105,\n    ...     'k_hyd_ch': 11.0\n    ... })\n</code></pre>"},{"location":"api_reference/components/biological/#clear_calibration_parameters","title":"<code>clear_calibration_parameters()</code>","text":"<pre><code>clear_calibration_parameters()\n</code></pre> <p>Clear all calibration parameters and revert to default substrate-dependent values.</p> <p>Example:</p> <pre><code>    &gt;&gt;&gt; digester.clear_calibration_parameters()\n</code></pre>"},{"location":"api_reference/components/biological/#get_calibration_parameters","title":"<code>get_calibration_parameters()</code>","text":"<pre><code>get_calibration_parameters()\n</code></pre> <p>Get currently applied calibration parameters.</p> <p>Returns:</p> <pre><code>dict: Current calibration parameters as {param_name: value}.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; params = digester.get_calibration_parameters()\n    &gt;&gt;&gt; print(params)\n    {'k_dis': 0.55, 'Y_su': 0.105}\n</code></pre>"},{"location":"api_reference/components/biological/#get_state","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/biological/#initialize","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre> <p>Initialize digester state.</p> <p>Args:</p> <pre><code>initial_state (Optional[Dict[str, Any]]): Initial state with keys:\n    - 'adm1_state': ADM1 state vector (37 dims)\n    - 'Q_substrates': Substrate feed rates\n    If None, uses default initialization.\n</code></pre>"},{"location":"api_reference/components/biological/#set_state","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/biological/#step","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre> <p>Perform one simulation time step.</p> <p>Args:</p> <pre><code>t (float): Current time in days.\ndt (float): Time step in days.\ninputs (Dict[str, Any]): Input data with keys:\n    - 'Q_substrates': Fresh substrate feed rates [m\u00b3/d]\n    - 'Q_in': Influent from previous digester [m\u00b3/d]\n    - 'state_in': ADM1 state from previous digester (if connected)\n</code></pre> <p>Returns:</p> <pre><code>Dict[str, Any]: Output data with keys:\n    - 'Q_out': Effluent flow rate [m\u00b3/d]\n    - 'state_out': ADM1 state vector for next digester\n    - 'Q_gas': Biogas production [m\u00b3/d]\n    - 'Q_ch4': Methane production [m\u00b3/d]\n    - 'Q_co2': CO2 production [m\u00b3/d]\n    - 'pH': pH value\n    - 'VFA': VFA concentration [g/L]\n    - 'TAC': TAC concentration [g CaCO3/L]\n</code></pre>"},{"location":"api_reference/components/biological/#to_dict","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize to dictionary.</p> <p>Returns:</p> <pre><code>Dict[str, Any]: Component configuration as dictionary.\n</code></pre> <p>Attributes:</p> <ul> <li>feedstock (Feedstock): Feedstock object for substrate management.</li> <li>V_liq (float): Liquid volume in m\u00b3.</li> <li>V_gas (float): Gas volume in m\u00b3.</li> <li>T_ad (float): Operating temperature in K.</li> <li>adm1 (ADM1): ADM1 model instance.</li> <li>simulator (Simulator): Simulator for ADM1.</li> <li>adm1_state (List[float]): Current ADM1 state vector (37 dimensions).</li> <li>Q_substrates (List[float]): Substrate feed rates in m\u00b3/d.</li> </ul>"},{"location":"api_reference/components/biological/#hydrolysis","title":"Hydrolysis","text":"<pre><code>from pyadm1.components.biological import Hydrolysis\n</code></pre> <p>Hydrolysis tank component (stub for future implementation).</p> <p>Signature:</p> <pre><code>Hydrolysis(\n    component_id,\n    feedstock,\n    V_liq=500.0,\n    T_ad=318.15,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/biological/#add_input_1","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/biological/#add_output_1","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/biological/#get_state_1","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/biological/#initialize_1","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre>"},{"location":"api_reference/components/biological/#set_state_1","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/biological/#step_1","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre>"},{"location":"api_reference/components/biological/#to_dict_1","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre>"},{"location":"api_reference/components/biological/#separator","title":"Separator","text":"<pre><code>from pyadm1.components.biological import Separator\n</code></pre> <p>Separator component (stub for future implementation).</p> <p>Signature:</p> <pre><code>Separator(\n    component_id,\n    separation_efficiency=0.95,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/biological/#add_input_2","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/biological/#add_output_2","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/biological/#get_state_2","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/biological/#initialize_2","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre>"},{"location":"api_reference/components/biological/#set_state_2","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/biological/#step_2","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre>"},{"location":"api_reference/components/biological/#to_dict_2","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre>"},{"location":"api_reference/components/components/","title":"Plant Components","text":"<p>Modular Plant Components</p> <p>This module provides a comprehensive library of biogas plant components that can be combined to build complex plant configurations. All components follow a common interface and can be dynamically loaded and connected.</p> <p>Modules:</p> <pre><code>base: Base classes (Component, ComponentType) defining the interface that all\n      components must implement, including step(), initialize(), serialization,\n      and connection management.\n\nregistry: Component registry system for dynamic component discovery, loading,\n         and instantiation, enabling plugin-like extensibility and automated\n         component selection by LLM agents.\n</code></pre> <p>Subpackages:</p> <pre><code>biological: Components for biological processes including digesters (single/multi-stage),\n           hydrolysis tanks for pre-treatment, and solid-liquid separators for\n           digestate processing.\n\nmechanical: Mechanical components including pumps (centrifugal, positive displacement),\n           mixers/agitators (various types), valves (control, safety), and heat\n           exchangers for thermal management.\n\nenergy: Energy conversion and storage components including CHP units (gas engines,\n       micro-turbines), boilers (auxiliary heating), gas storage (low/high pressure),\n       and flares for safety gas combustion.\n\nfeeding: Substrate handling components including storage silos, automated dosing\n        systems (screw feeders, pumps), and mixer wagons for substrate preparation.\n\nsensors: Measurement components including physical sensors (pH, temperature, pressure),\n        chemical sensors (VFA, ammonia, COD), and gas analyzers (CH4, CO2, H2S, O2).\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.components.biological import Digester\n    &gt;&gt;&gt; from pyadm1.components.energy import CHP\n    &gt;&gt;&gt; from pyadm1.components import ComponentRegistry\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Direct instantiation\n    &gt;&gt;&gt; digester = Digester(\"dig1\", feedstock, V_liq=2000)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Via registry\n    &gt;&gt;&gt; registry = ComponentRegistry()\n    &gt;&gt;&gt; component = registry.create(\"Digester\", \"dig1\", feedstock=feedstock)\n</code></pre>"},{"location":"api_reference/components/components/#subpackages","title":"Subpackages","text":""},{"location":"api_reference/components/components/#biological","title":"biological","text":"<p>Biological Process Components</p>"},{"location":"api_reference/components/components/#energy","title":"energy","text":"<p>Energy Conversion and Storage Components</p>"},{"location":"api_reference/components/components/#feeding","title":"feeding","text":"<p>Substrate Feeding and Storage Components</p>"},{"location":"api_reference/components/components/#mechanical","title":"mechanical","text":"<p>Mechanical Plant Components</p>"},{"location":"api_reference/components/components/#sensors","title":"sensors","text":"<p>Measurement and Sensor Components</p>"},{"location":"api_reference/components/components/#base-classes","title":"Base Classes","text":"<ul> <li>Component</li> <li>ComponentRegistry</li> <li>ComponentType</li> </ul>"},{"location":"api_reference/components/components/#component","title":"Component","text":"<pre><code>from pyadm1.components import Component\n</code></pre> <p>Abstract base class for all biogas plant components.</p> <p>All components must implement the step() method which performs one simulation time step.</p> <p>Signature:</p> <pre><code>Component(\n    component_id,\n    component_type,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/components/#add_input","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/components/#add_output","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/components/#get_state","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/components/#initialize","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre> <p>Initialize component state.</p>"},{"location":"api_reference/components/components/#parameters","title":"Parameters","text":"<p>initial_state : Optional[Dict[str, Any]]     Initial state values</p>"},{"location":"api_reference/components/components/#set_state","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/components/#step","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre> <p>Perform one simulation time step.</p>"},{"location":"api_reference/components/components/#parameters_1","title":"Parameters","text":"<p>t : float     Current simulation time [days] dt : float     Time step size [days] inputs : Dict[str, Any]     Input data from connected components</p>"},{"location":"api_reference/components/components/#returns","title":"Returns","text":"<p>Dict[str, Any]     Output data to be passed to connected components</p>"},{"location":"api_reference/components/components/#to_dict","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize component to dictionary for JSON export.</p>"},{"location":"api_reference/components/components/#returns_1","title":"Returns","text":"<p>Dict[str, Any]     Component configuration as dictionary</p>"},{"location":"api_reference/components/components/#componentregistry","title":"ComponentRegistry","text":"<pre><code>from pyadm1.components import ComponentRegistry\n</code></pre> <p>Registry for dynamically managing and creating component instances.</p> <p>The ComponentRegistry allows for plugin-like extensibility, enabling components to be registered and instantiated by name.</p> <p>Attributes:</p> <pre><code>_registry (Dict[str, Type[Component]]): Internal registry mapping\n    component names to their classes.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; registry = ComponentRegistry()\n    &gt;&gt;&gt; registry.register(\"Digester\", Digester)\n    &gt;&gt;&gt; component = registry.create(\"Digester\", \"dig1\", feedstock=feedstock)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/components/#create","title":"<code>create()</code>","text":"<pre><code>create(name, component_id, kwargs)\n</code></pre> <p>Create a component instance by name.</p> <p>Args:</p> <pre><code>name (str): Name of the registered component class.\ncomponent_id (str): Unique identifier for the component instance.\n**kwargs: Additional keyword arguments passed to component constructor.\n</code></pre> <p>Returns:</p> <pre><code>Component: Instantiated component.\n</code></pre> <p>Raises:</p> <pre><code>KeyError: If component name is not registered.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; component = registry.create(\"Digester\", \"dig1\",\n    ...                            feedstock=feedstock, V_liq=2000)\n</code></pre>"},{"location":"api_reference/components/components/#get_registered_components","title":"<code>get_registered_components()</code>","text":"<pre><code>get_registered_components()\n</code></pre> <p>Get all registered component classes.</p> <p>Returns:</p> <pre><code>Dict[str, Type[Component]]: Dictionary mapping names to component classes.\n</code></pre>"},{"location":"api_reference/components/components/#is_registered","title":"<code>is_registered()</code>","text":"<pre><code>is_registered(name)\n</code></pre> <p>Check if a component name is registered.</p> <p>Args:</p> <pre><code>name (str): Component name to check.\n</code></pre> <p>Returns:</p> <pre><code>bool: True if registered, False otherwise.\n</code></pre>"},{"location":"api_reference/components/components/#list_components","title":"<code>list_components()</code>","text":"<pre><code>list_components()\n</code></pre> <p>Get a list of all registered component names.</p> <p>Returns:</p> <pre><code>list[str]: List of registered component names.\n</code></pre>"},{"location":"api_reference/components/components/#register","title":"<code>register()</code>","text":"<pre><code>register(name, component_class)\n</code></pre> <p>Register a component class with a given name.</p> <p>Args:</p> <pre><code>name (str): Name to register the component under.\ncomponent_class (Type[Component]): Component class to register.\n</code></pre> <p>Raises:</p> <pre><code>ValueError: If name is already registered.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; registry.register(\"CustomDigester\", CustomDigester)\n</code></pre>"},{"location":"api_reference/components/components/#unregister","title":"<code>unregister()</code>","text":"<pre><code>unregister(name)\n</code></pre> <p>Unregister a component class.</p> <p>Args:</p> <pre><code>name (str): Name of the component to unregister.\n</code></pre> <p>Raises:</p> <pre><code>KeyError: If component name is not registered.\n</code></pre> <p>Attributes:</p> <ul> <li>_registry (Dict[str, Type[Component]]): Internal registry mapping</li> <li>component names to their classes.</li> </ul>"},{"location":"api_reference/components/components/#componenttype","title":"ComponentType","text":"<pre><code>from pyadm1.components import ComponentType\n</code></pre> <p>Enumeration of component types.</p> <p>Signature:</p> <pre><code>ComponentType(\n    args,\n    kwds\n)\n</code></pre>"},{"location":"api_reference/components/energy/","title":"Energy","text":"<p>Energy Conversion and Storage Components</p> <p>Components for energy generation, conversion, and storage in biogas plants.</p> <p>Modules:</p> <pre><code>chp: Combined Heat and Power (CHP) units including gas engines and micro-turbines,\n    with electrical and thermal efficiency curves, part-load behavior, maintenance\n    scheduling, and emissions calculation.\n\nboiler: Auxiliary heating systems (gas, oil, biomass boilers) for peak heat demand\n       and backup heating, with efficiency curves, fuel consumption, and emission\n       factors.\n\ngas_storage: Biogas storage systems including low-pressure (membrane, dome) and\n            high-pressure (compressed gas) storage, with pressure control, safety\n            management, and capacity utilization.\n\nflare: Safety gas combustion system for excess biogas or emergency situations,\n      with destruction efficiency, emissions calculation, and automatic ignition\n      control.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.components.energy import CHP, Boiler, GasStorage, Flare\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # CHP unit with 500 kW electrical output\n    &gt;&gt;&gt; chp = CHP(\"chp1\", P_el_nom=500, eta_el=0.40, eta_th=0.45,\n    ...          type=\"gas_engine\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Low-pressure gas storage (membrane roof)\n    &gt;&gt;&gt; storage = GasStorage(\"storage1\", volume=1000,\n    ...                     storage_type=\"membrane\", p_max=0.015)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Emergency flare\n    &gt;&gt;&gt; flare = Flare(\"flare1\", capacity=500, destruction_efficiency=0.98)\n</code></pre>"},{"location":"api_reference/components/energy/#classes","title":"Classes","text":"<ul> <li>Boiler</li> <li>CHP</li> <li>Flare</li> <li>GasStorage</li> </ul>"},{"location":"api_reference/components/energy/#boiler","title":"Boiler","text":"<pre><code>from pyadm1.components.energy import Boiler\n</code></pre> <p>Boiler component (stub for future implementation).</p> <p>Signature:</p> <pre><code>Boiler(\n    component_id,\n    P_th_nom=200.0,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/energy/#add_input","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/energy/#add_output","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/energy/#get_state","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/energy/#initialize","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre>"},{"location":"api_reference/components/energy/#set_state","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/energy/#step","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre>"},{"location":"api_reference/components/energy/#to_dict","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre>"},{"location":"api_reference/components/energy/#chp","title":"CHP","text":"<pre><code>from pyadm1.components.energy import CHP\n</code></pre> <p>Combined Heat and Power unit.</p> <p>Converts biogas to electricity and heat with configurable efficiency.</p> <p>Attributes:</p> <pre><code>P_el_nom (float): Nominal electrical power in kW.\neta_el (float): Electrical efficiency (0-1).\neta_th (float): Thermal efficiency (0-1).\nload_factor (float): Current operating point (0-1).\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; chp = CHP(\"chp1\", P_el_nom=500, eta_el=0.40, eta_th=0.45)\n    &gt;&gt;&gt; chp.initialize()\n    &gt;&gt;&gt; result = chp.step(t=0, dt=1/24, inputs={\"Q_ch4\": 1000})\n</code></pre> <p>Signature:</p> <pre><code>CHP(\n    component_id,\n    P_el_nom=500.0,\n    eta_el=0.4,\n    eta_th=0.45,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/energy/#add_input_1","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/energy/#add_output_1","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/energy/#get_state_1","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/energy/#initialize_1","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre> <p>Initialize CHP state.</p> <p>Args:</p> <pre><code>initial_state (Optional[Dict[str, Any]]): Initial state with keys:\n    - 'load_factor': Initial load factor (0-1)\n    If None, uses default initialization.\n</code></pre>"},{"location":"api_reference/components/energy/#set_state_1","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/energy/#step_1","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre> <p>Perform one simulation time step.</p> <p>Args:</p> <pre><code>t (float): Current time in days.\ndt (float): Time step in days.\ninputs (Dict[str, Any]): Input data with keys:\n    - 'Q_ch4': Methane flow rate [m\u00b3/d] (direct input)\n    - 'Q_gas_supplied_m3_per_day': Available biogas from storage [m\u00b3/d]\n    - 'load_setpoint': Desired load factor [0-1] (optional)\n</code></pre> <p>Returns:</p> <pre><code>Dict[str, Any]: Output data with keys:\n    - 'P_el': Electrical power [kW]\n    - 'P_th': Thermal power [kW]\n    - 'Q_gas_consumed': Biogas consumption [m\u00b3/d]\n    - 'Q_gas_out_m3_per_day': Gas demand for connected storages [m\u00b3/d]\n    - 'Q_ch4_remaining': Remaining methane [m\u00b3/d]\n</code></pre>"},{"location":"api_reference/components/energy/#to_dict_1","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize to dictionary.</p> <p>Returns:</p> <pre><code>Dict[str, Any]: Component configuration as dictionary.\n</code></pre> <p>Attributes:</p> <ul> <li>P_el_nom (float): Nominal electrical power in kW.</li> <li>eta_el (float): Electrical efficiency (0-1).</li> <li>eta_th (float): Thermal efficiency (0-1).</li> <li>load_factor (float): Current operating point (0-1).</li> </ul>"},{"location":"api_reference/components/energy/#flare","title":"Flare","text":"<pre><code>from pyadm1.components.energy import Flare\n</code></pre> <p>Flare component for combusting vented biogas.</p> <pre><code>The flare accepts an input `Q_gas_in_m3_per_day` and will combust it.\nIt reports `vented_volume_m3` for the current timestep and `cumulative_vented_m3`.\n\nParameters\n----------\ncomponent_id : str\n    Unique id for the flare component.\ndestruction_efficiency : float\n    Fraction of methane destroyed (0..1). Default 0.98.\nname : Optional[str]\n    Human readable name.\n</code></pre> <p>Signature:</p> <pre><code>Flare(\n    component_id,\n    destruction_efficiency=0.98,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/energy/#add_input_2","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/energy/#add_output_2","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/energy/#get_state_2","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/energy/#initialize_2","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre> <p>Initialize flare internal state.</p> <pre><code>    Args:\n\n        initial_state: optional dict with 'cumulative_vented_m3' to restore state.\n</code></pre>"},{"location":"api_reference/components/energy/#set_state_2","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/energy/#step_2","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre> <p>Process one timestep and combust incoming gas.</p> <pre><code>    Args:\n\n        t: current simulation time [days]\n        dt: timestep length [days]\n        inputs: dictionary that may contain:\n            - 'Q_gas_in_m3_per_day': inflow (m\u00b3/day)\n            - 'CH4_fraction': methane fraction in the gas (0..1). Default 0.6\n\n    Returns:\n\n        outputs_data dict with keys:\n            - 'vented_volume_m3' (this timestep)\n            - 'cumulative_vented_m3'\n            - 'CH4_destroyed_m3' (m\u00b3 of CH4 destroyed this step)\n</code></pre>"},{"location":"api_reference/components/energy/#to_dict_2","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize flare configuration and state.</p>"},{"location":"api_reference/components/energy/#gasstorage","title":"GasStorage","text":"<pre><code>from pyadm1.components.energy import GasStorage\n</code></pre> <p>Gas storage component.</p> <p>Arguments:     component_id: unique id     storage_type: 'membrane' | 'dome' | 'compressed'     capacity_m3: usable gas volume at STP (m^3)     p_min_bar: minimum operating pressure (bar)     p_max_bar: maximum safe pressure (bar)     name: optional human-readable name</p> <p>Signature:</p> <pre><code>GasStorage(\n    component_id,\n    storage_type='membrane',\n    capacity_m3=1000.0,\n    p_min_bar=0.95,\n    p_max_bar=1.05,\n    initial_fill_fraction=0.1,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/energy/#add_input_3","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/energy/#add_output_3","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/energy/#get_state_3","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/energy/#initialize_3","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre> <p>Initialize storage state; initial_state may contain stored_volume_m3, pressure_setpoint_bar.</p>"},{"location":"api_reference/components/energy/#set_state_3","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/energy/#step_3","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre> <p>One simulation step.</p> <p>Args:</p> <pre><code>t:\ndt:\ninputs: Inputs dictionary may contain:\n    - 'Q_gas_in_m3_per_day'   : gas inflow from digesters/other sources (m^3/day)\n    - 'Q_gas_out_m3_per_day'  : requested gas outflow (demand) (m^3/day)\n    - 'set_pressure'          : desired pressure setpoint (bar)  (optional)\n    - 'vent_to_flare'         : bool, if True allow venting to flare when overpressure (default True)\n</code></pre> <p>Returns:</p> <pre><code>object: Returns outputs_data with keys:\n    - 'stored_volume_m3'\n    - 'pressure_bar'\n    - 'utilization' (0-1)\n    - 'vented_volume_m3' (this timestep)\n    - 'Q_gas_supplied_m3_per_day' (actual supply that was delivered)\n</code></pre>"},{"location":"api_reference/components/energy/#to_dict_3","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize configuration + current state.</p>"},{"location":"api_reference/components/feeding/","title":"Feeding","text":"<p>Substrate Feeding and Storage Components</p> <p>Components for substrate handling, storage, and dosing into digesters.</p> <p>Modules:</p> <pre><code>substrate_storage: Storage facilities for different substrate types (silos for\n                  solid substrates, tanks for liquid substrates), with inventory\n                  management, quality degradation over time, and capacity monitoring.\n\nfeeder: Automated dosing systems including screw feeders for solid substrates,\n       progressive cavity pumps for liquid/slurry substrates, and piston feeders\n       for fibrous materials, with flow rate control and dosing accuracy.\n\nmixer_wagon: Mobile substrate preparation systems for mixing multiple substrates\n            before feeding, with mixing efficiency, recipe management, and\n            substrate homogenization.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.components.feeding import SubstrateStorage, Feeder, MixerWagon\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Corn silage storage\n    &gt;&gt;&gt; storage = SubstrateStorage(\"silo1\", substrate_type=\"corn_silage\",\n    ...                           capacity=1000, current_level=800)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Screw feeder for solid substrates\n    &gt;&gt;&gt; feeder = Feeder(\"feed1\", feeder_type=\"screw\",\n    ...                Q_max=20, substrate_type=\"solid\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Mixer wagon for substrate preparation\n    &gt;&gt;&gt; wagon = MixerWagon(\"wagon1\", capacity=30, mixing_time=15)\n</code></pre>"},{"location":"api_reference/components/feeding/#classes","title":"Classes","text":"<ul> <li>Feeder</li> <li>SubstrateStorage</li> </ul>"},{"location":"api_reference/components/feeding/#feeder","title":"Feeder","text":"<pre><code>from pyadm1.components.feeding import Feeder\n</code></pre> <p>Feeder component for automated substrate dosing.</p> <p>Models feeding systems that transfer substrates from storage to digesters. Includes realistic operational characteristics like dosing accuracy, capacity limits, and power consumption.</p> <p>Attributes:</p> <pre><code>feeder_type: Type of feeding system\nQ_max: Maximum flow rate [m\u00b3/d or t/d]\nsubstrate_type: Physical category of substrate\ndosing_accuracy: Accuracy of flow control (std dev as fraction)\npower_installed: Installed motor power [kW]\ncurrent_flow: Current actual flow rate [m\u00b3/d or t/d]\nis_running: Operating state\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; feeder = Feeder(\n    ...     \"feed1\",\n    ...     feeder_type=\"screw\",\n    ...     Q_max=20,\n    ...     substrate_type=\"solid\"\n    ... )\n    &gt;&gt;&gt; feeder.initialize()\n    &gt;&gt;&gt; result = feeder.step(0, 1/24, {'Q_setpoint': 15})\n</code></pre> <p>Signature:</p> <pre><code>Feeder(\n    component_id,\n    feeder_type=None,\n    Q_max=20.0,\n    substrate_type='solid',\n    dosing_accuracy=None,\n    power_installed=None,\n    enable_dosing_noise=True,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/feeding/#add_input","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/feeding/#add_output","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/feeding/#get_state","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/feeding/#initialize","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre> <p>Initialize feeder state.</p> <p>Args:</p> <pre><code>initial_state: Optional initial state with keys:\n    - 'is_running': Initial operating state\n    - 'current_flow': Initial flow rate [m\u00b3/d or t/d]\n    - 'operating_hours': Cumulative operating hours\n    - 'energy_consumed': Cumulative energy [kWh]\n    - 'total_mass_fed': Cumulative mass [t or m\u00b3]\n</code></pre>"},{"location":"api_reference/components/feeding/#set_state","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/feeding/#step","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre> <p>Perform one simulation time step.</p> <p>Args:</p> <pre><code>t: Current time [days]\ndt: Time step [days]\ninputs: Input data with optional keys:\n    - 'Q_setpoint': Desired flow rate [m\u00b3/d or t/d]\n    - 'enable_feeding': Enable/disable feeder\n    - 'substrate_available': Amount available in storage [t or m\u00b3]\n    - 'speed_setpoint': Desired speed fraction (0-1)\n</code></pre> <p>Returns:</p> <pre><code>Dict with keys:\n    - 'Q_actual': Actual flow rate [m\u00b3/d or t/d]\n    - 'is_running': Current operating state\n    - 'load_factor': Operating load (0-1)\n    - 'P_consumed': Power consumption [kW]\n    - 'blockage_detected': Blockage alarm\n    - 'dosing_error': Deviation from setpoint [%]\n    - 'speed_fraction': Current speed fraction\n</code></pre>"},{"location":"api_reference/components/feeding/#to_dict","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize feeder to dictionary.</p> <p>Attributes:</p> <ul> <li>feeder_type: Type of feeding system</li> <li>Q_max: Maximum flow rate [m\u00b3/d or t/d]</li> <li>substrate_type: Physical category of substrate</li> <li>dosing_accuracy: Accuracy of flow control (std dev as fraction)</li> <li>power_installed: Installed motor power [kW]</li> <li>current_flow: Current actual flow rate [m\u00b3/d or t/d]</li> <li>is_running: Operating state</li> </ul>"},{"location":"api_reference/components/feeding/#substratestorage","title":"SubstrateStorage","text":"<pre><code>from pyadm1.components.feeding import SubstrateStorage\n</code></pre> <p>Storage facility component for biogas plant substrates.</p> <p>Models storage of different substrate types with inventory tracking, quality degradation, and capacity management. Supports both solid (silage, solid manure) and liquid (liquid manure, slurry) substrates.</p> <p>Attributes:</p> <pre><code>storage_type: Type of storage facility\nsubstrate_type: Category of substrate stored\ncapacity: Maximum storage capacity [t or m\u00b3]\ncurrent_level: Current inventory level [t or m\u00b3]\nquality_factor: Current quality relative to fresh (0-1)\ndegradation_rate: Quality degradation rate [1/d]\ndensity: Substrate bulk density [kg/m\u00b3]\ndry_matter: Dry matter content [%]\nvs_content: Volatile solids [% of DM]\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; storage = SubstrateStorage(\n    ...     \"silo1\",\n    ...     storage_type=\"vertical_silo\",\n    ...     substrate_type=\"corn_silage\",\n    ...     capacity=1000,\n    ...     initial_level=600\n    ... )\n    &gt;&gt;&gt; storage.initialize()\n    &gt;&gt;&gt; outputs = storage.step(0, 1, {'withdrawal_rate': 15})\n</code></pre> <p>Signature:</p> <pre><code>SubstrateStorage(\n    component_id,\n    storage_type='vertical_silo',\n    substrate_type='corn_silage',\n    capacity=1000.0,\n    initial_level=0.0,\n    degradation_rate=None,\n    temperature=288.15,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/feeding/#add_input_1","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/feeding/#add_output_1","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/feeding/#get_state_1","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/feeding/#initialize_1","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre> <p>Initialize storage state.</p> <p>Args:</p> <pre><code>initial_state: Optional initial state with keys:\n    - 'current_level': Inventory level [t or m\u00b3]\n    - 'quality_factor': Quality factor (0-1)\n    - 'storage_time': Time stored [days]\n    - 'cumulative_losses': Total losses [t or m\u00b3]\n</code></pre>"},{"location":"api_reference/components/feeding/#set_state_1","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/feeding/#step_1","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre> <p>Perform one simulation time step.</p> <p>Args:</p> <pre><code>t: Current time [days]\ndt: Time step [days]\ninputs: Input data with optional keys:\n    - 'withdrawal_rate': Withdrawal rate [t/d or m\u00b3/d]\n    - 'refill_amount': Amount to add [t or m\u00b3]\n    - 'refill_quality': Quality of refill (0-1)\n    - 'temperature': Ambient/storage temperature [K]\n</code></pre> <p>Returns:</p> <pre><code>Dict with keys:\n    - 'current_level': Current inventory [t or m\u00b3]\n    - 'utilization': Fill level (0-1)\n    - 'quality_factor': Current quality (0-1)\n    - 'available_mass': Usable inventory [t or m\u00b3]\n    - 'degradation_rate': Current degradation rate [1/d]\n    - 'losses_this_step': Mass lost this timestep [t or m\u00b3]\n    - 'withdrawn_this_step': Mass withdrawn [t or m\u00b3]\n    - 'is_empty': Storage empty flag\n    - 'is_full': Storage full flag\n</code></pre>"},{"location":"api_reference/components/feeding/#to_dict_1","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize storage to dictionary.</p> <p>Attributes:</p> <ul> <li>storage_type: Type of storage facility</li> <li>substrate_type: Category of substrate stored</li> <li>capacity: Maximum storage capacity [t or m\u00b3]</li> <li>current_level: Current inventory level [t or m\u00b3]</li> <li>quality_factor: Current quality relative to fresh (0-1)</li> <li>degradation_rate: Quality degradation rate [1/d]</li> <li>density: Substrate bulk density [kg/m\u00b3]</li> <li>dry_matter: Dry matter content [%]</li> <li>vs_content: Volatile solids [% of DM]</li> </ul>"},{"location":"api_reference/components/mechanical/","title":"Mechanical","text":"<p>Mechanical Plant Components</p> <p>Mechanical equipment for material handling and process control.</p> <p>Modules:</p> <pre><code>pump: Pump models including centrifugal and positive displacement types,\n     with power consumption calculation, flow rate control, and characteristic\n     curves for different operating points.\n\nmixer: Agitator and stirrer models for digester mixing, including different\n      types (propeller, paddle, jet), with power consumption based on mixing\n      intensity, viscosity, and tank geometry.\n\nvalve: Control and safety valves for flow regulation, including proportional\n      control valves, on/off valves, and pressure relief valves with configurable\n      characteristics and response times.\n\nheat_exchanger: Heat transfer equipment for substrate pre-heating and digestate\n               cooling, supporting different types (plate, tube), with effectiveness\n               calculation and fouling factor consideration.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.components.mechanical import Pump, Mixer, Valve, HeatExchanger\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Substrate feeding pump\n    &gt;&gt;&gt; pump = Pump(\"pump1\", pump_type=\"positive_displacement\",\n    ...            Q_nom=10, pressure_head=5)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Digester mixer\n    &gt;&gt;&gt; mixer = Mixer(\"mix1\", mixer_type=\"propeller\",\n    ...              power=15, mixing_intensity=\"medium\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Heat exchanger for substrate pre-heating\n    &gt;&gt;&gt; hex = HeatExchanger(\"hex1\", effectiveness=0.7, area=50)\n</code></pre>"},{"location":"api_reference/components/mechanical/#classes","title":"Classes","text":"<ul> <li>Mixer</li> <li>Pump</li> </ul>"},{"location":"api_reference/components/mechanical/#mixer","title":"Mixer","text":"<pre><code>from pyadm1.components.mechanical import Mixer\n</code></pre> <p>Mixer/agitator component for biogas digesters. Models mechanical or hydraulic mixing systems that maintain homogeneity in anaerobic digesters. Calculates power consumption based on mixer type, operating conditions, and fluid properties.</p> <p>Attributes:</p> <pre><code>mixer_type: Type of mixer (propeller, paddle, jet)\ntank_volume: Tank volume [m\u00b3]\ntank_diameter: Tank diameter [m]\ntank_height: Tank height [m]\nmixing_intensity: Mixing intensity level\npower_installed: Installed mixer power [kW]\nimpeller_diameter: Impeller diameter [m]\noperating_speed: Mixer rotational speed [rpm]\nintermittent: Intermittent operation mode\non_time_fraction: Fraction of time mixer is on (0-1)\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; mixer = Mixer(\n    ...     \"mix1\",\n    ...     mixer_type=\"propeller\",\n    ...     tank_volume=2000,\n    ...     mixing_intensity=\"medium\"\n    ... )\n    &gt;&gt;&gt; mixer.initialize()\n    &gt;&gt;&gt; result = mixer.step(0, 1/24, {})\n</code></pre> <p>Signature:</p> <pre><code>Mixer(\n    component_id,\n    mixer_type='propeller',\n    tank_volume=2000.0,\n    tank_diameter=None,\n    tank_height=None,\n    mixing_intensity='medium',\n    power_installed=None,\n    impeller_diameter=None,\n    operating_speed=None,\n    intermittent=True,\n    on_time_fraction=0.25,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/mechanical/#add_input","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/mechanical/#add_output","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/mechanical/#get_state","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/mechanical/#initialize","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre> <p>Initialize mixer state.</p> <p>Args:</p> <pre><code>initial_state: Optional initial state dictionary with keys:\n    - 'is_running': Mixer running state\n    - 'current_speed_fraction': Speed fraction (0-1)\n    - 'operating_hours': Cumulative operating hours\n    - 'energy_consumed': Cumulative energy [kWh]\n</code></pre>"},{"location":"api_reference/components/mechanical/#set_state","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/mechanical/#step","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre> <p>Perform one simulation time step.</p> <p>Args:</p> <pre><code>t: Current time [days]\ndt: Time step [days]\ninputs: Input data with optional keys:\n    - 'speed_setpoint': Desired speed fraction (0-1)\n    - 'enable_mixing': Enable/disable mixer\n    - 'fluid_viscosity': Fluid viscosity [Pa\u00b7s]\n    - 'temperature': Fluid temperature [K]\n</code></pre> <p>Returns:</p> <pre><code>Dict with keys:\n    - 'P_consumed': Power consumption [kW]\n    - 'P_average': Time-averaged power [kW]\n    - 'is_running': Current running state\n    - 'mixing_quality': Mixing quality index (0-1)\n    - 'reynolds_number': Reynolds number\n    - 'power_number': Power number\n    - 'mixing_time': Mixing time [min]\n    - 'shear_rate': Average shear rate [1/s]\n</code></pre>"},{"location":"api_reference/components/mechanical/#to_dict","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize mixer to dictionary.</p> <p>Returns:</p> <pre><code>Dictionary representation\n</code></pre> <p>Attributes:</p> <ul> <li>mixer_type: Type of mixer (propeller, paddle, jet)</li> <li>tank_volume: Tank volume [m\u00b3]</li> <li>tank_diameter: Tank diameter [m]</li> <li>tank_height: Tank height [m]</li> <li>mixing_intensity: Mixing intensity level</li> <li>power_installed: Installed mixer power [kW]</li> <li>impeller_diameter: Impeller diameter [m]</li> <li>operating_speed: Mixer rotational speed [rpm]</li> <li>intermittent: Intermittent operation mode</li> <li>on_time_fraction: Fraction of time mixer is on (0-1)</li> </ul>"},{"location":"api_reference/components/mechanical/#pump","title":"Pump","text":"<pre><code>from pyadm1.components.mechanical import Pump\n</code></pre> <p>Pump component for material handling in biogas plants.</p> <p>Models different pump types for substrate feeding, recirculation, and digestate transfer. Calculates power consumption based on flow rate, pressure head, and pump efficiency.</p> <p>Attributes:</p> <pre><code>pump_type: Type of pump (centrifugal, progressive_cavity, piston)\nQ_nom: Nominal flow rate [m\u00b3/h]\npressure_head: Pressure head [m] or [bar]\nefficiency: Pump efficiency at nominal point (0-1)\nmotor_efficiency: Motor efficiency (0-1)\nfluid_density: Fluid density [kg/m\u00b3]\nspeed_control: Enable variable speed drive (VSD)\ncurrent_flow: Current flow rate [m\u00b3/h]\nis_running: Pump operating state\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; pump = Pump(\n    ...     \"feed_pump\",\n    ...     pump_type=\"progressive_cavity\",\n    ...     Q_nom=10.0,\n    ...     pressure_head=50.0\n    ... )\n    &gt;&gt;&gt; pump.initialize()\n    &gt;&gt;&gt; result = pump.step(0, 1/24, {'Q_setpoint': 8.0})\n</code></pre> <p>Signature:</p> <pre><code>Pump(\n    component_id,\n    pump_type='progressive_cavity',\n    Q_nom=10.0,\n    pressure_head=50.0,\n    efficiency=None,\n    motor_efficiency=0.9,\n    fluid_density=1020.0,\n    speed_control=True,\n    name=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/components/mechanical/#add_input_1","title":"<code>add_input()</code>","text":"<pre><code>add_input(component_id)\n</code></pre> <p>Add an input connection.</p>"},{"location":"api_reference/components/mechanical/#add_output_1","title":"<code>add_output()</code>","text":"<pre><code>add_output(component_id)\n</code></pre> <p>Add an output connection.</p>"},{"location":"api_reference/components/mechanical/#get_state_1","title":"<code>get_state()</code>","text":"<pre><code>get_state()\n</code></pre> <p>Get current component state.</p>"},{"location":"api_reference/components/mechanical/#initialize_1","title":"<code>initialize()</code>","text":"<pre><code>initialize(initial_state=None)\n</code></pre> <p>Initialize pump state.</p> <p>Args:</p> <pre><code>initial_state: Optional initial state dictionary with keys:\n    - 'is_running': Initial pump state\n    - 'current_flow': Initial flow rate [m\u00b3/h]\n    - 'operating_hours': Cumulative operating hours\n    - 'energy_consumed': Cumulative energy [kWh]\n    - 'total_volume_pumped': Cumulative volume [m\u00b3]\n</code></pre>"},{"location":"api_reference/components/mechanical/#set_state_1","title":"<code>set_state()</code>","text":"<pre><code>set_state(state)\n</code></pre> <p>Set component state.</p>"},{"location":"api_reference/components/mechanical/#step_1","title":"<code>step()</code>","text":"<pre><code>step(t, dt, inputs)\n</code></pre> <p>Perform one simulation time step.</p> <p>Args:</p> <pre><code>t: Current time [days]\ndt: Time step [days]\ninputs: Input data with optional keys:\n    - 'Q_setpoint': Desired flow rate [m\u00b3/h]\n    - 'enable_pump': Enable/disable pump\n    - 'fluid_density': Fluid density [kg/m\u00b3]\n    - 'fluid_viscosity': Fluid viscosity [Pa\u00b7s]\n    - 'pressure_head': Required pressure head [m]\n</code></pre> <p>Returns:</p> <pre><code>Dict with keys:\n    - 'P_consumed': Power consumption [kW]\n    - 'Q_actual': Actual flow rate [m\u00b3/h]\n    - 'is_running': Current running state\n    - 'efficiency': Current operating efficiency\n    - 'pressure_actual': Actual pressure head [m]\n    - 'speed_fraction': Speed as fraction of nominal\n</code></pre>"},{"location":"api_reference/components/mechanical/#to_dict_1","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize pump to dictionary.</p> <p>Returns:</p> <pre><code>Dictionary representation\n</code></pre> <p>Attributes:</p> <ul> <li>pump_type: Type of pump (centrifugal, progressive_cavity, piston)</li> <li>Q_nom: Nominal flow rate [m\u00b3/h]</li> <li>pressure_head: Pressure head [m] or [bar]</li> <li>efficiency: Pump efficiency at nominal point (0-1)</li> <li>motor_efficiency: Motor efficiency (0-1)</li> <li>fluid_density: Fluid density [kg/m\u00b3]</li> <li>speed_control: Enable variable speed drive (VSD)</li> <li>current_flow: Current flow rate [m\u00b3/h]</li> <li>is_running: Pump operating state</li> </ul>"},{"location":"api_reference/components/sensors/","title":"Sensors","text":"<p>Measurement and Sensor Components</p> <p>Virtual sensors for process monitoring and control, with realistic measurement characteristics including noise, drift, and response times.</p> <p>Modules:</p> <pre><code>physical: Physical property sensors including pH electrodes (with calibration drift),\n         temperature sensors (PT100, thermocouples), pressure transmitters, level\n         sensors, and flow meters with accuracy specifications.\n\nchemical: Chemical analysis sensors for process liquids including VFA analyzers\n         (online titration, GC), ammonia sensors (ion-selective electrodes),\n         COD analyzers (online spectroscopy), and nutrient analyzers.\n\ngas: Gas composition analyzers for biogas quality monitoring including methane\n    sensors (infrared, calorimetric), CO2 sensors, H2S sensors (electrochemical),\n    oxygen sensors, and trace gas analyzers with detection limits.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.components.sensors import PhysicalSensor, ChemicalSensor, GasSensor\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # pH sensor with realistic noise\n    &gt;&gt;&gt; ph_sensor = PhysicalSensor(\"ph1\", sensor_type=\"pH\",\n    ...                           measurement_noise=0.05, drift_rate=0.01)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # VFA analyzer with sampling delay\n    &gt;&gt;&gt; vfa_sensor = ChemicalSensor(\"vfa1\", sensor_type=\"VFA\",\n    ...                            measurement_delay=5, accuracy=0.1)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Methane analyzer\n    &gt;&gt;&gt; ch4_sensor = GasSensor(\"ch4_1\", sensor_type=\"CH4\",\n    ...                       measurement_range=(0, 100), accuracy=0.5)\n</code></pre>"},{"location":"api_reference/configurator/configurator/","title":"Plant Model Configurator and MCP Server","text":"<p>Plant Model Configurator and MCP Server</p> <p>This module provides tools for building, validating, and automatically configuring biogas plant models, including an MCP server for LLM-driven plant design.</p> <p>Modules:</p> <pre><code>plant_builder: BiogasPlant class for assembling components into complete plant\n              models, managing component lifecycle, connections, and providing\n              JSON serialization for model persistence and sharing.\n\nconnection_manager: Connection handling between components including type checking\n                   (liquid, gas, heat, power), flow validation, and dependency\n                   resolution for correct simulation order.\n\nvalidation: Model validation checking for physical consistency (mass/energy balance),\n           completeness (all required connections), and parameter validity with\n           detailed error messages for debugging.\n</code></pre> <p>Subpackages:</p> <pre><code>templates: Pre-defined plant configurations for common biogas plant layouts\n          (single-stage, two-stage, plug-flow, CSTR) serving as starting\n          points for customization or examples for learning.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.configurator import BiogasPlant, ConnectionManager\n    &gt;&gt;&gt; from pyadm1.components.biological import Digester\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Build plant programmatically\n    &gt;&gt;&gt; plant = BiogasPlant(\"My Plant\")\n    &gt;&gt;&gt; plant.add_component(Digester(\"dig1\", feedstock, V_liq=2000))\n    &gt;&gt;&gt; plant.validate()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Save configuration\n    &gt;&gt;&gt; plant.to_json(\"my_plant.json\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Load from template\n    &gt;&gt;&gt; from pyadm1.configurator.templates import TwoStageTemplate\n    &gt;&gt;&gt; plant = TwoStageTemplate.create(feedstock=feedstock)\n</code></pre>"},{"location":"api_reference/configurator/configurator/#subpackages","title":"Subpackages","text":""},{"location":"api_reference/configurator/configurator/#templates","title":"templates","text":"<p>Plant Configuration Templates</p>"},{"location":"api_reference/configurator/configurator/#base-classes","title":"Base Classes","text":"<ul> <li>BiogasPlant</li> <li>Connection</li> <li>ConnectionManager</li> <li>ConnectionType</li> </ul>"},{"location":"api_reference/configurator/configurator/#biogasplant","title":"BiogasPlant","text":"<pre><code>from pyadm1.configurator import BiogasPlant\n</code></pre> <p>Complete biogas plant model with multiple components.</p> <p>Manages component lifecycle, connections, and simulation. Supports JSON-based configuration.</p> <p>Attributes:</p> <pre><code>plant_name (str): Name of the biogas plant.\ncomponents (Dict[str, Component]): Dictionary of all plant components.\nconnections (List[Connection]): List of connections between components.\nsimulation_time (float): Current simulation time in days.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.substrates.feedstock import Feedstock\n    &gt;&gt;&gt; from pyadm1.configurator.plant_builder import BiogasPlant\n    &gt;&gt;&gt; from pyadm1.components.biological.digester import Digester\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; feedstock = Feedstock(feeding_freq=48)\n    &gt;&gt;&gt; plant = BiogasPlant(\"My Plant\")\n    &gt;&gt;&gt; digester = Digester(\"dig1\", feedstock, V_liq=2000)\n    &gt;&gt;&gt; plant.add_component(digester)\n    &gt;&gt;&gt; plant.initialize()\n</code></pre> <p>Signature:</p> <pre><code>BiogasPlant(\n    plant_name='Biogas Plant'\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/configurator/configurator/#add_component","title":"<code>add_component()</code>","text":"<pre><code>add_component(component)\n</code></pre> <p>Add a component to the plant.</p> <p>Args:</p> <pre><code>component (Component): Component to add to the plant.\n</code></pre> <p>Raises:</p> <pre><code>ValueError: If component with same ID already exists.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#add_connection","title":"<code>add_connection()</code>","text":"<pre><code>add_connection(connection)\n</code></pre> <p>Add a connection between components.</p> <p>Args:</p> <pre><code>connection (Connection): Connection to add.\n</code></pre> <p>Raises:</p> <pre><code>ValueError: If source or target component not found.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#get_summary","title":"<code>get_summary()</code>","text":"<pre><code>get_summary()\n</code></pre> <p>Get human-readable summary of plant configuration.</p> <p>Returns:</p> <pre><code>str: Summary text with components and connections.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#initialize","title":"<code>initialize()</code>","text":"<pre><code>initialize()\n</code></pre> <p>Initialize all components.</p> <p>Note: Most components auto-initialize in their constructor. This method is kept for compatibility and to ensure any components that need explicit initialization are handled.</p>"},{"location":"api_reference/configurator/configurator/#simulate","title":"<code>simulate()</code>","text":"<pre><code>simulate(duration, dt=0.041666666666666664, save_interval=None)\n</code></pre> <p>Run simulation for specified duration.</p> <p>Args:</p> <pre><code>duration (float): Simulation duration in days.\ndt (float): Time step in days. Defaults to 1 hour (1/24 day).\nsave_interval (Optional[float]): Interval for saving results in days.\n    If None, saves every step.\n</code></pre> <p>Returns:</p> <pre><code>List[Dict[str, Any]]: Simulation results at each saved time point.\n    Each entry contains 'time' and 'components' with component results.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; results = plant.simulate(duration=30, dt=1/24, save_interval=1.0)\n    &gt;&gt;&gt; print(f\"Simulated {len(results)} time points\")\n</code></pre>"},{"location":"api_reference/configurator/configurator/#step","title":"<code>step()</code>","text":"<pre><code>step(dt)\n</code></pre> <p>Perform one simulation time step for all components.</p> <p>This uses a three-pass execution model: 1. Execute digesters to produce gas \u2192 storages 2. Execute CHPs to determine gas demand \u2192 storages 3. Execute storages to supply gas \u2192 CHPs (re-execute with actual supply)</p> <p>Args:</p> <pre><code>dt (float): Time step in days.\n</code></pre> <p>Returns:</p> <pre><code>Dict[str, Dict[str, Any]]: Results from all components.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#to_json","title":"<code>to_json()</code>","text":"<pre><code>to_json(filepath)\n</code></pre> <p>Save plant configuration to JSON file.</p> <p>Args:</p> <pre><code>filepath (str): Path to JSON file.\n</code></pre> <p>Attributes:</p> <ul> <li>plant_name (str): Name of the biogas plant.</li> <li>components (Dict[str, Component]): Dictionary of all plant components.</li> <li>connections (List[Connection]): List of connections between components.</li> <li>simulation_time (float): Current simulation time in days.</li> </ul>"},{"location":"api_reference/configurator/configurator/#connection","title":"Connection","text":"<pre><code>from pyadm1.configurator import Connection\n</code></pre> <p>Represents a connection between two components.</p> <p>A connection defines a directed link from one component to another, specifying what type of flow or signal is being transferred.</p> <p>Attributes:</p> <pre><code>from_component (str): Source component ID.\nto_component (str): Target component ID.\nconnection_type (str): Type of connection.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; conn = Connection(\"digester_1\", \"chp_1\", \"gas\")\n    &gt;&gt;&gt; config = conn.to_dict()\n</code></pre> <p>Signature:</p> <pre><code>Connection(\n    from_component,\n    to_component,\n    connection_type='default'\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/configurator/configurator/#to_dict","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize to dictionary.</p> <p>Returns:</p> <pre><code>Dict[str, Any]: Dictionary representation of the connection.\n</code></pre> <p>Attributes:</p> <ul> <li>from_component (str): Source component ID.</li> <li>to_component (str): Target component ID.</li> <li>connection_type (str): Type of connection.</li> </ul>"},{"location":"api_reference/configurator/configurator/#connectionmanager","title":"ConnectionManager","text":"<pre><code>from pyadm1.configurator import ConnectionManager\n</code></pre> <p>Manages connections between components in a biogas plant.</p> <p>The ConnectionManager handles connection validation, dependency resolution, and provides utilities for analyzing component relationships.</p> <p>Attributes:</p> <pre><code>connections (List[Connection]): List of all connections.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; manager = ConnectionManager()\n    &gt;&gt;&gt; manager.add_connection(Connection(\"dig1\", \"chp1\", \"gas\"))\n    &gt;&gt;&gt; deps = manager.get_dependencies(\"chp1\")\n    &gt;&gt;&gt; print(deps)  # ['dig1']\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/configurator/configurator/#add_connection_1","title":"<code>add_connection()</code>","text":"<pre><code>add_connection(connection)\n</code></pre> <p>Add a connection to the manager.</p> <p>Args:</p> <pre><code>connection (Connection): Connection to add.\n</code></pre> <p>Raises:</p> <pre><code>ValueError: If connection already exists.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#clear","title":"<code>clear()</code>","text":"<pre><code>clear()\n</code></pre> <p>Remove all connections.</p>"},{"location":"api_reference/configurator/configurator/#get_all_connections","title":"<code>get_all_connections()</code>","text":"<pre><code>get_all_connections()\n</code></pre> <p>Get all connections.</p> <p>Returns:</p> <pre><code>List[Connection]: List of all connections.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#get_connected_components","title":"<code>get_connected_components()</code>","text":"<pre><code>get_connected_components(component_id)\n</code></pre> <p>Get all components connected to the given component (directly or indirectly).</p> <p>Args:</p> <pre><code>component_id (str): Starting component ID.\n</code></pre> <p>Returns:</p> <pre><code>Set[str]: Set of connected component IDs.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#get_connections_from","title":"<code>get_connections_from()</code>","text":"<pre><code>get_connections_from(component_id)\n</code></pre> <p>Get all connections originating from a component.</p> <p>Args:</p> <pre><code>component_id (str): Component ID.\n</code></pre> <p>Returns:</p> <pre><code>List[Connection]: List of outgoing connections.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#get_connections_to","title":"<code>get_connections_to()</code>","text":"<pre><code>get_connections_to(component_id)\n</code></pre> <p>Get all connections terminating at a component.</p> <p>Args:</p> <pre><code>component_id (str): Component ID.\n</code></pre> <p>Returns:</p> <pre><code>List[Connection]: List of incoming connections.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#get_dependencies","title":"<code>get_dependencies()</code>","text":"<pre><code>get_dependencies(component_id)\n</code></pre> <p>Get all components that the given component depends on.</p> <p>Args:</p> <pre><code>component_id (str): Component ID.\n</code></pre> <p>Returns:</p> <pre><code>List[str]: List of component IDs that this component depends on.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#get_dependents","title":"<code>get_dependents()</code>","text":"<pre><code>get_dependents(component_id)\n</code></pre> <p>Get all components that depend on the given component.</p> <p>Args:</p> <pre><code>component_id (str): Component ID.\n</code></pre> <p>Returns:</p> <pre><code>List[str]: List of component IDs that depend on this component.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#get_execution_order","title":"<code>get_execution_order()</code>","text":"<pre><code>get_execution_order(component_ids)\n</code></pre> <p>Determine execution order based on dependencies (topological sort).</p> <p>Args:</p> <pre><code>component_ids (List[str]): List of all component IDs.\n</code></pre> <p>Returns:</p> <pre><code>List[str]: Component IDs in execution order.\n</code></pre> <p>Raises:</p> <pre><code>ValueError: If circular dependencies are detected.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#has_circular_dependency","title":"<code>has_circular_dependency()</code>","text":"<pre><code>has_circular_dependency(component_ids)\n</code></pre> <p>Check if there are circular dependencies.</p> <p>Args:</p> <pre><code>component_ids (List[str]): List of component IDs to check.\n</code></pre> <p>Returns:</p> <pre><code>bool: True if circular dependencies exist, False otherwise.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#remove_connection","title":"<code>remove_connection()</code>","text":"<pre><code>remove_connection(from_component, to_component, connection_type=None)\n</code></pre> <p>Remove a connection.</p> <p>Args:</p> <pre><code>from_component (str): Source component ID.\nto_component (str): Target component ID.\nconnection_type (Optional[str]): Connection type. If None, removes\n    all connections between the components.\n</code></pre> <p>Returns:</p> <pre><code>bool: True if at least one connection was removed, False otherwise.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#to_dict_1","title":"<code>to_dict()</code>","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize all connections to dictionary.</p> <p>Returns:</p> <pre><code>Dict[str, Any]: Dictionary with connection data.\n</code></pre>"},{"location":"api_reference/configurator/configurator/#validate_connections","title":"<code>validate_connections()</code>","text":"<pre><code>validate_connections(component_ids)\n</code></pre> <p>Validate all connections and return list of issues.</p> <p>Args:</p> <pre><code>component_ids (List[str]): List of valid component IDs.\n</code></pre> <p>Returns:</p> <pre><code>List[str]: List of validation error messages. Empty if all valid.\n</code></pre> <p>Attributes:</p> <ul> <li>connections (List[Connection]): List of all connections.</li> </ul>"},{"location":"api_reference/configurator/configurator/#connectiontype","title":"ConnectionType","text":"<pre><code>from pyadm1.configurator import ConnectionType\n</code></pre> <p>Enumeration of connection types between components.</p> <p>Attributes:</p> <pre><code>LIQUID: Liquid flow connection (substrate, digestate).\nGAS: Biogas flow connection.\nHEAT: Heat transfer connection.\nPOWER: Electrical power connection.\nCONTROL: Control signal connection.\nDEFAULT: Generic connection type.\n</code></pre> <p>Signature:</p> <pre><code>ConnectionType(\n    args,\n    kwds\n)\n</code></pre> <p>Attributes:</p> <ul> <li>LIQUID: Liquid flow connection (substrate, digestate).</li> <li>GAS: Biogas flow connection.</li> <li>HEAT: Heat transfer connection.</li> <li>POWER: Electrical power connection.</li> <li>CONTROL: Control signal connection.</li> <li>DEFAULT: Generic connection type.</li> </ul>"},{"location":"api_reference/configurator/templates/","title":"Templates","text":"<p>Plant Configuration Templates</p> <p>Pre-defined biogas plant configurations for common layouts and designs.</p> <p>Modules:</p> <pre><code>single_stage: Single continuously stirred tank reactor (CSTR) with standard\n             peripheral equipment (feeding, CHP, heating), suitable for most\n             agricultural substrates with good degradability.\n\ntwo_stage: Two-stage system with separate hydrolysis and methanogenesis reactors,\n          optimal for substrates with high lignocellulosic content or when\n          process stability is critical, with independent temperature control.\n\ncustom: Custom plant builder with guided configuration for specific requirements,\n       providing interactive setup or programmatic configuration with validation\n       at each step for complex plant designs.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.configurator.templates import (\n    ...     SingleStageTemplate,\n    ...     TwoStageTemplate,\n    ...     CustomPlantBuilder\n    ... )\n    &gt;&gt;&gt; from pyadm1.substrates import Feedstock\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; feedstock = Feedstock(feeding_freq=48)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create single-stage plant\n    &gt;&gt;&gt; plant = SingleStageTemplate.create(\n    ...     feedstock=feedstock,\n    ...     V_liq=2000,\n    ...     P_el_chp=500\n    ... )\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create two-stage plant\n    &gt;&gt;&gt; plant = TwoStageTemplate.create(\n    ...     feedstock=feedstock,\n    ...     V_hydrolysis=500,\n    ...     V_main=2000,\n    ...     T_hydrolysis=318.15,\n    ...     T_main=308.15\n    ... )\n</code></pre>"},{"location":"api_reference/core/core/","title":"Core ADM1 Model","text":"<p>Core ADM1 Implementation</p> <p>This module contains the core implementation of the Anaerobic Digestion Model No. 1 (ADM1) as a pure ODE system without DAEs, specifically adapted for agricultural biogas plants.</p> <p>Modules:</p> <pre><code>adm1: Main ADM1 class implementing the complete ODE system with 37 state variables,\n      including methods for creating influent streams, calculating gas production,\n      and managing simulation state.\n\nadm_params: Static parameter class providing all stoichiometric, kinetic, and\n           physical-chemical parameters for ADM1, including temperature-dependent\n           parameters and pH inhibition factors.\n\nadm_equations: Process rate equations, inhibition functions, and biochemical\n              transformations used in the ADM1 model, separated for clarity\n              and easier modification.\n\nsolver: ODE solver wrapper providing interface to scipy solvers with\n       appropriate settings for stiff systems (BDF method), time step\n       management, and result handling.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.core import ADM1, ADMParams, create_solver\n    &gt;&gt;&gt; from pyadm1.substrates import Feedstock\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create model\n    &gt;&gt;&gt; feedstock = Feedstock(feeding_freq=48)\n    &gt;&gt;&gt; adm1 = ADM1(feedstock, V_liq=2000, T_ad=308.15)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Get parameters\n    &gt;&gt;&gt; params = ADMParams.get_all_params(R=0.08314, T_base=298.15, T_ad=308.15)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create custom solver\n    &gt;&gt;&gt; solver = create_solver(method='BDF', rtol=1e-7)\n</code></pre>"},{"location":"api_reference/core/core/#base-classes","title":"Base Classes","text":"<ul> <li>ADM1</li> <li>ADMParams</li> <li>AcidBaseKinetics</li> <li>AdaptiveODESolver</li> <li>BiochemicalProcesses</li> <li>GasTransfer</li> <li>InhibitionFunctions</li> <li>ODESolver</li> <li>ProcessRates</li> <li>SolverConfig</li> </ul>"},{"location":"api_reference/core/core/#adm1","title":"ADM1","text":"<pre><code>from pyadm1.core import ADM1\n</code></pre> <p>Main class implementing ADM1 as pure ODE system.</p> <p>This class manages the ADM1 state, parameters, and provides methods for simulation including influent stream creation, gas production calculation, and state tracking.</p> <p>Attributes:</p> <pre><code>V_liq: Liquid volume [m\u00b3]\nT_ad: Operating temperature [K]\nfeedstock: Feedstock object for substrate management\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; feedstock = Feedstock(feeding_freq=48)\n    &gt;&gt;&gt; adm1 = ADM1(feedstock, V_liq=2000, T_ad=308.15)\n    &gt;&gt;&gt; adm1.create_influent([15, 10, 0, 0, 0, 0, 0, 0, 0, 0], 0)\n</code></pre> <p>Signature:</p> <pre><code>ADM1(\n    feedstock,\n    V_liq=1977.0,\n    V_gas=304.0,\n    T_ad=308.15\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/core/core/#adm1_ode","title":"<code>ADM1_ODE()</code>","text":"<pre><code>ADM1_ODE(t, state_zero)\n</code></pre> <p>Calculate derivatives for ADM1 ODE system.</p> <p>This is the main ODE function that computes dy/dt for all 37 state variables. Uses process rate equations and stoichiometric relationships.</p> <p>Args:</p> <pre><code>t: Current time [days] (not used, system is autonomous)\nstate_zero: Current ADM1 state vector (37 elements)\n</code></pre> <p>Returns:</p> <pre><code>Tuple of 37 derivatives (dy/dt)\n</code></pre> <p>Note:</p> <pre><code>This method is called by the ODE solver and should not be called\ndirectly by users.\n</code></pre>"},{"location":"api_reference/core/core/#calc_gas","title":"<code>calc_gas()</code>","text":"<pre><code>calc_gas(pi_Sh2, pi_Sch4, pi_Sco2, pTOTAL)\n</code></pre> <p>Calculate biogas production rates from partial pressures.</p> <p>Uses the ideal gas law and Henry's constants to calculate gas flow rates from the gas phase partial pressures.</p> <p>Args:</p> <pre><code>pi_Sh2: Hydrogen partial pressure [bar]\npi_Sch4: Methane partial pressure [bar]\npi_Sco2: CO2 partial pressure [bar]\npTOTAL: Total gas pressure [bar]\n</code></pre> <p>Returns:</p> <pre><code>Tuple containing:\n    - q_gas: Total biogas flow rate [m\u00b3/d]\n    - q_ch4: Methane flow rate [m\u00b3/d]\n    - q_co2: CO2 flow rate [m\u00b3/d]\n    - p_gas: Total gas partial pressure (excl. H2O) [bar]\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; q_gas, q_ch4, q_co2, p_gas = adm1.calc_gas(5e-6, 0.55, 0.42, 0.98)\n    &gt;&gt;&gt; print(f\"Biogas: {q_gas:.1f} m\u00b3/d, Methane: {q_ch4:.1f} m\u00b3/d\")\n</code></pre>"},{"location":"api_reference/core/core/#clear_calibration_parameters","title":"<code>clear_calibration_parameters()</code>","text":"<pre><code>clear_calibration_parameters()\n</code></pre> <p>Clear all calibration parameters and revert to substrate-dependent calculations.</p> <p>Example:</p> <pre><code>    &gt;&gt;&gt; adm1.clear_calibration_parameters()\n</code></pre>"},{"location":"api_reference/core/core/#create_influent","title":"<code>create_influent()</code>","text":"<pre><code>create_influent(Q, i)\n</code></pre> <p>Create ADM1 input stream from volumetric flow rates.</p> <p>Calculates the ADM1 influent state by mixing substrate streams according to their volumetric flow rates. The resulting influent composition is stored internally for use in ODE calculations.</p> <p>Args:</p> <pre><code>Q: Volumetric flow rates for each substrate [m\u00b3/d]\n   Length must equal number of substrates in feedstock\ni: Time step index for accessing influent dataframe\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; adm1.create_influent([15, 10, 0, 0, 0, 0, 0, 0, 0, 0], 0)\n</code></pre>"},{"location":"api_reference/core/core/#get_calibration_parameters","title":"<code>get_calibration_parameters()</code>","text":"<pre><code>get_calibration_parameters()\n</code></pre> <p>Get currently set calibration parameters.</p> <p>Returns:</p> <pre><code>dict: Current calibration parameters as {param_name: value}.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; params = adm1.get_calibration_parameters()\n    &gt;&gt;&gt; print(params)\n    {'k_dis': 0.55, 'Y_su': 0.105}\n</code></pre>"},{"location":"api_reference/core/core/#print_params_at_current_state","title":"<code>print_params_at_current_state()</code>","text":"<pre><code>print_params_at_current_state(state_ADM1xp)\n</code></pre> <p>Calculate and print process parameters from current state.</p> <p>Computes and displays key process indicators including pH, VFA, TAC, and gas production rates. Also stores values in tracking lists.</p> <p>Args:</p> <pre><code>state_ADM1xp: Current ADM1 state vector (37 elements)\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; adm1.print_params_at_current_state(state_vector)\n    pH(lib) = [7.2, 7.3]\n    FOS/TAC = [0.25, 0.26]\n    ...\n</code></pre>"},{"location":"api_reference/core/core/#resume_from_broken_simulation","title":"<code>resume_from_broken_simulation()</code>","text":"<pre><code>resume_from_broken_simulation(Q_CH4)\n</code></pre>"},{"location":"api_reference/core/core/#save_final_state_in_csv","title":"<code>save_final_state_in_csv()</code>","text":"<pre><code>save_final_state_in_csv(simulate_results, filename='digester_final.csv')\n</code></pre> <p>Save final ADM1 state vector to CSV file.</p> <p>Exports only the last state from simulation results, which can be used as initial state for subsequent simulations.</p> <p>Args:</p> <pre><code>simulate_results: List of ADM1 state vectors from simulation\nfilename: Output CSV filename\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; results = [[0.01]*37, [0.02]*37, [0.03]*37]\n    &gt;&gt;&gt; adm1.save_final_state_in_csv(results, 'final_state.csv')\n</code></pre>"},{"location":"api_reference/core/core/#set_calibration_parameters","title":"<code>set_calibration_parameters()</code>","text":"<pre><code>set_calibration_parameters(parameters)\n</code></pre> <p>Set calibration parameters that override substrate-dependent calculations.</p> <p>Args:</p> <pre><code>parameters: Parameter values as {param_name: value}.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; adm1.set_calibration_parameters({\n    ...     'k_dis': 0.55,\n    ...     'k_hyd_ch': 11.0,\n    ...     'Y_su': 0.105\n    ... })\n</code></pre> <p>Attributes:</p> <ul> <li>V_liq: Liquid volume [m\u00b3]</li> <li>T_ad: Operating temperature [K]</li> <li>feedstock: Feedstock object for substrate management</li> </ul>"},{"location":"api_reference/core/core/#admparams","title":"ADMParams","text":"<pre><code>from pyadm1.core import ADMParams\n</code></pre> <p>Static class containing ADM1 model parameters.</p> <p>Signature:</p> <pre><code>ADMParams(\n    args,\n    kwargs\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/core/core/#getadmgasparams","title":"<code>getADMgasparams()</code>","text":"<pre><code>getADMgasparams(R, T_base, T_ad)\n</code></pre> <p>Get gas phase parameters including Henry constants.</p>"},{"location":"api_reference/core/core/#parameters","title":"Parameters","text":"<p>R : float     Gas constant [bar\u00b7M^-1\u00b7K^-1] T_base : float     Base temperature [K] T_ad : float     Digester temperature [K]</p>"},{"location":"api_reference/core/core/#returns","title":"Returns","text":"<p>Tuple[float, float, float, float, float, float]     p_gas_h2o, k_p, k_L_a, K_H_co2, K_H_ch4, K_H_h2</p>"},{"location":"api_reference/core/core/#getadminhibitionparams","title":"<code>getADMinhibitionparams()</code>","text":"<pre><code>getADMinhibitionparams()\n</code></pre> <p>Get pH inhibition parameters.</p>"},{"location":"api_reference/core/core/#returns_1","title":"Returns","text":"<p>Tuple[float, float, float, float, float, float]     K_pH_aa, nn_aa, K_pH_ac, n_ac, K_pH_h2, n_h2</p>"},{"location":"api_reference/core/core/#getadmparams","title":"<code>getADMparams()</code>","text":"<pre><code>getADMparams(R, T_base, T_ad)\n</code></pre> <p>Get all ADM1 stoichiometric and kinetic parameters.</p>"},{"location":"api_reference/core/core/#parameters_1","title":"Parameters","text":"<p>R : float     Gas constant [bar\u00b7M^-1\u00b7K^-1] T_base : float     Base temperature [K] T_ad : float     Digester temperature [K]</p>"},{"location":"api_reference/core/core/#returns_2","title":"Returns","text":"<p>Tuple[float, ...]     All ADM1 parameters (87 values)</p>"},{"location":"api_reference/core/core/#acidbasekinetics","title":"AcidBaseKinetics","text":"<pre><code>from pyadm1.core import AcidBaseKinetics\n</code></pre> <p>Acid-base equilibrium kinetics for ADM1.</p> <p>Signature:</p> <pre><code>AcidBaseKinetics(\n    args,\n    kwargs\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/core/core/#acid_base_rate","title":"<code>acid_base_rate()</code>","text":"<pre><code>acid_base_rate(k_AB, S_ion, S_H_ion, K_a, S_undissociated)\n</code></pre> <p>Calculate acid-base reaction rate.</p> <p>Implements: S_ion + H+ &lt;-&gt; S_undissociated</p> <p>Args:</p> <pre><code>k_AB: Acid-base kinetic constant [M^-1\u00b7d^-1]\nS_ion: Ionized form concentration [M or kg COD/m\u00b3]\nS_H_ion: Hydrogen ion concentration [M]\nK_a: Acid dissociation constant [M]\nS_undissociated: Undissociated form concentration [M or kg COD/m\u00b3]\n</code></pre> <p>Returns:</p> <pre><code>Acid-base reaction rate [M/d or kg COD/(m\u00b3\u00b7d)]\n</code></pre>"},{"location":"api_reference/core/core/#adaptiveodesolver","title":"AdaptiveODESolver","text":"<pre><code>from pyadm1.core import AdaptiveODESolver\n</code></pre> <p>Adaptive ODE solver that adjusts tolerances based on solution behavior.</p> <p>Monitors the solution and can tighten tolerances if instabilities are detected, or relax them for faster computation when solution is smooth.</p> <p>Signature:</p> <pre><code>AdaptiveODESolver(\n    config=None,\n    adaptive=True,\n    min_rtol=1e-08,\n    max_rtol=0.0001\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/core/core/#solve","title":"<code>solve()</code>","text":"<pre><code>solve(fun, t_span, y0, t_eval=None, dense_output=False)\n</code></pre> <p>Solve with adaptive tolerance adjustment.</p> <p>Same interface as parent class but monitors solution quality.</p>"},{"location":"api_reference/core/core/#solve_sequential","title":"<code>solve_sequential()</code>","text":"<pre><code>solve_sequential(fun, t_points, y0)\n</code></pre> <p>Solve ODE system sequentially through multiple time points.</p> <p>Useful for simulations where conditions change at specific times (e.g., substrate feed changes).</p> <p>Args:</p> <pre><code>fun: Right-hand side of ODE system\nt_points: List of time points [days]\ny0: Initial state vector\n</code></pre> <p>Returns:</p> <pre><code>List of state vectors at each time point\n</code></pre>"},{"location":"api_reference/core/core/#solve_to_steady_state","title":"<code>solve_to_steady_state()</code>","text":"<pre><code>solve_to_steady_state(fun, y0, max_time=1000.0, steady_state_tol=1e-06, check_interval=10.0)\n</code></pre> <p>Integrate until steady state is reached or max time exceeded.</p> <p>Args:</p> <pre><code>fun: Right-hand side of ODE system\ny0: Initial state vector\nmax_time: Maximum integration time [days]\nsteady_state_tol: Tolerance for steady state detection\ncheck_interval: Interval for checking steady state [days]\n</code></pre> <p>Returns:</p> <pre><code>Tuple of (final_state, final_time, converged)\n- final_state: State vector at end of integration\n- final_time: Time at end of integration [days]\n- converged: True if steady state was reached\n</code></pre>"},{"location":"api_reference/core/core/#biochemicalprocesses","title":"BiochemicalProcesses","text":"<pre><code>from pyadm1.core import BiochemicalProcesses\n</code></pre> <p>Combined biochemical process calculations for ADM1.</p> <p>This class orchestrates the calculation of all process rates including inhibition factors and stoichiometric relationships.</p> <p>Signature:</p> <pre><code>BiochemicalProcesses(\n    args,\n    kwargs\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/core/core/#calculate_acid_base_rates","title":"<code>calculate_acid_base_rates()</code>","text":"<pre><code>calculate_acid_base_rates(state, acid_base_params)\n</code></pre> <p>Calculate acid-base reaction rates for ODE implementation.</p> <p>Args:</p> <pre><code>state: ADM1 state vector (37 elements)\nacid_base_params: Dictionary containing K_a and k_AB values\n</code></pre> <p>Returns:</p> <pre><code>Tuple of 6 acid-base rates (Rho_A_4 through Rho_A_11)\n</code></pre>"},{"location":"api_reference/core/core/#calculate_gas_transfer_rates","title":"<code>calculate_gas_transfer_rates()</code>","text":"<pre><code>calculate_gas_transfer_rates(state, gas_params, RT, V_liq, V_gas)\n</code></pre> <p>Calculate gas-liquid transfer and gas outlet rates.</p> <p>Args:</p> <pre><code>state: ADM1 state vector (37 elements)\ngas_params: Dictionary containing k_L_a, K_H constants, k_p\nRT: Gas constant \u00d7 temperature [bar\u00b7m\u00b3/kmol]\nV_liq: Liquid volume [m\u00b3]\nV_gas: Gas volume [m\u00b3]\n</code></pre> <p>Returns:</p> <pre><code>Tuple of 4 rates (Rho_T_8, Rho_T_9, Rho_T_10, Rho_T_11)\n</code></pre>"},{"location":"api_reference/core/core/#calculate_inhibition_factors","title":"<code>calculate_inhibition_factors()</code>","text":"<pre><code>calculate_inhibition_factors(S_H_ion, S_h2, S_nh4_ion, S_nh3, K_pH_aa, nn_aa, K_pH_ac, n_ac, K_pH_h2, n_h2, K_S_IN, K_I_h2_fa, K_I_h2_c4, K_I_h2_pro, K_I_nh3)\n</code></pre> <p>Calculate all inhibition factors for ADM1 processes.</p> <p>Args:</p> <pre><code>S_H_ion: Hydrogen ion concentration [M]\nS_h2: Hydrogen gas concentration [kg COD/m\u00b3]\nS_nh4_ion: Ammonium concentration [M]\nS_nh3: Free ammonia concentration [M]\nK_pH_aa: pH inhibition constant for amino acid degraders [M]\nnn_aa: Hill coefficient for aa pH inhibition [-]\nK_pH_ac: pH inhibition constant for acetate degraders [M]\nn_ac: Hill coefficient for ac pH inhibition [-]\nK_pH_h2: pH inhibition constant for hydrogen degraders [M]\nn_h2: Hill coefficient for h2 pH inhibition [-]\nK_S_IN: Nitrogen half-saturation constant [M]\nK_I_h2_fa: H2 inhibition constant for LCFA degraders [kg COD/m\u00b3]\nK_I_h2_c4: H2 inhibition constant for C4 degraders [kg COD/m\u00b3]\nK_I_h2_pro: H2 inhibition constant for propionate degraders [kg COD/m\u00b3]\nK_I_nh3: Ammonia inhibition constant [M]\n</code></pre> <p>Returns:</p> <pre><code>Tuple of inhibition factors (I_pH_aa, I_pH_ac, I_pH_h2, I_IN_lim,\nI_h2_fa, I_h2_c4, I_h2_pro, I_nh3, I_5 through I_12)\n</code></pre>"},{"location":"api_reference/core/core/#calculate_process_rates","title":"<code>calculate_process_rates()</code>","text":"<pre><code>calculate_process_rates(state, inhibitions, kinetic_params, substrate_params, hydro_factor=1.0)\n</code></pre> <p>Calculate all 19 biochemical process rates for ADM1.</p> <p>Args:</p> <pre><code>state: ADM1 state vector (37 elements)\ninhibitions: Tuple of inhibition factors from calculate_inhibition_factors\nkinetic_params: Dictionary of kinetic parameters (k_m, K_S, k_dec, etc.)\nsubstrate_params: Dictionary of substrate-dependent parameters\n    (k_dis, k_hyd_ch, k_hyd_pr, k_hyd_li)\nhydro_factor: Optional TS-dependent hydrolysis factor [-]\n</code></pre> <p>Returns:</p> <pre><code>Tuple of 19 process rates (Rho_1 through Rho_19)\n</code></pre>"},{"location":"api_reference/core/core/#gastransfer","title":"GasTransfer","text":"<pre><code>from pyadm1.core import GasTransfer\n</code></pre> <p>Gas-liquid transfer and gas outlet calculations.</p> <p>Signature:</p> <pre><code>GasTransfer(\n    args,\n    kwargs\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/core/core/#gas_outlet_rate","title":"<code>gas_outlet_rate()</code>","text":"<pre><code>gas_outlet_rate(k_p, p_total, p_ext, V_liq, V_gas)\n</code></pre> <p>Calculate gas outlet flow rate.</p> <p>Args:</p> <pre><code>k_p: Gas outlet friction coefficient [m\u00b3/(m\u00b3\u00b7d\u00b7bar)]\np_total: Total gas pressure [bar]\np_ext: External pressure [bar]\nV_liq: Liquid volume [m\u00b3]\nV_gas: Gas volume [m\u00b3]\n</code></pre> <p>Returns:</p> <pre><code>Gas outlet rate [1/d]\n</code></pre>"},{"location":"api_reference/core/core/#gas_transfer_rate","title":"<code>gas_transfer_rate()</code>","text":"<pre><code>gas_transfer_rate(k_L_a, S_gas_liq, p_gas, K_H, RT, COD_per_mole, V_liq, V_gas)\n</code></pre> <p>Calculate gas-liquid transfer rate.</p> <p>Args:</p> <pre><code>k_L_a: Gas-liquid transfer coefficient [1/d]\nS_gas_liq: Gas concentration in liquid [kg COD/m\u00b3 or kmol/m\u00b3]\np_gas: Partial pressure in gas phase [bar]\nK_H: Henry's law constant [M/bar]\nRT: Gas constant \u00d7 temperature [bar\u00b7m\u00b3/kmol]\nCOD_per_mole: COD per mole of gas [kg COD/kmol]\nV_liq: Liquid volume [m\u00b3]\nV_gas: Gas volume [m\u00b3]\n</code></pre> <p>Returns:</p> <pre><code>Gas transfer rate to gas phase [kg COD/(m\u00b3_gas\u00b7d) or kmol/(m\u00b3_gas\u00b7d)]\n</code></pre>"},{"location":"api_reference/core/core/#inhibitionfunctions","title":"InhibitionFunctions","text":"<pre><code>from pyadm1.core import InhibitionFunctions\n</code></pre> <p>pH and substrate inhibition functions for ADM1 processes.</p> <p>Signature:</p> <pre><code>InhibitionFunctions(\n    args,\n    kwargs\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/core/core/#ammonia_inhibition","title":"<code>ammonia_inhibition()</code>","text":"<pre><code>ammonia_inhibition(S_nh3, K_I_nh3)\n</code></pre> <p>Calculate ammonia inhibition.</p> <p>Args:</p> <pre><code>S_nh3: Free ammonia concentration [M]\nK_I_nh3: Ammonia inhibition constant [M]\n</code></pre> <p>Returns:</p> <pre><code>Inhibition factor between 0 and 1\n</code></pre>"},{"location":"api_reference/core/core/#hydrogen_inhibition","title":"<code>hydrogen_inhibition()</code>","text":"<pre><code>hydrogen_inhibition(S_h2, K_I_h2)\n</code></pre> <p>Calculate non-competitive hydrogen inhibition.</p> <p>Args:</p> <pre><code>S_h2: Hydrogen concentration [kg COD/m\u00b3]\nK_I_h2: Hydrogen inhibition constant [kg COD/m\u00b3]\n</code></pre> <p>Returns:</p> <pre><code>Inhibition factor between 0 and 1\n</code></pre>"},{"location":"api_reference/core/core/#nitrogen_limitation","title":"<code>nitrogen_limitation()</code>","text":"<pre><code>nitrogen_limitation(S_nh4_ion, S_nh3, K_S_IN)\n</code></pre> <p>Calculate inorganic nitrogen limitation factor.</p> <p>Args:</p> <pre><code>S_nh4_ion: Ammonium ion concentration [M]\nS_nh3: Free ammonia concentration [M]\nK_S_IN: Nitrogen half-saturation constant [M]\n</code></pre> <p>Returns:</p> <pre><code>Limitation factor between 0 and 1\n</code></pre>"},{"location":"api_reference/core/core/#ph_inhibition","title":"<code>pH_inhibition()</code>","text":"<pre><code>pH_inhibition(S_H_ion, K_pH, n)\n</code></pre> <p>Calculate pH inhibition factor.</p> <p>Args:</p> <pre><code>S_H_ion: Hydrogen ion concentration [M]\nK_pH: pH inhibition constant [M]\nn: Hill coefficient for pH inhibition [-]\n</code></pre> <p>Returns:</p> <pre><code>Inhibition factor between 0 and 1\n</code></pre>"},{"location":"api_reference/core/core/#substrate_inhibition","title":"<code>substrate_inhibition()</code>","text":"<pre><code>substrate_inhibition(S, K_S)\n</code></pre> <p>Calculate Monod substrate limitation factor.</p> <p>Args:</p> <pre><code>S: Substrate concentration [kg COD/m\u00b3]\nK_S: Half-saturation constant [kg COD/m\u00b3]\n</code></pre> <p>Returns:</p> <pre><code>Limitation factor between 0 and 1\n</code></pre>"},{"location":"api_reference/core/core/#odesolver","title":"ODESolver","text":"<pre><code>from pyadm1.core import ODESolver\n</code></pre> <p>ODE solver wrapper for ADM1 system.</p> <p>Provides a clean interface to scipy's solve_ivp with appropriate settings for stiff biogas process ODEs. Uses BDF (Backward Differentiation Formula) method which is suitable for stiff systems.</p> <p>Example:</p> <pre><code>    &gt;&gt;&gt; def ode_func(t, y):\n    ...     return [-0.5 * y[0], 0.5 * y[0] - 0.1 * y[1]]\n    &gt;&gt;&gt; solver = ODESolver()\n    &gt;&gt;&gt; result = solver.solve(ode_func, [0, 10], [1.0, 0.0])\n    &gt;&gt;&gt; print(result.y[:, -1])  # Final state\n</code></pre> <p>Signature:</p> <pre><code>ODESolver(\n    config=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/core/core/#solve_1","title":"<code>solve()</code>","text":"<pre><code>solve(fun, t_span, y0, t_eval=None, dense_output=False)\n</code></pre> <p>Solve ODE system over time span.</p> <p>Args:</p> <pre><code>fun: Right-hand side of ODE system dy/dt = fun(t, y)\nt_span: Integration time span (t_start, t_end) [days]\ny0: Initial state vector\nt_eval: Times at which to store solution. If None, uses automatic\n    time points with 0.05 day resolution\ndense_output: If True, returns continuous solution object\n</code></pre> <p>Returns:</p> <pre><code>OdeResult object with solution (from scipy.integrate.solve_ivp)\n</code></pre> <p>Raises:</p> <pre><code>RuntimeError: If integration fails\n</code></pre>"},{"location":"api_reference/core/core/#solve_sequential_1","title":"<code>solve_sequential()</code>","text":"<pre><code>solve_sequential(fun, t_points, y0)\n</code></pre> <p>Solve ODE system sequentially through multiple time points.</p> <p>Useful for simulations where conditions change at specific times (e.g., substrate feed changes).</p> <p>Args:</p> <pre><code>fun: Right-hand side of ODE system\nt_points: List of time points [days]\ny0: Initial state vector\n</code></pre> <p>Returns:</p> <pre><code>List of state vectors at each time point\n</code></pre>"},{"location":"api_reference/core/core/#solve_to_steady_state_1","title":"<code>solve_to_steady_state()</code>","text":"<pre><code>solve_to_steady_state(fun, y0, max_time=1000.0, steady_state_tol=1e-06, check_interval=10.0)\n</code></pre> <p>Integrate until steady state is reached or max time exceeded.</p> <p>Args:</p> <pre><code>fun: Right-hand side of ODE system\ny0: Initial state vector\nmax_time: Maximum integration time [days]\nsteady_state_tol: Tolerance for steady state detection\ncheck_interval: Interval for checking steady state [days]\n</code></pre> <p>Returns:</p> <pre><code>Tuple of (final_state, final_time, converged)\n- final_state: State vector at end of integration\n- final_time: Time at end of integration [days]\n- converged: True if steady state was reached\n</code></pre>"},{"location":"api_reference/core/core/#processrates","title":"ProcessRates","text":"<pre><code>from pyadm1.core import ProcessRates\n</code></pre> <p>Biochemical process rate calculations for ADM1.</p> <p>Signature:</p> <pre><code>ProcessRates(\n    args,\n    kwargs\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/core/core/#decay_rate","title":"<code>decay_rate()</code>","text":"<pre><code>decay_rate(k_dec, X_biomass)\n</code></pre> <p>Calculate biomass decay rate.</p> <p>Args:</p> <pre><code>k_dec: Decay rate constant [1/d]\nX_biomass: Biomass concentration [kg COD/m\u00b3]\n</code></pre> <p>Returns:</p> <pre><code>Decay rate [kg COD/(m\u00b3\u00b7d)]\n</code></pre>"},{"location":"api_reference/core/core/#disintegration_rate","title":"<code>disintegration_rate()</code>","text":"<pre><code>disintegration_rate(k_dis, X_xc)\n</code></pre> <p>Calculate disintegration rate of composites.</p> <p>Args:</p> <pre><code>k_dis: Disintegration rate constant [1/d]\nX_xc: Composite concentration [kg COD/m\u00b3]\n</code></pre> <p>Returns:</p> <pre><code>Disintegration rate [kg COD/(m\u00b3\u00b7d)]\n</code></pre>"},{"location":"api_reference/core/core/#hydrolysis_rate","title":"<code>hydrolysis_rate()</code>","text":"<pre><code>hydrolysis_rate(k_hyd, X_substrate, hydro_factor=1.0)\n</code></pre> <p>Calculate hydrolysis rate (carbohydrates, proteins, lipids).</p> <p>Args:</p> <pre><code>k_hyd: Hydrolysis rate constant [1/d]\nX_substrate: Particulate substrate concentration [kg COD/m\u00b3]\nhydro_factor: Optional TS-dependent factor [-]\n</code></pre> <p>Returns:</p> <pre><code>Hydrolysis rate [kg COD/(m\u00b3\u00b7d)]\n</code></pre>"},{"location":"api_reference/core/core/#uptake_rate","title":"<code>uptake_rate()</code>","text":"<pre><code>uptake_rate(k_m, S_substrate, K_S, X_biomass, I_combined)\n</code></pre> <p>Calculate Monod uptake rate with inhibition.</p> <p>Args:</p> <pre><code>k_m: Maximum uptake rate constant [1/d]\nS_substrate: Substrate concentration [kg COD/m\u00b3]\nK_S: Half-saturation constant [kg COD/m\u00b3]\nX_biomass: Biomass concentration [kg COD/m\u00b3]\nI_combined: Combined inhibition factor [-]\n</code></pre> <p>Returns:</p> <pre><code>Uptake rate [kg COD/(m\u00b3\u00b7d)]\n</code></pre>"},{"location":"api_reference/core/core/#solverconfig","title":"SolverConfig","text":"<pre><code>from pyadm1.core import SolverConfig\n</code></pre> <p>Configuration for ODE solver.</p> <p>Attributes:</p> <pre><code>method: Integration method ('BDF' for stiff ODEs)\nrtol: Relative tolerance for solver\natol: Absolute tolerance for solver\nmin_step: Minimum allowed time step [days]\nmax_step: Maximum allowed time step [days]\nfirst_step: Initial step size [days]\n</code></pre> <p>Signature:</p> <pre><code>SolverConfig(\n    method='BDF',\n    rtol=1e-06,\n    atol=1e-08,\n    min_step=1e-06,\n    max_step=0.1,\n    first_step=None\n)\n</code></pre> <p>Methods:</p> <p>Attributes:</p> <ul> <li>method: Integration method ('BDF' for stiff ODEs)</li> <li>rtol: Relative tolerance for solver</li> <li>atol: Absolute tolerance for solver</li> <li>min_step: Minimum allowed time step [days]</li> <li>max_step: Maximum allowed time step [days]</li> <li>first_step: Initial step size [days]</li> </ul>"},{"location":"api_reference/simulation/simulation/","title":"Simulation Engine","text":"<p>Simulation Engine</p> <p>Core simulation functionality for single and parallel execution of biogas plant models.</p> <p>The Simulator class has been refactored to use the new solver architecture from pyadm1.core.solver, providing better separation of concerns and improved testability.</p> <p>Modules:</p> <pre><code>simulator: Main Simulator class orchestrating single plant simulation runs, managing\n          time stepping using the ODESolver interface, state updates, and result\n          collection with progress reporting and error handling.\n\nparallel: ParallelSimulator for concurrent execution of multiple scenarios with\n         different parameter sets, substrate mixtures, or operating conditions\n         using multiprocessing for efficient parameter sweeps and Monte Carlo\n         simulations.\n\nscenarios: Scenario management system for defining, organizing, and comparing\n          different simulation configurations including parameter variations,\n          substrate schedules, and operational strategies with metadata tracking.\n\ntime_series: Time series data handling for simulation inputs (substrate feeds,\n            temperatures, prices) and outputs (gas production, concentrations,\n            power) with interpolation, resampling, and statistical analysis.\n\nresults: Result management and analysis including data extraction, aggregation,\n        comparison between scenarios, statistical summaries, and export in\n        various formats (CSV, JSON, HDF5) for further processing.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.simulation import Simulator, ParallelSimulator\n    &gt;&gt;&gt; from pyadm1.core import ADM1, create_solver\n    &gt;&gt;&gt; from pyadm1.substrates import Feedstock\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create model\n    &gt;&gt;&gt; feedstock = Feedstock(feeding_freq=48)\n    &gt;&gt;&gt; adm1 = ADM1(feedstock)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Single simulation\n    &gt;&gt;&gt; solver = create_solver(method='BDF', rtol=1e-7)\n    &gt;&gt;&gt; simulator = Simulator(adm1, solver=solver)\n    &gt;&gt;&gt; initial_state = [0.01] * 37\n    &gt;&gt;&gt; final_state = simulator.simulate_AD_plant([0, 30], initial_state)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Parallel simulations\n    &gt;&gt;&gt; parallel = ParallelSimulator(adm1, n_workers=4)\n    &gt;&gt;&gt; scenarios = [{\"k_dis\": 0.5, \"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]}]\n    &gt;&gt;&gt; results = parallel.run_scenarios(scenarios, duration=30, initial_state=initial_state)\n</code></pre>"},{"location":"api_reference/simulation/simulation/#base-classes","title":"Base Classes","text":"<ul> <li>MonteCarloConfig</li> <li>ParallelSimulator</li> <li>ParameterSweepConfig</li> <li>ScenarioResult</li> <li>Simulator</li> </ul>"},{"location":"api_reference/simulation/simulation/#montecarloconfig","title":"MonteCarloConfig","text":"<pre><code>from pyadm1.simulation import MonteCarloConfig\n</code></pre> <p>Configuration for Monte Carlo simulation.</p> <p>Attributes:</p> <pre><code>n_samples: Number of Monte Carlo samples\nparameter_distributions: Dict mapping parameter names to (mean, std) tuples\nfixed_params: Parameters to keep fixed\nseed: Random seed for reproducibility\n</code></pre> <p>Signature:</p> <pre><code>MonteCarloConfig(\n    n_samples,\n    parameter_distributions,\n    fixed_params=&lt;factory&gt;,\n    seed=None\n)\n</code></pre> <p>Methods:</p> <p>Attributes:</p> <ul> <li>n_samples: Number of Monte Carlo samples</li> <li>parameter_distributions: Dict mapping parameter names to (mean, std) tuples</li> <li>fixed_params: Parameters to keep fixed</li> <li>seed: Random seed for reproducibility</li> </ul>"},{"location":"api_reference/simulation/simulation/#parallelsimulator","title":"ParallelSimulator","text":"<pre><code>from pyadm1.simulation import ParallelSimulator\n</code></pre> <p>Parallel simulator for running multiple ADM1 scenarios concurrently.</p> <p>Uses multiprocessing to distribute scenarios across CPU cores for efficient parameter sweeps, sensitivity analysis, and Monte Carlo simulations.</p> <p>Attributes:</p> <pre><code>adm1: Base ADM1 model instance (will be copied for each worker)\nn_workers: Number of parallel worker processes\nverbose: Enable progress reporting\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; parallel = ParallelSimulator(adm1, n_workers=4, verbose=True)\n    &gt;&gt;&gt; results = parallel.run_scenarios(scenarios, duration=30)\n</code></pre> <p>Signature:</p> <pre><code>ParallelSimulator(\n    adm1,\n    n_workers=None,\n    verbose=True\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/simulation/simulation/#monte_carlo","title":"<code>monte_carlo()</code>","text":"<pre><code>monte_carlo(config, duration, initial_state, kwargs)\n</code></pre> <p>Run Monte Carlo simulation with parameter uncertainty.</p> <p>Samples parameters from normal distributions and runs multiple scenarios to quantify uncertainty in predictions.</p> <p>Args:</p> <pre><code>config: MonteCarloConfig with distributions and sample count\nduration: Simulation duration [days]\ninitial_state: Initial ADM1 state vector\n**kwargs: Additional arguments for run_scenarios\n</code></pre> <p>Returns:</p> <pre><code>List of ScenarioResult objects\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; config = MonteCarloConfig(\n    ...     n_samples=100,\n    ...     parameter_distributions={\n    ...         \"k_dis\": (0.5, 0.05),  # mean=0.5, std=0.05\n    ...         \"Y_su\": (0.10, 0.01)\n    ...     },\n    ...     fixed_params={\"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]},\n    ...     seed=42\n    ... )\n    &gt;&gt;&gt; results = parallel.monte_carlo(config, duration=30, initial_state=state)\n</code></pre>"},{"location":"api_reference/simulation/simulation/#multi_parameter_sweep","title":"<code>multi_parameter_sweep()</code>","text":"<pre><code>multi_parameter_sweep(parameter_configs, duration, initial_state, fixed_params=None, kwargs)\n</code></pre> <p>Run multi-parameter sweep (full factorial design).</p> <p>Tests all combinations of provided parameter values.</p> <p>Args:</p> <pre><code>parameter_configs: Dict mapping parameter names to value lists\nduration: Simulation duration [days]\ninitial_state: Initial ADM1 state vector\nfixed_params: Parameters to keep fixed\n**kwargs: Additional arguments for run_scenarios\n</code></pre> <p>Returns:</p> <pre><code>List of ScenarioResult objects\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; parameter_configs = {\n    ...     \"k_dis\": [0.4, 0.5, 0.6],\n    ...     \"Y_su\": [0.09, 0.10, 0.11]\n    ... }\n    &gt;&gt;&gt; results = parallel.multi_parameter_sweep(\n    ...     parameter_configs,\n    ...     duration=30,\n    ...     initial_state=state,\n    ...     fixed_params={\"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]}\n    ... )\n</code></pre>"},{"location":"api_reference/simulation/simulation/#parameter_sweep","title":"<code>parameter_sweep()</code>","text":"<pre><code>parameter_sweep(config, duration, initial_state, kwargs)\n</code></pre> <p>Run parameter sweep for a single parameter.</p> <p>Tests multiple values of one parameter while keeping others fixed.</p> <p>Args:</p> <pre><code>config: ParameterSweepConfig with parameter and values\nduration: Simulation duration [days]\ninitial_state: Initial ADM1 state vector\n**kwargs: Additional arguments for run_scenarios\n</code></pre> <p>Returns:</p> <pre><code>List of ScenarioResult objects\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; config = ParameterSweepConfig(\n    ...     parameter_name=\"k_dis\",\n    ...     values=[0.3, 0.4, 0.5, 0.6, 0.7],\n    ...     other_params={\"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]}\n    ... )\n    &gt;&gt;&gt; results = parallel.parameter_sweep(config, duration=30, initial_state=state)\n</code></pre>"},{"location":"api_reference/simulation/simulation/#run_scenarios","title":"<code>run_scenarios()</code>","text":"<pre><code>run_scenarios(scenarios, duration, initial_state, dt=0.041666666666666664, compute_metrics=True, save_time_series=False)\n</code></pre> <p>Run multiple simulation scenarios in parallel.</p> <p>Each scenario is a dictionary containing parameter values and substrate feed rates. The simulator will run all scenarios concurrently and collect results.</p> <p>Args:</p> <pre><code>scenarios: List of scenario dictionaries with parameters\nduration: Simulation duration [days]\ninitial_state: Initial ADM1 state vector\ndt: Time step [days]\ncompute_metrics: Calculate performance metrics\nsave_time_series: Save full time series data\n</code></pre> <p>Returns:</p> <pre><code>List of ScenarioResult objects\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; scenarios = [\n    ...     {\"k_dis\": 0.5, \"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]},\n    ...     {\"k_dis\": 0.6, \"Q\": [20, 10, 0, 0, 0, 0, 0, 0, 0, 0]},\n    ... ]\n    &gt;&gt;&gt; results = parallel.run_scenarios(scenarios, duration=30, initial_state=state)\n</code></pre>"},{"location":"api_reference/simulation/simulation/#summarize_results","title":"<code>summarize_results()</code>","text":"<pre><code>summarize_results(results, metrics=None)\n</code></pre> <p>Summarize results from multiple scenarios.</p> <p>Computes statistics (mean, std, min, max) for each metric across all successful scenarios.</p> <p>Args:</p> <pre><code>results: List of ScenarioResult objects\nmetrics: List of metric names to summarize (default: all)\n</code></pre> <p>Returns:</p> <pre><code>Dictionary with summary statistics\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; summary = parallel.summarize_results(results)\n    &gt;&gt;&gt; print(f\"Mean CH4: {summary['Q_ch4']['mean']:.1f} m\u00b3/d\")\n</code></pre> <p>Attributes:</p> <ul> <li>adm1: Base ADM1 model instance (will be copied for each worker)</li> <li>n_workers: Number of parallel worker processes</li> <li>verbose: Enable progress reporting</li> </ul>"},{"location":"api_reference/simulation/simulation/#parametersweepconfig","title":"ParameterSweepConfig","text":"<pre><code>from pyadm1.simulation import ParameterSweepConfig\n</code></pre> <p>Configuration for parameter sweep.</p> <p>Attributes:</p> <pre><code>parameter_name: Name of parameter to sweep\nvalues: List of values to test\nother_params: Fixed parameters for all scenarios\n</code></pre> <p>Signature:</p> <pre><code>ParameterSweepConfig(\n    parameter_name,\n    values,\n    other_params=&lt;factory&gt;\n)\n</code></pre> <p>Methods:</p> <p>Attributes:</p> <ul> <li>parameter_name: Name of parameter to sweep</li> <li>values: List of values to test</li> <li>other_params: Fixed parameters for all scenarios</li> </ul>"},{"location":"api_reference/simulation/simulation/#scenarioresult","title":"ScenarioResult","text":"<pre><code>from pyadm1.simulation import ScenarioResult\n</code></pre> <p>Result from a single simulation scenario.</p> <p>Attributes:</p> <pre><code>scenario_id: Unique identifier for this scenario\nparameters: Parameter values used in this scenario\nsuccess: Whether simulation completed successfully\nduration: Simulation duration [days]\nfinal_state: Final ADM1 state vector\ntime_series: Optional time series data\nmetrics: Computed performance metrics\nerror: Error message if simulation failed\nexecution_time: Wall clock time for execution [seconds]\n</code></pre> <p>Signature:</p> <pre><code>ScenarioResult(\n    scenario_id,\n    parameters,\n    success,\n    duration,\n    final_state=None,\n    time_series=None,\n    metrics=&lt;factory&gt;,\n    error=None,\n    execution_time=0.0\n)\n</code></pre> <p>Methods:</p> <p>Attributes:</p> <ul> <li>scenario_id: Unique identifier for this scenario</li> <li>parameters: Parameter values used in this scenario</li> <li>success: Whether simulation completed successfully</li> <li>duration: Simulation duration [days]</li> <li>final_state: Final ADM1 state vector</li> <li>time_series: Optional time series data</li> <li>metrics: Computed performance metrics</li> <li>error: Error message if simulation failed</li> <li>execution_time: Wall clock time for execution [seconds]</li> </ul>"},{"location":"api_reference/simulation/simulation/#simulator","title":"Simulator","text":"<pre><code>from pyadm1.simulation import Simulator\n</code></pre> <p>Handles ADM1 simulation runs with various configurations.</p> <p>This class provides high-level interfaces for running ADM1 simulations, including single runs and multi-scenario optimization for substrate feed determination.</p> <p>Attributes:</p> <pre><code>adm1: ADM1 model instance\nsolver: ODE solver instance\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; simulator = Simulator(adm1)\n    &gt;&gt;&gt; result = simulator.simulate_AD_plant([0, 10], initial_state)\n</code></pre> <p>Signature:</p> <pre><code>Simulator(\n    adm1,\n    solver=None\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/simulation/simulation/#determine_best_feed_by_n_sims","title":"<code>determine_best_feed_by_n_sims()</code>","text":"<pre><code>determine_best_feed_by_n_sims(state_zero, Q, Qch4sp, feeding_freq, n=13)\n</code></pre> <p>Determine optimal substrate feed by running n simulations.</p> <p>Runs n simulations with varying substrate feed rates around Q and returns the feed rate yielding methane production closest to setpoint.</p> <p>The first simulation uses Q, the 2nd and 3rd use Q \u00b1 1.5 m\u00b3/d, and remaining simulations use random variations.</p> <p>Args:</p> <pre><code>state_zero: Initial ADM1 state vector (37 elements)\nQ: Initial volumetric flow rates [m\u00b3/d], e.g. [15, 10, 0, ...]\nQch4sp: Methane flow rate setpoint [m\u00b3/d]\nfeeding_freq: Feeding frequency [hours]\nn: Number of simulations to run (default: 13, minimum: 3)\n</code></pre> <p>Returns:</p> <pre><code>Tuple containing:\n    - Q_Gas_7d_best: Best biogas production after 7 days [m\u00b3/d]\n    - Q_CH4_7d_best: Best methane production after 7 days [m\u00b3/d]\n    - Qbest: Best substrate feed rates [m\u00b3/d]\n    - Q_Gas_7d_initial: Initial biogas production after 7 days [m\u00b3/d]\n    - Q_CH4_7d_initial: Initial methane production after 7 days [m\u00b3/d]\n    - Q_initial: Initial substrate feed rates [m\u00b3/d]\n    - q_gas_best_2d: Best biogas after feeding_freq/24 days [m\u00b3/d]\n    - q_ch4_best_2d: Best methane after feeding_freq/24 days [m\u00b3/d]\n    - q_gas_2d: Initial biogas after feeding_freq/24 days [m\u00b3/d]\n    - q_ch4_2d: Initial methane after feeding_freq/24 days [m\u00b3/d]\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; result = simulator.determine_best_feed_by_n_sims(\n    ...     state, [15, 10, 0, 0, 0, 0, 0, 0, 0, 0], 900, 48, n=13\n    ... )\n    &gt;&gt;&gt; Q_best = result[2]\n</code></pre>"},{"location":"api_reference/simulation/simulation/#simulate_ad_plant","title":"<code>simulate_AD_plant()</code>","text":"<pre><code>simulate_AD_plant(tstep, state_zero)\n</code></pre> <p>Simulate ADM1 for specified time span and return final state.</p> <p>This is the main simulation method that integrates the ADM1 ODEs and tracks process values for operator information.</p> <p>Args:</p> <pre><code>tstep: Time span [t_start, t_end] in days\nstate_zero: Initial ADM1 state vector (37 elements)\n</code></pre> <p>Returns:</p> <pre><code>Final ADM1 state vector after simulation (37 elements)\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; final_state = simulator.simulate_AD_plant([0, 1], initial_state)\n    &gt;&gt;&gt; print(f\"Final pH: {final_state[...])\n</code></pre> <p>Attributes:</p> <ul> <li>adm1: ADM1 model instance</li> <li>solver: ODE solver instance</li> </ul>"},{"location":"api_reference/substrates/substrates/","title":"Substrate Management and Characterization","text":"<p>Substrate Management and Characterization</p> <p>This module handles substrate definitions, characterization, and ADM1 input stream calculation for agricultural biogas substrates.</p> <p>Modules:</p> <pre><code>feedstock: Main Feedstock class managing substrate mixing and ADM1 input stream\n          generation, with support for time-varying substrate feeds and automatic\n          weighting of substrate properties based on volumetric flow rates.\n\nsubstrate_db: Database interface for substrate properties including built-in\n             database of common agricultural substrates (energy crops, manures,\n             organic waste) with literature values and local calibrations.\n\nxml_loader: Parser for substrate definition XML files following the schema used\n           in SIMBA and other biogas simulation tools, with validation and\n           error handling for malformed substrate definitions.\n\ncharacterization: Substrate characterization methods for converting laboratory\n                 analysis data (Weender, Van Soest, BMP) into ADM1 model\n                 parameters, including COD fractionation and stoichiometry.\n</code></pre> <p>Example:</p> <pre><code>    &gt;&gt;&gt; from pyadm1.substrates import Feedstock, SubstrateDB\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Load substrates from database\n    &gt;&gt;&gt; db = SubstrateDB()\n    &gt;&gt;&gt; corn_silage = db.get_substrate(\"corn_silage\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create feedstock for simulation\n    &gt;&gt;&gt; feedstock = Feedstock(feeding_freq=48)\n    &gt;&gt;&gt; Q = [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]  # m\u00b3/d for each substrate\n    &gt;&gt;&gt; influent_df = feedstock.get_influent_dataframe(Q)\n</code></pre>"},{"location":"api_reference/substrates/substrates/#base-classes","title":"Base Classes","text":"<ul> <li>Feedstock</li> </ul>"},{"location":"api_reference/substrates/substrates/#feedstock","title":"Feedstock","text":"<pre><code>from pyadm1.substrates import Feedstock\n</code></pre> <p>Manages substrate information and creates ADM1 input streams.</p> <p>Substrate parameters are loaded from XML files and processed via C# DLLs to generate ADM1-compatible input streams.</p> <p>Signature:</p> <pre><code>Feedstock(\n    feeding_freq,\n    total_simtime=60,\n    substrate_xml='substrate_gummersbach.xml'\n)\n</code></pre> <p>Methods:</p>"},{"location":"api_reference/substrates/substrates/#get_influent_dataframe","title":"<code>get_influent_dataframe()</code>","text":"<pre><code>get_influent_dataframe(Q)\n</code></pre> <p>Generate ADM1 input stream as DataFrame for entire simulation.</p> <p>The input stream is constant over the simulation duration and depends on the volumetric flow rate of each substrate.</p>"},{"location":"api_reference/substrates/substrates/#parameters","title":"Parameters","text":"<p>Q : List[float]     Volumetric flow rates [m\u00b3/d], e.g., [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]</p>"},{"location":"api_reference/substrates/substrates/#returns","title":"Returns","text":"<p>pd.DataFrame     ADM1 input stream with columns: time, S_su, S_aa, ..., Q</p>"},{"location":"api_reference/substrates/substrates/#get_substrate_feed_mixtures","title":"<code>get_substrate_feed_mixtures()</code>","text":"<pre><code>get_substrate_feed_mixtures(Q, n=13)\n</code></pre>"},{"location":"api_reference/substrates/substrates/#header","title":"<code>header()</code>","text":"<pre><code>header()\n</code></pre> <p>Names of ADM1 input stream components.</p>"},{"location":"api_reference/substrates/substrates/#mysubstrates","title":"<code>mySubstrates()</code>","text":"<pre><code>mySubstrates()\n</code></pre> <p>Substrates object from C# DLL.</p>"},{"location":"api_reference/substrates/substrates/#simtime","title":"<code>simtime()</code>","text":"<pre><code>simtime()\n</code></pre> <p>Simulation time array [days].</p>"},{"location":"development/TESTING/","title":"Testing PyADM1ODE","text":""},{"location":"development/TESTING/#overview","title":"Overview","text":"<p>This project includes unit tests for the core ADM1 functionality. However, some tests require the .NET/Mono runtime to be available because they test components that interact with C# DLLs via <code>pythonnet</code>.</p>"},{"location":"development/TESTING/#requirements","title":"Requirements","text":""},{"location":"development/TESTING/#for-basic-tests","title":"For Basic Tests","text":"<ul> <li>Python 3.8+</li> <li>pytest</li> <li>numpy</li> <li>pandas</li> <li>scipy</li> </ul>"},{"location":"development/TESTING/#for-full-test-suite-including-net-dependent-tests","title":"For Full Test Suite (including .NET-dependent tests)","text":"<ul> <li>All basic requirements</li> <li>Mono runtime (Linux/macOS) or .NET Framework (Windows)</li> <li>pythonnet</li> <li>C# DLLs in the <code>dlls/</code> directory (included in repository)</li> <li>Windows only: vs2015_runtime</li> </ul>"},{"location":"development/TESTING/#running-tests","title":"Running Tests","text":""},{"location":"development/TESTING/#run-all-available-tests","title":"Run All Available Tests","text":"<pre><code>pytest\n</code></pre> <p>This will automatically skip tests that require .NET if the runtime is not available.</p>"},{"location":"development/TESTING/#run-only-tests-that-dont-require-net","title":"Run Only Tests That Don't Require .NET","text":"<pre><code>pytest -m \"not requires_dotnet\"\n</code></pre>"},{"location":"development/TESTING/#view-skipped-test-information","title":"View Skipped Test Information","text":"<pre><code>pytest -v -rs\n</code></pre> <p>The <code>-rs</code> flag shows detailed information about skipped tests.</p>"},{"location":"development/TESTING/#install-netmono-runtime","title":"Install .NET/Mono Runtime","text":""},{"location":"development/TESTING/#on-ubuntudebian","title":"On Ubuntu/Debian:","text":"<pre><code>sudo apt-get update\nsudo apt-get install mono-complete\n</code></pre>"},{"location":"development/TESTING/#on-macos","title":"On macOS:","text":"<pre><code>brew install mono\n</code></pre>"},{"location":"development/TESTING/#on-windows","title":"On Windows:","text":"<p>Install .NET Framework or Mono from the official websites.</p>"},{"location":"development/TESTING/#test-structure","title":"Test Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 test_adm_params.py      # Tests for ADMparams (requires .NET)\n\u251c\u2500\u2500 test_pyadm1.py           # Tests for PyADM1 (requires .NET)\n\u251c\u2500\u2500 test_simulator.py        # Tests for Simulator (requires .NET)\n\u2514\u2500\u2500 test_feedstock.py        # Tests for Feedstock (requires .NET)\n</code></pre>"},{"location":"development/TESTING/#continuous-integration","title":"Continuous Integration","text":"<p>The GitHub Actions workflow automatically installs Mono (on Linux/macOS) or uses the pre-installed .NET Framework (on Windows) to run the complete test suite. All tests should pass in CI.</p>"},{"location":"development/TESTING/#writing-new-tests","title":"Writing New Tests","text":"<p>When writing tests that require the C# DLLs, add this at the top of your test module:</p> <pre><code>import pytest\n\n# Check if .NET runtime is available\ntry:\n    import clr\n    clr.AddReference(\"System\")\n    DOTNET_AVAILABLE = True\nexcept (ImportError, RuntimeError):\n    DOTNET_AVAILABLE = False\n\n# Skip entire module if .NET is not available\nif not DOTNET_AVAILABLE:\n    pytest.skip(\"Requires .NET/Mono runtime\", allow_module_level=True)\n</code></pre>"},{"location":"development/TESTING/#known-issues","title":"Known Issues","text":"<ol> <li> <p>First-time Mono Installation: When running tests for the first time after installing Mono, you may need to restart your terminal or IDE.</p> </li> <li> <p>DLL Files: The C# DLL files are included in the <code>dlls/</code> directory of the repository. Make sure they are present and accessible.</p> </li> <li> <p>Platform Differences: Some tests may behave differently on Windows vs Linux/macOS due to .NET Framework vs Mono differences.</p> </li> <li> <p>pythonnet Configuration: On some systems, you may need to configure pythonnet to use the correct runtime. See the pythonnet documentation for details.</p> </li> </ol>"},{"location":"development/TESTING/#contributing","title":"Contributing","text":"<p>When contributing tests: 1. Ensure tests can run without .NET when possible 2. Clearly mark tests that require .NET 3. Provide mock data or fixtures to enable testing without external dependencies 4. Document any special requirements in test docstrings</p>"},{"location":"development/architecture/","title":"PyADM1ODE Architecture","text":"<p>This document describes the architecture of PyADM1ODE, a modular framework for biogas plant simulation and optimization.</p>"},{"location":"development/architecture/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Design Principles</li> <li>Core Architecture</li> <li>Module Organization</li> <li>Component System</li> <li>Simulation Engine</li> <li>Data Flow</li> <li>Extension Points</li> <li>Integration with External Systems</li> </ol>"},{"location":"development/architecture/#overview","title":"Overview","text":"<p>PyADM1ODE is designed as a modular, extensible framework following object-oriented principles. The architecture separates concerns into distinct layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    User Interface Layer                     \u2502\n\u2502  - CLI/API                                                  \u2502\n\u2502  - MCP Server (LLM Integration)                            \u2502\n\u2502  - Jupyter Notebooks                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Configuration Layer                        \u2502\n\u2502  - PlantConfigurator (High-level API)                      \u2502\n\u2502  - PlantBuilder (Component assembly)                       \u2502\n\u2502  - ConnectionManager (Component connections)               \u2502\n\u2502  - Templates (Pre-defined configurations)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Component Layer                           \u2502\n\u2502  - Biological (Digesters, Hydrolysis, Separators)         \u2502\n\u2502  - Energy (CHP, Heating, Gas Storage, Flare)              \u2502\n\u2502  - Mechanical (Pumps, Mixers)                              \u2502\n\u2502  - Feeding (Storage, Feeders)                              \u2502\n\u2502  - Sensors (Physical, Chemical, Gas)                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Simulation Layer                          \u2502\n\u2502  - Simulator (Single run)                                  \u2502\n\u2502  - ParallelSimulator (Multi-scenario)                      \u2502\n\u2502  - Time series management                                  \u2502\n\u2502  - Result collection and analysis                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      Core Layer                             \u2502\n\u2502  - ADM1 (ODE system)                                       \u2502\n\u2502  - ADMParams (Model parameters)                            \u2502\n\u2502  - ODESolver (Numerical integration)                       \u2502\n\u2502  - Substrate characterization                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   External Dependencies                     \u2502\n\u2502  - scipy (ODE solver)                                      \u2502\n\u2502  - numpy (Numerical operations)                            \u2502\n\u2502  - pythonnet (C# interop)                                  \u2502\n\u2502  - C# DLLs (Substrate database)                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"development/architecture/#design-principles","title":"Design Principles","text":""},{"location":"development/architecture/#1-modularity","title":"1. Modularity","text":"<p>Each component is self-contained and can be used independently:</p> <pre><code># Components work standalone\nfrom pyadm1.components.biological import Digester\nfrom pyadm1.substrates import Feedstock\n\nfeedstock = Feedstock(feeding_freq=48)\ndigester = Digester(\"dig1\", feedstock, V_liq=2000)\ndigester.initialize()\nresult = digester.step(t=0, dt=1/24, inputs={})\n</code></pre>"},{"location":"development/architecture/#2-separation-of-concerns","title":"2. Separation of Concerns","text":"<ul> <li>Core: ADM1 model implementation (pure science/math)</li> <li>Components: Engineering equipment models (plant hardware)</li> <li>Configurator: Plant assembly and connections (system design)</li> <li>Simulation: Time integration and result management (execution)</li> </ul>"},{"location":"development/architecture/#3-extensibility","title":"3. Extensibility","text":"<p>New components can be added without modifying existing code:</p> <pre><code>from pyadm1.components.base import Component, ComponentType\n\nclass CustomComponent(Component):\n    \"\"\"User-defined component.\"\"\"\n\n    def __init__(self, component_id, custom_param, name=None):\n        super().__init__(component_id, ComponentType.CUSTOM, name)\n        self.custom_param = custom_param\n\n    def step(self, t, dt, inputs):\n        \"\"\"Implement custom behavior.\"\"\"\n        # Custom logic here\n        return {'output': self.custom_param * dt}\n\n    def initialize(self, initial_state=None):\n        \"\"\"Initialize component.\"\"\"\n        pass\n\n    def to_dict(self):\n        \"\"\"Serialize to dictionary.\"\"\"\n        return {\n            'component_id': self.component_id,\n            'component_type': self.component_type.value,\n            'custom_param': self.custom_param\n        }\n\n# Register and use\nfrom pyadm1.components import ComponentRegistry\nregistry = ComponentRegistry()\nregistry.register(\"CustomComponent\", CustomComponent)\n</code></pre>"},{"location":"development/architecture/#4-type-safety","title":"4. Type Safety","text":"<p>Type hints throughout for better IDE support and error prevention:</p> <pre><code>from typing import Dict, List, Optional, Any\n\ndef simulate(\n    duration: float,\n    dt: float = 1.0/24.0,\n    save_interval: Optional[float] = None\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Type-safe simulation method.\"\"\"\n    pass\n</code></pre>"},{"location":"development/architecture/#5-configuration-as-code","title":"5. Configuration as Code","text":"<p>Plant configurations are serializable and version-controllable:</p> <pre><code># Configuration is pure data\nconfig = {\n    \"plant_name\": \"My Plant\",\n    \"components\": [...],\n    \"connections\": [...]\n}\n\n# Can be saved/loaded\nplant.to_json(\"config.json\")\nplant = BiogasPlant.from_json(\"config.json\", feedstock)\n</code></pre>"},{"location":"development/architecture/#core-architecture","title":"Core Architecture","text":""},{"location":"development/architecture/#adm1-core","title":"ADM1 Core","text":"<p>The heart of PyADM1ODE is the ADM1 implementation:</p> <pre><code>class ADM1:\n    \"\"\"Main ADM1 model class.\n\n    Implements the complete ADM1 ODE system with 37 state variables.\n    Pure ODE formulation (no DAEs) for numerical stability.\n\n    Attributes:\n        V_liq: Liquid volume [m\u00b3]\n        V_gas: Gas volume [m\u00b3]\n        T_ad: Operating temperature [K]\n        feedstock: Feedstock object\n        state: Current ADM1 state vector (37 elements)\n        params: Model parameters\n    \"\"\"\n\n    def __init__(self, feedstock, V_liq=1977.0, V_gas=304.0, T_ad=308.15):\n        \"\"\"Initialize ADM1 model.\"\"\"\n        self.feedstock = feedstock\n        self.V_liq = V_liq\n        self.V_gas = V_gas\n        self.T_ad = T_ad\n\n        # Get parameters\n        self.params = ADMParams.get_all_params(\n            R=0.08314,\n            T_base=298.15,\n            T_ad=T_ad\n        )\n\n        # Initialize state\n        self.state = None\n\n    def ADM1_ODE(self, t, state_zero):\n        \"\"\"Calculate derivatives dy/dt.\n\n        This is the core ODE function called by the solver.\n\n        Args:\n            t: Current time [days] (not used, autonomous system)\n            state_zero: Current state vector (37 elements)\n\n        Returns:\n            Tuple of 37 derivatives\n        \"\"\"\n        # Unpack state variables\n        S_su, S_aa, S_fa, S_va, S_bu, S_pro, S_ac, S_h2, S_ch4 = state_zero[0:9]\n        S_IC, S_IN, S_I = state_zero[9:12]\n        X_xc, X_ch, X_pr, X_li, X_su, X_aa = state_zero[12:18]\n        X_fa, X_c4, X_pro, X_ac, X_h2, X_I = state_zero[18:24]\n        S_cat, S_an, S_va_ion, S_bu_ion, S_pro_ion = state_zero[24:29]\n        S_ac_ion, S_hco3_ion, S_nh3, S_nh4_ion, S_gas_h2 = state_zero[29:34]\n        S_gas_ch4, S_gas_co2, S_H_ion = state_zero[34:37]\n\n        # Calculate process rates\n        rates = BiochemicalProcesses.calculate_process_rates(\n            state_zero,\n            self._inhibitions,\n            self.params,\n            self._substrate_params\n        )\n\n        # Calculate acid-base rates\n        acid_base_rates = BiochemicalProcesses.calculate_acid_base_rates(\n            state_zero,\n            self.params\n        )\n\n        # Calculate gas transfer rates\n        gas_transfer_rates = BiochemicalProcesses.calculate_gas_transfer_rates(\n            state_zero,\n            self.params,\n            self.params['R'] * self.T_ad,\n            self.V_liq,\n            self.V_gas\n        )\n\n        # Assemble derivatives (simplified - actual implementation has all 37)\n        dS_su = rates[0] - rates[4] + self.influent_rate * (S_su_in - S_su)\n        # ... (all 37 derivatives)\n\n        return (dS_su, dS_aa, dS_fa, ...)  # All 37 derivatives\n</code></pre> <p>Key Design Decisions:</p> <ol> <li>Pure ODE System: No differential-algebraic equations (DAEs) for better numerical stability</li> <li>Modular Calculation: Process rates, inhibitions, and gas transfer separated</li> <li>Parameter Management: Static parameter class for easy modification</li> <li>Substrate Integration: C# DLL interop for substrate characterization</li> </ol>"},{"location":"development/architecture/#component-base-class","title":"Component Base Class","text":"<p>All components inherit from a common base:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Dict, Any, Optional, List\nfrom enum import Enum\n\nclass ComponentType(Enum):\n    \"\"\"Enumeration of component types.\"\"\"\n    BIOLOGICAL = \"biological\"\n    MECHANICAL = \"mechanical\"\n    ENERGY = \"energy\"\n    FEEDING = \"feeding\"\n    SENSOR = \"sensor\"\n    CONTROL = \"control\"\n    CUSTOM = \"custom\"\n\nclass Component(ABC):\n    \"\"\"Abstract base class for all biogas plant components.\n\n    All components must implement:\n    - step(): Execute one simulation time step\n    - initialize(): Set up initial state\n    - to_dict(): Serialize to dictionary\n\n    Attributes:\n        component_id: Unique identifier\n        component_type: Type of component\n        name: Human-readable name\n        inputs: Connected input components\n        outputs: Connected output components\n        state: Current component state\n        outputs_data: Latest output data\n    \"\"\"\n\n    def __init__(self, component_id: str, component_type: ComponentType,\n                 name: Optional[str] = None):\n        \"\"\"Initialize component.\n\n        Args:\n            component_id: Unique identifier\n            component_type: Type of component\n            name: Optional human-readable name\n        \"\"\"\n        self.component_id = component_id\n        self.component_type = component_type\n        self.name = name or component_id\n        self.inputs: List[str] = []\n        self.outputs: List[str] = []\n        self.state: Dict[str, Any] = {}\n        self.outputs_data: Dict[str, Any] = {}\n\n    @abstractmethod\n    def step(self, t: float, dt: float, inputs: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Perform one simulation time step.\n\n        Args:\n            t: Current simulation time [days]\n            dt: Time step size [days]\n            inputs: Input data from connected components\n\n        Returns:\n            Output data to be passed to connected components\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def initialize(self, initial_state: Optional[Dict[str, Any]] = None):\n        \"\"\"Initialize component state.\n\n        Args:\n            initial_state: Optional initial state values\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Serialize component to dictionary for JSON export.\n\n        Returns:\n            Component configuration as dictionary\n        \"\"\"\n        pass\n\n    def add_input(self, component_id: str):\n        \"\"\"Add an input connection.\"\"\"\n        if component_id not in self.inputs:\n            self.inputs.append(component_id)\n\n    def add_output(self, component_id: str):\n        \"\"\"Add an output connection.\"\"\"\n        if component_id not in self.outputs:\n            self.outputs.append(component_id)\n\n    def get_state(self) -&gt; Dict[str, Any]:\n        \"\"\"Get current component state.\"\"\"\n        return self.state.copy()\n\n    def set_state(self, state: Dict[str, Any]):\n        \"\"\"Set component state.\"\"\"\n        self.state = state.copy()\n</code></pre>"},{"location":"development/architecture/#module-organization","title":"Module Organization","text":""},{"location":"development/architecture/#pyadm1core","title":"pyadm1/core/","text":"<p>Purpose: Core ADM1 model implementation</p> <p>Files: - <code>adm1.py</code>: Main ADM1 class with ODE system - <code>adm_params.py</code>: Static parameter definitions - <code>adm_equations.py</code>: Process rates, inhibitions, gas transfer - <code>solver.py</code>: ODE solver wrapper</p> <p>Design Pattern: Functional decomposition for mathematical clarity</p> <pre><code># Clear separation of concerns\nfrom pyadm1.core.adm_equations import BiochemicalProcesses, InhibitionFunctions\n\n# Calculate inhibitions\ninhibitions = InhibitionFunctions.calculate_inhibition_factors(...)\n\n# Calculate process rates\nrates = BiochemicalProcesses.calculate_process_rates(state, inhibitions, ...)\n</code></pre>"},{"location":"development/architecture/#pyadm1components","title":"pyadm1/components/","text":"<p>Purpose: Modular plant components</p> <p>Structure: <pre><code>components/\n\u251c\u2500\u2500 __init__.py          # Base classes, registry\n\u251c\u2500\u2500 base.py              # Component base class\n\u251c\u2500\u2500 registry.py          # Dynamic component loading\n\u251c\u2500\u2500 biological/          # Digesters, hydrolysis, separators\n\u251c\u2500\u2500 mechanical/          # Pumps, mixers, valves\n\u251c\u2500\u2500 energy/              # CHP, heating, gas storage, flare\n\u251c\u2500\u2500 feeding/             # Storage, feeders, mixer wagons\n\u2514\u2500\u2500 sensors/             # Physical, chemical, gas sensors\n</code></pre></p> <p>Design Pattern: Plugin architecture with registry</p> <pre><code>from pyadm1.components import ComponentRegistry\n\nregistry = ComponentRegistry()\n\n# Components self-register on import\nfrom pyadm1.components.biological import Digester\nfrom pyadm1.components.energy import CHP\n\n# Can create by name\ncomponent = registry.create(\"Digester\", \"dig1\", feedstock=feedstock)\n</code></pre>"},{"location":"development/architecture/#pyadm1configurator","title":"pyadm1/configurator/","text":"<p>Purpose: Plant model building and configuration</p> <p>Files: - <code>plant_builder.py</code>: BiogasPlant class (low-level) - <code>plant_configurator.py</code>: PlantConfigurator (high-level API) - <code>connection_manager.py</code>: Component connections - <code>validation.py</code>: Model validation - <code>templates/</code>: Pre-defined plant layouts</p> <p>Design Pattern: Builder pattern with fluent API</p> <pre><code>from pyadm1.configurator import PlantConfigurator\n\nconfigurator = PlantConfigurator(plant, feedstock)\n\n# Fluent API for plant construction\nconfigurator \\\n    .add_digester(\"dig1\", V_liq=2000, Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0]) \\\n    .add_chp(\"chp1\", P_el_nom=500) \\\n    .add_heating(\"heat1\", target_temperature=308.15) \\\n    .auto_connect_digester_to_chp(\"dig1\", \"chp1\") \\\n    .auto_connect_chp_to_heating(\"chp1\", \"heat1\")\n</code></pre>"},{"location":"development/architecture/#pyadm1simulation","title":"pyadm1/simulation/","text":"<p>Purpose: Simulation execution and result management</p> <p>Files: - <code>simulator.py</code>: Single simulation runs - <code>parallel.py</code>: Parallel multi-scenario simulation - <code>scenarios.py</code>: Scenario management - <code>time_series.py</code>: Time series data handling - <code>results.py</code>: Result analysis and export</p> <p>Design Pattern: Strategy pattern for different simulation modes</p> <pre><code>from pyadm1.simulation import Simulator, ParallelSimulator\n\n# Single run\nsimulator = Simulator(adm1)\nresult = simulator.simulate_AD_plant([0, 30], initial_state)\n\n# Parallel scenarios\nparallel = ParallelSimulator(adm1, n_workers=4)\nresults = parallel.run_scenarios(scenarios, duration=30, initial_state=state)\n</code></pre>"},{"location":"development/architecture/#pyadm1substrates","title":"pyadm1/substrates/","text":"<p>Purpose: Substrate management and characterization</p> <p>Files: - <code>feedstock.py</code>: Main Feedstock class - <code>substrate_db.py</code>: Substrate database interface - <code>xml_loader.py</code>: XML substrate file parser - <code>characterization.py</code>: Substrate characterization methods</p> <p>Design Pattern: Facade pattern for C# DLL interaction</p> <pre><code>class Feedstock:\n    \"\"\"Facade for C# substrate DLLs.\n\n    Hides complexity of .NET interop behind simple Python API.\n    \"\"\"\n\n    def __init__(self, feeding_freq, substrate_xml='substrate_gummersbach.xml'):\n        \"\"\"Initialize with C# DLL.\"\"\"\n        # Load C# assemblies\n        clr.AddReference(str(dll_path / \"substrates.dll\"))\n        from substrates import Substrates as CSharpSubstrates\n\n        self._substrates = CSharpSubstrates(substrate_xml)\n\n    def get_influent_dataframe(self, Q):\n        \"\"\"Get ADM1 input stream as DataFrame.\n\n        Wraps C# method calls in Pythonic interface.\n        \"\"\"\n        # Call C# methods\n        influent = self._substrates.getInfluent(Q, ...)\n\n        # Convert to pandas DataFrame\n        return pd.DataFrame(influent, columns=self.header())\n</code></pre>"},{"location":"development/architecture/#component-system","title":"Component System","text":""},{"location":"development/architecture/#component-lifecycle","title":"Component Lifecycle","text":"<pre><code># 1. Creation\ncomponent = Digester(\"dig1\", feedstock, V_liq=2000)\n\n# 2. Configuration\ncomponent.Q_substrates = [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n\n# 3. Connection\nplant.add_component(component)\nconfigurator.connect(\"dig1\", \"chp1\", \"gas\")\n\n# 4. Initialization\ncomponent.initialize()\n\n# 5. Simulation loop\nfor t in time_steps:\n    result = component.step(t, dt, inputs)\n\n# 6. Serialization\nconfig = component.to_dict()\n</code></pre>"},{"location":"development/architecture/#component-connections","title":"Component Connections","text":"<p>Connections are typed and validated:</p> <pre><code>class Connection:\n    \"\"\"Directed connection between components.\n\n    Attributes:\n        from_component: Source component ID\n        to_component: Target component ID\n        connection_type: Type of flow (liquid, gas, heat, power)\n    \"\"\"\n\n    def __init__(self, from_component: str, to_component: str,\n                 connection_type: str = \"default\"):\n        self.from_component = from_component\n        self.to_component = to_component\n        self.connection_type = connection_type\n\nclass ConnectionManager:\n    \"\"\"Manages connections between components.\"\"\"\n\n    def add_connection(self, connection: Connection):\n        \"\"\"Add and validate connection.\"\"\"\n        # Type checking\n        if connection.connection_type not in valid_types:\n            raise ValueError(f\"Invalid connection type: {connection.connection_type}\")\n\n        # Store connection\n        self.connections.append(connection)\n\n    def get_execution_order(self, component_ids: List[str]) -&gt; List[str]:\n        \"\"\"Determine execution order via topological sort.\"\"\"\n        # Build dependency graph\n        graph = self._build_dependency_graph(component_ids)\n\n        # Topological sort\n        return self._topological_sort(graph)\n</code></pre>"},{"location":"development/architecture/#three-pass-execution-model","title":"Three-Pass Execution Model","text":"<p>PyADM1ODE uses a three-pass execution for realistic gas flow:</p> <pre><code>def step(self, dt: float) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Execute one simulation time step with three-pass model.\n\n    Pass 1: Digesters produce gas \u2192 Gas storages\n    Pass 2: Gas storages update (no consumption yet)\n    Pass 3: CHPs consume gas \u2192 Storages supply \u2192 Flares vent excess\n    \"\"\"\n    results = {}\n\n    # Pass 1: Execute digesters\n    for digester_id in self.digesters:\n        component = self.components[digester_id]\n        inputs = self._get_inputs(digester_id, results)\n        result = component.step(self.simulation_time, dt, inputs)\n        results[digester_id] = result\n\n        # Gas to storage\n        storage_id = f\"{digester_id}_storage\"\n        if storage_id in self.components:\n            storage_inputs = {'Q_gas_in_m3_per_day': result['Q_gas']}\n            storage_result = self.components[storage_id].step(\n                self.simulation_time, dt, storage_inputs\n            )\n            results[storage_id] = storage_result\n\n    # Pass 2: Execute CHPs (first pass - determine demand)\n    for chp_id in self.chps:\n        component = self.components[chp_id]\n        inputs = self._get_inputs(chp_id, results)\n        result = component.step(self.simulation_time, dt, inputs)\n        results[chp_id] = result\n\n    # Pass 3: Execute storages (supply to CHPs)\n    for storage_id in self.storages:\n        if storage_id in results:\n            # Already executed in Pass 1\n            continue\n\n        # Standalone storage\n        component = self.components[storage_id]\n        inputs = self._get_inputs(storage_id, results)\n        result = component.step(self.simulation_time, dt, inputs)\n        results[storage_id] = result\n\n    # Re-execute CHPs with actual gas supply\n    for chp_id in self.chps:\n        component = self.components[chp_id]\n        inputs = self._get_inputs(chp_id, results)\n        result = component.step(self.simulation_time, dt, inputs)\n        results[chp_id] = result\n\n    # Execute remaining components\n    for component_id in self.execution_order:\n        if component_id not in results:\n            component = self.components[component_id]\n            inputs = self._get_inputs(component_id, results)\n            result = component.step(self.simulation_time, dt, inputs)\n            results[component_id] = result\n\n    return results\n</code></pre>"},{"location":"development/architecture/#simulation-engine","title":"Simulation Engine","text":""},{"location":"development/architecture/#single-simulation","title":"Single Simulation","text":"<pre><code>class Simulator:\n    \"\"\"Handles single ADM1 simulation runs.\n\n    Uses ODESolver for numerical integration.\n\n    Attributes:\n        adm1: ADM1 model instance\n        solver: ODE solver instance\n    \"\"\"\n\n    def __init__(self, adm1: ADM1, solver: Optional[ODESolver] = None):\n        \"\"\"Initialize simulator.\"\"\"\n        self.adm1 = adm1\n        self.solver = solver or ODESolver()\n\n    def simulate_AD_plant(self, tstep: List[float],\n                          state_zero: List[float]) -&gt; List[float]:\n        \"\"\"Simulate ADM1 for time span.\n\n        Args:\n            tstep: [t_start, t_end] in days\n            state_zero: Initial ADM1 state (37 elements)\n\n        Returns:\n            Final ADM1 state after simulation\n        \"\"\"\n        # Create ODE function\n        def ode_func(t, y):\n            return self.adm1.ADM1_ODE(t, y)\n\n        # Solve ODE system\n        result = self.solver.solve(\n            ode_func,\n            t_span=tstep,\n            y0=state_zero\n        )\n\n        # Track process values\n        for i, t in enumerate(result.t):\n            state = result.y[:, i]\n            self.adm1.print_params_at_current_state(state)\n\n        return result.y[:, -1]  # Final state\n</code></pre>"},{"location":"development/architecture/#parallel-simulation","title":"Parallel Simulation","text":"<pre><code>from multiprocessing import Pool\nfrom dataclasses import dataclass\nfrom typing import List, Dict\n\n@dataclass\nclass ScenarioResult:\n    \"\"\"Result from a single scenario.\"\"\"\n    scenario_id: int\n    parameters: Dict[str, Any]\n    success: bool\n    duration: float\n    final_state: Optional[List[float]]\n    metrics: Dict[str, float]\n    error: Optional[str]\n    execution_time: float\n\nclass ParallelSimulator:\n    \"\"\"Parallel execution of multiple scenarios.\n\n    Uses multiprocessing for CPU-bound simulation tasks.\n\n    Attributes:\n        adm1: Base ADM1 model (copied per worker)\n        n_workers: Number of parallel workers\n    \"\"\"\n\n    def __init__(self, adm1: ADM1, n_workers: Optional[int] = None):\n        \"\"\"Initialize parallel simulator.\"\"\"\n        self.adm1 = adm1\n        self.n_workers = n_workers or cpu_count()\n\n    def run_scenarios(self, scenarios: List[Dict[str, Any]],\n                      duration: float,\n                      initial_state: List[float],\n                      **kwargs) -&gt; List[ScenarioResult]:\n        \"\"\"Run multiple scenarios in parallel.\n\n        Args:\n            scenarios: List of parameter dictionaries\n            duration: Simulation duration [days]\n            initial_state: Initial ADM1 state\n\n        Returns:\n            List of ScenarioResult objects\n        \"\"\"\n        # Create work items\n        work_items = [\n            (i, scenario, duration, initial_state, self.adm1, kwargs)\n            for i, scenario in enumerate(scenarios)\n        ]\n\n        # Execute in parallel\n        with Pool(processes=self.n_workers) as pool:\n            results = pool.starmap(self._run_single_scenario, work_items)\n\n        return results\n\n    @staticmethod\n    def _run_single_scenario(scenario_id, parameters, duration,\n                             initial_state, adm1_base, kwargs):\n        \"\"\"Run single scenario (called by worker process).\"\"\"\n        import time\n        start_time = time.time()\n\n        try:\n            # Create ADM1 copy for this worker\n            adm1 = deepcopy(adm1_base)\n\n            # Apply parameters\n            for param, value in parameters.items():\n                if param == 'Q':\n                    adm1.create_influent(value, 0)\n                else:\n                    adm1.set_calibration_parameters({param: value})\n\n            # Simulate\n            simulator = Simulator(adm1)\n            final_state = simulator.simulate_AD_plant([0, duration], initial_state)\n\n            # Compute metrics\n            metrics = self._compute_metrics(final_state, adm1)\n\n            return ScenarioResult(\n                scenario_id=scenario_id,\n                parameters=parameters,\n                success=True,\n                duration=duration,\n                final_state=final_state,\n                metrics=metrics,\n                error=None,\n                execution_time=time.time() - start_time\n            )\n\n        except Exception as e:\n            return ScenarioResult(\n                scenario_id=scenario_id,\n                parameters=parameters,\n                success=False,\n                duration=duration,\n                final_state=None,\n                metrics={},\n                error=str(e),\n                execution_time=time.time() - start_time\n            )\n</code></pre>"},{"location":"development/architecture/#data-flow","title":"Data Flow","text":""},{"location":"development/architecture/#input-data-flow","title":"Input Data Flow","text":"<pre><code>User Input \u2192 PlantConfigurator \u2192 BiogasPlant \u2192 Components\n    \u2193\nSubstrate XML \u2192 Feedstock \u2192 C# DLLs \u2192 ADM1 Input Stream\n    \u2193\nInitial State CSV \u2192 ADM1 State Vector\n</code></pre>"},{"location":"development/architecture/#simulation-data-flow","title":"Simulation Data Flow","text":"<pre><code>t=0: Initialize all components\n     \u2193\nLoop over time steps:\n     \u2193\n1. Get component execution order (topological sort)\n     \u2193\n2. For each component:\n     - Gather inputs from connected components\n     - Call component.step(t, dt, inputs)\n     - Store outputs for downstream components\n     \u2193\n3. Collect results\n     \u2193\nSave/Export results\n</code></pre>"},{"location":"development/architecture/#output-data-flow","title":"Output Data Flow","text":"<pre><code>Component Outputs \u2192 Results Dictionary \u2192 Analysis/Visualization\n                                      \u2193\n                                   Export:\n                                   - JSON (configuration)\n                                   - CSV (time series)\n                                   - Plots (matplotlib)\n</code></pre>"},{"location":"development/architecture/#extension-points","title":"Extension Points","text":"<p>PyADM1ODE provides multiple extension points for customization and enhancement without modifying core code.</p>"},{"location":"development/architecture/#1-adding-new-components","title":"1. Adding New Components","text":"<p>Implement the Component interface to create custom components:</p> <pre><code>from pyadm1.components.base import Component, ComponentType\nfrom typing import Dict, Any, Optional\n\nclass MyCustomComponent(Component):\n    \"\"\"Example custom component implementation.\n\n    Custom components can model any plant equipment or process\n    not included in the standard library.\n\n    Args:\n        component_id: Unique identifier\n        custom_param: Component-specific parameter\n        name: Optional human-readable name\n\n    Example:\n        &gt;&gt;&gt; component = MyCustomComponent(\"custom1\", custom_param=42.0)\n        &gt;&gt;&gt; component.initialize()\n        &gt;&gt;&gt; result = component.step(0, 1/24, {})\n    \"\"\"\n\n    def __init__(self, component_id: str, custom_param: float,\n                 name: Optional[str] = None):\n        \"\"\"Initialize custom component.\n\n        Args:\n            component_id: Unique identifier\n            custom_param: Custom parameter value\n            name: Optional human-readable name\n        \"\"\"\n        super().__init__(component_id, ComponentType.CUSTOM, name)\n        self.custom_param = custom_param\n        self.state = {\n            'value': 0.0,\n            'accumulated': 0.0,\n            'operating_hours': 0.0\n        }\n\n    def initialize(self, initial_state: Optional[Dict[str, Any]] = None):\n        \"\"\"Initialize component state.\n\n        Args:\n            initial_state: Optional initial state dictionary\n        \"\"\"\n        if initial_state:\n            self.state.update(initial_state)\n\n    def step(self, t: float, dt: float, inputs: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Execute one simulation time step.\n\n        Args:\n            t: Current time [days]\n            dt: Time step [days]\n            inputs: Input data from connected components\n\n        Returns:\n            Output data dictionary\n        \"\"\"\n        # Custom logic\n        input_value = inputs.get('input_value', 0.0)\n\n        # Update state\n        self.state['value'] = input_value * self.custom_param\n        self.state['accumulated'] += self.state['value'] * dt\n        self.state['operating_hours'] += dt * 24  # Convert to hours\n\n        # Prepare outputs\n        outputs = {\n            'output': self.state['value'],\n            'accumulated': self.state['accumulated'],\n            'status': 'ok',\n            'is_running': True\n        }\n\n        # Store for access\n        self.outputs_data = outputs\n\n        return outputs\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Serialize component to dictionary.\n\n        Returns:\n            Dictionary representation of component\n        \"\"\"\n        return {\n            'component_id': self.component_id,\n            'component_type': self.component_type.value,\n            'custom_param': self.custom_param,\n            'name': self.name,\n            'state': self.state\n        }\n\n    @classmethod\n    def from_dict(cls, config: Dict[str, Any]) -&gt; 'MyCustomComponent':\n        \"\"\"Create component from dictionary.\n\n        Args:\n            config: Component configuration dictionary\n\n        Returns:\n            MyCustomComponent instance\n        \"\"\"\n        component = cls(\n            component_id=config['component_id'],\n            custom_param=config['custom_param'],\n            name=config.get('name')\n        )\n        if 'state' in config:\n            component.state = config['state']\n        return component\n\n# Register component for dynamic loading\nfrom pyadm1.components import ComponentRegistry\n\nregistry = ComponentRegistry()\nregistry.register(\"MyCustomComponent\", MyCustomComponent)\n\n# Use in plant\nfrom pyadm1.configurator import BiogasPlant\n\nplant = BiogasPlant(\"Plant with Custom Component\")\ncustom_comp = MyCustomComponent(\"custom1\", custom_param=42.0)\nplant.add_component(custom_comp)\n</code></pre>"},{"location":"development/architecture/#2-custom-simulation-algorithms","title":"2. Custom Simulation Algorithms","text":"<p>Extend the Simulator class for specialized simulation algorithms:</p> <pre><code>from pyadm1.simulation import Simulator\nfrom pyadm1.core import ADM1, ODESolver\nimport numpy as np\nfrom typing import List, Tuple, Optional\n\nclass AdaptiveSimulator(Simulator):\n    \"\"\"Simulator with adaptive time stepping and steady-state detection.\n\n    Extends base Simulator with:\n    - Adaptive time step control\n    - Automatic steady-state detection\n    - Error estimation and control\n\n    Example:\n        &gt;&gt;&gt; simulator = AdaptiveSimulator(adm1, tolerance=1e-6)\n        &gt;&gt;&gt; state, converged = simulator.simulate_to_steady_state(\n        ...     initial_state, max_time=1000\n        ... )\n    \"\"\"\n\n    def __init__(self, adm1: ADM1, tolerance: float = 1e-6,\n                 solver: Optional[ODESolver] = None):\n        \"\"\"Initialize adaptive simulator.\n\n        Args:\n            adm1: ADM1 model instance\n            tolerance: Tolerance for adaptive control\n            solver: Optional custom ODE solver\n        \"\"\"\n        super().__init__(adm1, solver)\n        self.tolerance = tolerance\n        self.error_history = []\n\n    def adaptive_time_step(self, current_state: List[float],\n                          dt_current: float) -&gt; float:\n        \"\"\"Calculate adaptive time step based on error estimate.\n\n        Uses embedded Runge-Kutta method for error estimation.\n\n        Args:\n            current_state: Current ADM1 state\n            dt_current: Current time step\n\n        Returns:\n            Adjusted time step\n        \"\"\"\n        # Estimate local truncation error\n        def ode_func(t, y):\n            return self.adm1.ADM1_ODE(t, y)\n\n        # Two half-steps\n        k1 = ode_func(0, current_state)\n        state_half = [s + dt_current/2 * k for s, k in zip(current_state, k1)]\n        k2 = ode_func(dt_current/2, state_half)\n        state_two_half = [s + dt_current/2 * k for s, k in zip(state_half, k2)]\n\n        # One full step\n        state_full = [s + dt_current * k for s, k in zip(current_state, k1)]\n\n        # Error estimate\n        error = np.max(np.abs(np.array(state_two_half) - np.array(state_full)))\n        self.error_history.append(error)\n\n        # Adjust time step\n        if error &lt; self.tolerance / 10:\n            dt_new = min(dt_current * 1.5, 0.1)  # Increase, max 0.1 days\n        elif error &gt; self.tolerance:\n            dt_new = max(dt_current * 0.5, 1e-6)  # Decrease, min 1e-6 days\n        else:\n            dt_new = dt_current\n\n        return dt_new\n\n    def detect_steady_state(self, state_history: List[List[float]],\n                           threshold: float = 1e-5) -&gt; bool:\n        \"\"\"Detect when steady state is reached.\n\n        Compares recent states to detect convergence.\n\n        Args:\n            state_history: List of recent ADM1 states\n            threshold: Convergence threshold\n\n        Returns:\n            True if steady state detected\n        \"\"\"\n        if len(state_history) &lt; 10:\n            return False\n\n        # Compare last 10 states\n        recent_states = state_history[-10:]\n\n        # Calculate maximum change\n        max_change = 0.0\n        for i in range(1, len(recent_states)):\n            diff = np.abs(np.array(recent_states[i]) - np.array(recent_states[i-1]))\n            max_change = max(max_change, np.max(diff))\n\n        return max_change &lt; threshold\n\n    def simulate_to_steady_state(self, initial_state: List[float],\n                                 max_time: float = 1000.0,\n                                 check_interval: float = 10.0) -&gt; Tuple[List[float], bool]:\n        \"\"\"Simulate until steady state or max time.\n\n        Args:\n            initial_state: Initial ADM1 state\n            max_time: Maximum simulation time [days]\n            check_interval: Interval for steady-state check [days]\n\n        Returns:\n            Tuple of (final_state, converged)\n        \"\"\"\n        t = 0.0\n        state = initial_state.copy()\n        state_history = [state]\n        dt = 0.01  # Initial time step\n\n        print(f\"Starting simulation to steady state (max {max_time} days)...\")\n\n        while t &lt; max_time:\n            # Adaptive time step\n            dt = self.adaptive_time_step(state, dt)\n\n            # Simulate one step\n            state = self.simulate_AD_plant([t, t + dt], state)\n            state_history.append(state)\n            t += dt\n\n            # Check for steady state periodically\n            if len(state_history) % int(check_interval / dt) == 0:\n                if self.detect_steady_state(state_history):\n                    print(f\"\u2713 Steady state reached at t={t:.1f} days\")\n                    return state, True\n                else:\n                    print(f\"  t={t:.1f} days, dt={dt:.4f}, checking...\")\n\n        print(f\"\u2717 Max time {max_time} days reached without convergence\")\n        return state, False\n\n# Usage example\nfrom pyadm1.substrates import Feedstock\n\nfeedstock = Feedstock(feeding_freq=48)\nadm1 = ADM1(feedstock, V_liq=2000, T_ad=308.15)\n\n# Create adaptive simulator\nsimulator = AdaptiveSimulator(adm1, tolerance=1e-6)\n\n# Run to steady state\ninitial_state = [0.01] * 37\nfinal_state, converged = simulator.simulate_to_steady_state(\n    initial_state,\n    max_time=1000\n)\n\nif converged:\n    print(\"Steady state achieved!\")\n    # Use final_state as initial condition for production runs\n</code></pre>"},{"location":"development/architecture/#3-custom-parameter-calibration","title":"3. Custom Parameter Calibration","text":"<p>Implement custom calibration algorithms (see PyADM1ODE_calibration):</p> <pre><code>from pyadm1.core import ADM1\nfrom pyadm1.simulation import Simulator\nfrom typing import Dict, List, Callable\nimport numpy as np\n\nclass CustomCalibrator:\n    \"\"\"Custom parameter calibration implementation.\n\n    Example implementation of Bayesian optimization for parameter estimation.\n\n    Args:\n        adm1: ADM1 model instance\n        measurement_data: Observed data for calibration\n        parameters_to_calibrate: List of parameter names\n\n    Example:\n        &gt;&gt;&gt; calibrator = CustomCalibrator(adm1, measurements, ['k_dis', 'Y_su'])\n        &gt;&gt;&gt; best_params = calibrator.calibrate(n_iterations=100)\n    \"\"\"\n\n    def __init__(self, adm1: ADM1, measurement_data: Dict[str, List[float]],\n                 parameters_to_calibrate: List[str]):\n        \"\"\"Initialize calibrator.\n\n        Args:\n            adm1: ADM1 model instance\n            measurement_data: Dictionary with 'time' and measured variables\n            parameters_to_calibrate: Parameter names to optimize\n        \"\"\"\n        self.adm1 = adm1\n        self.measurement_data = measurement_data\n        self.parameters = parameters_to_calibrate\n        self.simulator = Simulator(adm1)\n\n    def objective_function(self, param_values: List[float]) -&gt; float:\n        \"\"\"Calculate objective function (RMSE).\n\n        Args:\n            param_values: Parameter values to test\n\n        Returns:\n            Root mean square error\n        \"\"\"\n        # Set parameters\n        param_dict = dict(zip(self.parameters, param_values))\n        self.adm1.set_calibration_parameters(param_dict)\n\n        # Simulate\n        try:\n            results = []\n            for i, t in enumerate(self.measurement_data['time'][:-1]):\n                dt = self.measurement_data['time'][i+1] - t\n                state = self.simulator.simulate_AD_plant([t, t+dt], state)\n                results.append(state)\n\n            # Calculate RMSE for methane production\n            simulated_ch4 = [self.adm1.calc_gas(...)[-2] for state in results]\n            measured_ch4 = self.measurement_data['Q_ch4']\n\n            rmse = np.sqrt(np.mean((np.array(simulated_ch4) - np.array(measured_ch4))**2))\n\n        except Exception as e:\n            # Penalize failed simulations\n            rmse = 1e10\n\n        return rmse\n\n    def calibrate(self, n_iterations: int = 100,\n                  bounds: Optional[Dict[str, Tuple[float, float]]] = None) -&gt; Dict[str, float]:\n        \"\"\"Run calibration using custom optimization.\n\n        Args:\n            n_iterations: Number of optimization iterations\n            bounds: Parameter bounds as {param: (min, max)}\n\n        Returns:\n            Best parameter values\n        \"\"\"\n        # Default bounds\n        if bounds is None:\n            bounds = {\n                'k_dis': (0.1, 1.0),\n                'Y_su': (0.05, 0.15),\n                'k_hyd_ch': (5.0, 20.0),\n                # ... other parameters\n            }\n\n        # Extract bounds for optimizer\n        param_bounds = [bounds[p] for p in self.parameters]\n\n        # Simple random search (replace with sophisticated algorithm)\n        best_params = None\n        best_error = float('inf')\n\n        print(f\"Starting calibration with {n_iterations} iterations...\")\n\n        for i in range(n_iterations):\n            # Random sample within bounds\n            param_values = [\n                np.random.uniform(b[0], b[1])\n                for b in param_bounds\n            ]\n\n            # Evaluate\n            error = self.objective_function(param_values)\n\n            if error &lt; best_error:\n                best_error = error\n                best_params = param_values.copy()\n                print(f\"Iteration {i+1}: New best RMSE = {best_error:.4f}\")\n\n        # Return as dictionary\n        result = dict(zip(self.parameters, best_params))\n        print(f\"\\nCalibration complete!\")\n        print(f\"Best parameters: {result}\")\n        print(f\"Best RMSE: {best_error:.4f}\")\n\n        return result\n\n# Usage\nmeasurement_data = {\n    'time': [0, 1, 2, 3, 4, 5],  # days\n    'Q_ch4': [700, 720, 735, 745, 750, 752]  # m\u00b3/d\n}\n\ncalibrator = CustomCalibrator(\n    adm1,\n    measurement_data,\n    parameters_to_calibrate=['k_dis', 'Y_su']\n)\n\nbest_params = calibrator.calibrate(n_iterations=100)\n\n# Apply to model\nadm1.set_calibration_parameters(best_params)\n</code></pre>"},{"location":"development/architecture/#4-custom-substrates","title":"4. Custom Substrates","text":"<p>Add new substrate definitions via XML:</p> <pre><code>&lt;!-- data/substrates/custom_substrates.xml --&gt;\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;substrates&gt;\n    &lt;substrate name=\"custom_substrate\"&gt;\n        &lt;!-- Basic properties --&gt;\n        &lt;pH&gt;4.5&lt;/pH&gt;\n        &lt;TS&gt;25.0&lt;/TS&gt;  &lt;!-- Total solids [%] --&gt;\n        &lt;VS&gt;95.0&lt;/VS&gt;  &lt;!-- Volatile solids [% of TS] --&gt;\n\n        &lt;!-- Weender analysis --&gt;\n        &lt;crude_protein&gt;15.0&lt;/crude_protein&gt;  &lt;!-- [% of TS] --&gt;\n        &lt;crude_fat&gt;4.0&lt;/crude_fat&gt;\n        &lt;crude_fiber&gt;20.0&lt;/crude_fiber&gt;\n        &lt;nitrogen_free_extract&gt;55.0&lt;/nitrogen_free_extract&gt;\n        &lt;ash&gt;6.0&lt;/ash&gt;\n\n        &lt;!-- Van Soest fractions --&gt;\n        &lt;NDF&gt;45.0&lt;/NDF&gt;  &lt;!-- Neutral detergent fiber [% of TS] --&gt;\n        &lt;ADF&gt;25.0&lt;/ADF&gt;  &lt;!-- Acid detergent fiber [% of TS] --&gt;\n        &lt;ADL&gt;5.0&lt;/ADL&gt;   &lt;!-- Acid detergent lignin [% of TS] --&gt;\n\n        &lt;!-- COD fractions (will be calculated if not provided) --&gt;\n        &lt;COD_total&gt;1.5&lt;/COD_total&gt;  &lt;!-- [kg COD/kg FM] --&gt;\n\n        &lt;!-- Kinetic parameters (optional, will use defaults if not provided) --&gt;\n        &lt;k_dis&gt;0.5&lt;/k_dis&gt;          &lt;!-- Disintegration rate [1/d] --&gt;\n        &lt;k_hyd_ch&gt;10.0&lt;/k_hyd_ch&gt;   &lt;!-- Carbohydrate hydrolysis [1/d] --&gt;\n        &lt;k_hyd_pr&gt;10.0&lt;/k_hyd_pr&gt;   &lt;!-- Protein hydrolysis [1/d] --&gt;\n        &lt;k_hyd_li&gt;10.0&lt;/k_hyd_li&gt;   &lt;!-- Lipid hydrolysis [1/d] --&gt;\n    &lt;/substrate&gt;\n&lt;/substrates&gt;\n</code></pre> <p>Load custom substrates:</p> <pre><code>from pyadm1.substrates import Feedstock\n\n# Load with custom substrate file\nfeedstock = Feedstock(\n    feeding_freq=48,\n    substrate_xml='custom_substrates.xml'\n)\n\n# Verify substrate loaded\nsubstrates = feedstock.mySubstrates()\nn_substrates = substrates.getNumSubstrates()\nprint(f\"Loaded {n_substrates} substrates\")\n\n# Use in simulation\nQ_substrates = [0, 0, 0, 0, 0, 0, 0, 0, 0, 20]  # 20 m\u00b3/d custom substrate\n</code></pre>"},{"location":"development/architecture/#5-custom-result-analyzers","title":"5. Custom Result Analyzers","text":"<p>Create specialized analysis tools:</p> <pre><code>from typing import List, Dict, Any\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nclass EconomicAnalyzer:\n    \"\"\"Analyze economic performance of biogas plant.\n\n    Calculates revenues, costs, and profitability metrics.\n\n    Args:\n        electricity_price: Price per kWh [\u20ac/kWh]\n        feed_in_tariff: Feed-in tariff [\u20ac/kWh]\n        substrate_costs: Cost per substrate [\u20ac/m\u00b3 or \u20ac/t]\n\n    Example:\n        &gt;&gt;&gt; analyzer = EconomicAnalyzer(\n        ...     electricity_price=0.30,\n        ...     feed_in_tariff=0.15,\n        ...     substrate_costs={'corn_silage': 35, 'manure': 0}\n        ... )\n        &gt;&gt;&gt; economics = analyzer.analyze(results, Q_substrates)\n    \"\"\"\n\n    def __init__(self, electricity_price: float = 0.30,\n                 feed_in_tariff: float = 0.15,\n                 substrate_costs: Dict[str, float] = None):\n        \"\"\"Initialize economic analyzer.\n\n        Args:\n            electricity_price: Electricity price [\u20ac/kWh]\n            feed_in_tariff: Feed-in tariff [\u20ac/kWh]\n            substrate_costs: Substrate costs dictionary\n        \"\"\"\n        self.electricity_price = electricity_price\n        self.feed_in_tariff = feed_in_tariff\n        self.substrate_costs = substrate_costs or {}\n\n    def analyze(self, results: List[Dict[str, Any]],\n                Q_substrates: List[float]) -&gt; Dict[str, float]:\n        \"\"\"Analyze economic performance.\n\n        Args:\n            results: Simulation results\n            Q_substrates: Substrate feed rates [m\u00b3/d]\n\n        Returns:\n            Economic metrics dictionary\n        \"\"\"\n        # Extract data\n        times = [r['time'] for r in results]\n        duration = times[-1] - times[0]\n\n        # Energy production\n        if 'chp1' in results[0]['components']:\n            P_el = [r['components']['chp1']['P_el'] for r in results]\n            avg_P_el = sum(P_el) / len(P_el)\n            annual_production = avg_P_el * 24 * 365  # kWh/year\n        else:\n            annual_production = 0\n\n        # Revenues\n        revenue_electricity = annual_production * self.feed_in_tariff\n\n        # Substrate costs\n        substrate_names = ['corn_silage', 'manure', 'rye', 'grass',\n                          'wheat', 'gps', 'ccm', 'lime', 'cow_manure', 'onions']\n        annual_substrate_cost = 0\n        for i, substrate in enumerate(substrate_names):\n            if i &lt; len(Q_substrates) and Q_substrates[i] &gt; 0:\n                cost_per_unit = self.substrate_costs.get(substrate, 0)\n                annual_cost = Q_substrates[i] * 365 * cost_per_unit\n                annual_substrate_cost += annual_cost\n\n        # Operating costs (simplified)\n        operating_cost = annual_production * 0.03  # 3 ct/kWh\n\n        # Total costs\n        total_costs = annual_substrate_cost + operating_cost\n\n        # Profit\n        annual_profit = revenue_electricity - total_costs\n\n        return {\n            'annual_production_kWh': annual_production,\n            'revenue_electricity_\u20ac': revenue_electricity,\n            'substrate_costs_\u20ac': annual_substrate_cost,\n            'operating_costs_\u20ac': operating_cost,\n            'total_costs_\u20ac': total_costs,\n            'annual_profit_\u20ac': annual_profit,\n            'profit_margin': annual_profit / revenue_electricity if revenue_electricity &gt; 0 else 0,\n            'specific_cost_\u20ac_per_kWh': total_costs / annual_production if annual_production &gt; 0 else 0\n        }\n\n    def plot_economics(self, economics: Dict[str, float]):\n        \"\"\"Plot economic analysis.\n\n        Args:\n            economics: Economic metrics from analyze()\n        \"\"\"\n        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\n\n        # Revenue vs Costs\n        categories = ['Revenue', 'Substrate\\nCosts', 'Operating\\nCosts', 'Profit']\n        values = [\n            economics['revenue_electricity_\u20ac'],\n            -economics['substrate_costs_\u20ac'],\n            -economics['operating_costs_\u20ac'],\n            economics['annual_profit_\u20ac']\n        ]\n        colors = ['green', 'red', 'red', 'blue']\n\n        ax1.bar(categories, values, color=colors, alpha=0.7)\n        ax1.set_ylabel('\u20ac/year')\n        ax1.set_title('Annual Economics')\n        ax1.axhline(y=0, color='k', linestyle='-', linewidth=0.5)\n        ax1.grid(True, alpha=0.3)\n\n        # Cost breakdown pie chart\n        cost_categories = ['Substrates', 'Operation']\n        cost_values = [\n            economics['substrate_costs_\u20ac'],\n            economics['operating_costs_\u20ac']\n        ]\n\n        ax2.pie(cost_values, labels=cost_categories, autopct='%1.1f%%',\n                colors=['#ff9999', '#66b3ff'])\n        ax2.set_title('Cost Breakdown')\n\n        plt.tight_layout()\n        plt.show()\n\n# Usage\nanalyzer = EconomicAnalyzer(\n    electricity_price=0.30,\n    feed_in_tariff=0.15,\n    substrate_costs={\n        'corn_silage': 35,  # \u20ac/t\n        'manure': 0,        # Free\n        'grass': 25\n    }\n)\n\neconomics = analyzer.analyze(results, Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0])\nprint(f\"Annual profit: {economics['annual_profit_\u20ac']:,.0f} \u20ac/year\")\nanalyzer.plot_economics(economics)\n</code></pre>"},{"location":"development/architecture/#integration-with-external-systems","title":"Integration with External Systems","text":"<p>PyADM1ODE can be integrated with various external systems for enhanced functionality.</p>"},{"location":"development/architecture/#1-mcp-server-integration-llm-driven-design","title":"1. MCP Server Integration (LLM-Driven Design)","text":"<p>The Model Context Protocol (MCP) server enables LLM-driven plant design via natural language.</p> <p>Repository: PyADM1ODE_mcp</p> <p>Architecture:</p> <pre><code>User (Natural Language)\n         \u2193\n    LLM (Claude)\n         \u2193\n    MCP Server\n         \u2193\nPyADM1ODE PlantConfigurator\n         \u2193\n    BiogasPlant\n</code></pre> <p>Example Interaction:</p> <pre><code>User: \"Design a 500 kW biogas plant with corn silage and manure\"\n\nLLM \u2192 MCP Server: create_plant(name=\"500kW Plant\")\nMCP Server \u2192 PyADM1ODE: BiogasPlant(\"500kW Plant\")\n\nLLM \u2192 MCP Server: add_digester(V_liq=2000, substrates=[\"corn\", \"manure\"])\nMCP Server \u2192 PyADM1ODE: configurator.add_digester(...)\n\nLLM \u2192 MCP Server: add_chp(P_el_nom=500)\nMCP Server \u2192 PyADM1ODE: configurator.add_chp(...)\n\nLLM \u2192 MCP Server: simulate(duration=30)\nMCP Server \u2192 PyADM1ODE: plant.simulate(30)\n\nMCP Server \u2192 LLM: Results summary\nLLM \u2192 User: \"Your plant produces 750 m\u00b3/d methane at 60% content...\"\n</code></pre> <p>Installation:</p> <pre><code>git clone https://github.com/dgaida/PyADM1ODE_mcp.git\ncd PyADM1ODE_mcp\npip install -e .\n</code></pre> <p>Key Features: - Natural language plant design - Automatic component selection - Parameter optimization suggestions - Interactive refinement</p>"},{"location":"development/architecture/#2-parameter-calibration-system","title":"2. Parameter Calibration System","text":"<p>Automated calibration from measurement data.</p> <p>Repository: PyADM1ODE_calibration</p> <p>Architecture:</p> <pre><code>Measurement Database\n         \u2193\n  Data Preprocessing\n         \u2193\nCalibration Algorithm (DE/PSO/Nelder-Mead)\n         \u2193\n    PyADM1ODE ADM1\n         \u2193\nCalibrated Parameters \u2192 Model\n</code></pre> <p>Usage Example:</p> <pre><code>from pyadm1_calibration import Calibrator\nfrom pyadm1.core import ADM1\nfrom pyadm1.substrates import Feedstock\n\n# Load measurement data\nmeasurements = pd.read_csv('plant_data.csv')\n\n# Create calibrator\nfeedstock = Feedstock(feeding_freq=48)\nadm1 = ADM1(feedstock, V_liq=2000, T_ad=308.15)\n\ncalibrator = Calibrator(\n    adm1=adm1,\n    measurement_data=measurements,\n    parameters_to_calibrate=['k_dis', 'Y_su', 'k_hyd_ch'],\n    algorithm='differential_evolution'\n)\n\n# Run calibration\nbest_params, history = calibrator.calibrate(\n    n_iterations=100,\n    population_size=20\n)\n\n# Apply to model\nadm1.set_calibration_parameters(best_params)\n\n# Validate\nvalidation_rmse = calibrator.validate(best_params, validation_data)\nprint(f\"Validation RMSE: {validation_rmse:.4f}\")\n</code></pre> <p>Key Features: - Multiple optimization algorithms - Online re-calibration - Comprehensive validation metrics - Database integration</p>"},{"location":"development/architecture/#3-database-integration","title":"3. Database Integration","text":"<p>Connect to various databases for input/output management:</p> <pre><code>import sqlalchemy\nfrom sqlalchemy import create_engine\nimport pandas as pd\n\nclass DatabaseConnector:\n    \"\"\"Connect PyADM1ODE to external databases.\n\n    Supports PostgreSQL, MySQL, SQLite for:\n    - Loading measurement data\n    - Storing simulation results\n    - Managing plant configurations\n\n    Example:\n        &gt;&gt;&gt; db = DatabaseConnector('postgresql://user:pass@localhost/biogas')\n        &gt;&gt;&gt; measurements = db.load_measurements('plant_001', start_date, end_date)\n        &gt;&gt;&gt; db.save_results(results, 'simulation_001')\n    \"\"\"\n\n    def __init__(self, connection_string: str):\n        \"\"\"Initialize database connection.\n\n        Args:\n            connection_string: SQLAlchemy connection string\n        \"\"\"\n        self.engine = create_engine(connection_string)\n\n    def load_measurements(self, plant_id: str,\n                         start_date: str, end_date: str) -&gt; pd.DataFrame:\n        \"\"\"Load measurement data from database.\n\n        Args:\n            plant_id: Plant identifier\n            start_date: Start date (YYYY-MM-DD)\n            end_date: End date (YYYY-MM-DD)\n\n        Returns:\n            DataFrame with measurement data\n        \"\"\"\n        query = f\"\"\"\n        SELECT timestamp, Q_gas, Q_ch4, pH, VFA, temperature\n        FROM measurements\n        WHERE plant_id = '{plant_id}'\n          AND timestamp BETWEEN '{start_date}' AND '{end_date}'\n        ORDER BY timestamp\n        \"\"\"\n\n        return pd.read_sql(query, self.engine)\n\n    def save_results(self, results: List[Dict[str, Any]],\n                    simulation_id: str):\n        \"\"\"Save simulation results to database.\n\n        Args:\n            results: Simulation results\n            simulation_id: Unique simulation identifier\n        \"\"\"\n        # Convert to DataFrame\n        data = []\n        for r in results:\n            row = {\n                'simulation_id': simulation_id,\n                'timestamp': r['time'],\n                'Q_gas': r['components']['main_digester']['Q_gas'],\n                'Q_ch4': r['components']['main_digester']['Q_ch4'],\n                'pH': r['components']['main_digester']['pH'],\n                'VFA': r['components']['main_digester']['VFA']\n            }\n            data.append(row)\n\n        df = pd.DataFrame(data)\n        df.to_sql('simulation_results', self.engine,\n                 if_exists='append', index=False)\n\n    def load_plant_config(self, config_id: str) -&gt; Dict[str, Any]:\n        \"\"\"Load plant configuration from database.\n\n        Args:\n            config_id: Configuration identifier\n\n        Returns:\n            Configuration dictionary\n        \"\"\"\n        query = f\"\"\"\n        SELECT config_json\n        FROM plant_configurations\n        WHERE config_id = '{config_id}'\n        \"\"\"\n\n        result = pd.read_sql(query, self.engine)\n        return json.loads(result['config_json'][0])\n\n# Usage\ndb = DatabaseConnector('postgresql://user:pass@localhost/biogas_db')\n\n# Load measurements\nmeasurements = db.load_measurements(\n    'plant_001',\n    '2024-01-01',\n    '2024-12-31'\n)\n\n# Run simulation\nplant.initialize()\nresults = plant.simulate(duration=30)\n\n# Save results\ndb.save_results(results, 'sim_20240115_001')\n</code></pre>"},{"location":"development/architecture/#4-scadaprocess-control-systems","title":"4. SCADA/Process Control Systems","text":"<p>Integrate with industrial SCADA systems for real-time monitoring and control:</p> <pre><code>from typing import Callable, Dict, Any\nimport time\nimport threading\n\nclass SCADAInterface:\n    \"\"\"Interface to SCADA/DCS systems.\n\n    Provides bidirectional communication for:\n    - Reading process values\n    - Writing setpoints\n    - Alarm management\n\n    Supports protocols:\n    - OPC UA\n    - Modbus TCP\n    - MQTT\n\n    Example:\n        &gt;&gt;&gt; scada = SCADAInterface(protocol='opcua', endpoint='opc.tcp://localhost:4840')\n        &gt;&gt;&gt; scada.start()\n        &gt;&gt;&gt; value = scada.read_tag('Digester.Temperature')\n        &gt;&gt;&gt; scada.write_tag('Feeder.Setpoint', 15.0)\n    \"\"\"\n\n    def __init__(self, protocol: str = 'opcua',\n                 endpoint: str = 'opc.tcp://localhost:4840'):\n        \"\"\"Initialize SCADA interface.\n\n        Args:\n            protocol: Communication protocol\n            endpoint: Connection endpoint\n        \"\"\"\n        self.protocol = protocol\n        self.endpoint = endpoint\n        self.connected = False\n        self.tag_cache = {}\n        self.callbacks = {}\n\n    def connect(self):\n        \"\"\"Establish connection to SCADA system.\"\"\"\n        if self.protocol == 'opcua':\n            # Example using opcua library\n            from opcua import Client\n            self.client = Client(self.endpoint)\n            self.client.connect()\n            self.connected = True\n            print(f\"Connected to OPC UA server at {self.endpoint}\")\n\n        elif self.protocol == 'mqtt':\n            # Example using paho-mqtt\n            import paho.mqtt.client as mqtt\n            self.client = mqtt.Client()\n            self.client.on_connect = self._on_mqtt_connect\n            self.client.on_message = self._on_mqtt_message\n            self.client.connect(self.endpoint.split(':')[0],\n                              int(self.endpoint.split(':')[1]))\n            self.client.loop_start()\n            self.connected = True\n            print(f\"Connected to MQTT broker at {self.endpoint}\")\n\n    def disconnect(self):\n        \"\"\"Close connection to SCADA system.\"\"\"\n        if self.connected:\n            self.client.disconnect()\n            self.connected = False\n\n    def read_tag(self, tag_name: str) -&gt; Any:\n        \"\"\"Read value from SCADA tag.\n\n        Args:\n            tag_name: Tag name/address\n\n        Returns:\n            Tag value\n        \"\"\"\n        if not self.connected:\n            raise RuntimeError(\"Not connected to SCADA system\")\n\n        if self.protocol == 'opcua':\n            node = self.client.get_node(tag_name)\n            value = node.get_value()\n            self.tag_cache[tag_name] = value\n            return value\n\n    def write_tag(self, tag_name: str, value: Any):\n        \"\"\"Write value to SCADA tag.\n\n        Args:\n            tag_name: Tag name/address\n            value: Value to write\n        \"\"\"\n        if not self.connected:\n            raise RuntimeError(\"Not connected to SCADA system\")\n\n        if self.protocol == 'opcua':\n            node = self.client.get_node(tag_name)\n            node.set_value(value)\n            print(f\"Wrote {value} to {tag_name}\")\n\n    def subscribe(self, tag_name: str, callback: Callable):\n        \"\"\"Subscribe to tag changes.\n\n        Args:\n            tag_name: Tag to monitor\n            callback: Function to call on change\n        \"\"\"\n        self.callbacks[tag_name] = callback\n\n        if self.protocol == 'opcua':\n            handler = self._create_subscription_handler(callback)\n            node = self.client.get_node(tag_name)\n            sub = self.client.create_subscription(1000, handler)\n            sub.subscribe_data_change(node)\n\n# Integration with PyADM1ODE\nclass RealTimePlantControl:\n    \"\"\"Real-time plant control using SCADA integration.\n\n    Synchronizes PyADM1ODE simulation with real plant data.\n\n    Example:\n        &gt;&gt;&gt; controller = RealTimePlantControl(plant, scada)\n        &gt;&gt;&gt; controller.start_control_loop()\n    \"\"\"\n\n    def __init__(self, plant: BiogasPlant, scada: SCADAInterface):\n        \"\"\"Initialize controller.\n\n        Args:\n            plant: BiogasPlant instance\n            scada: SCADA interface\n        \"\"\"\n        self.plant = plant\n        self.scada = scada\n        self.running = False\n\n    def read_process_values(self) -&gt; Dict[str, float]:\n        \"\"\"Read current process values from SCADA.\n\n        Returns:\n            Dictionary of process values\n        \"\"\"\n        return {\n            'temperature': self.scada.read_tag('Digester.Temperature'),\n            'pH': self.scada.read_tag('Digester.pH'),\n            'VFA': self.scada.read_tag('Digester.VFA'),\n            'Q_gas': self.scada.read_tag('GasMeter.Flow'),\n            'feed_rate': self.scada.read_tag('Feeder.ActualFlow')\n        }\n\n    def write_setpoints(self, setpoints: Dict[str, float]):\n        \"\"\"Write setpoints to SCADA.\n\n        Args:\n            setpoints: Dictionary of setpoint values\n        \"\"\"\n        for tag, value in setpoints.items():\n            self.scada.write_tag(tag, value)\n\n    def control_loop(self, dt: float = 60.0):\n        \"\"\"Main control loop.\n\n        Args:\n            dt: Loop interval [seconds]\n        \"\"\"\n        self.running = True\n\n        while self.running:\n            # Read process values\n            process_values = self.read_process_values()\n\n            # Update plant model\n            # (Simplified - real implementation would be more sophisticated)\n\n            # Run predictive simulation\n            results = self.plant.simulate(duration=1.0, dt=1/24)\n\n            # Calculate optimal setpoints\n            setpoints = self._calculate_setpoints(results, process_values)\n\n            # Write to SCADA\n            self.write_setpoints(setpoints)\n\n            # Wait for next cycle\n            time.sleep(dt)\n\n    def _calculate_setpoints(self, simulation_results, process_values):\n        \"\"\"Calculate optimal setpoints based on model prediction.\"\"\"\n        # Implement model predictive control logic\n        return {\n            'Feeder.Setpoint': 15.0,\n            'Mixer.Speed': 80.0\n        }\n\n    def start_control_loop(self):\n        \"\"\"Start control loop in background thread.\"\"\"\n        thread = threading.Thread(target=self.control_loop)\n        thread.daemon = True\n        thread.start()\n\n    def stop_control_loop(self):\n        \"\"\"Stop control loop.\"\"\"\n        self.running = False\n\n# Usage\nscada = SCADAInterface(protocol='opcua', endpoint='opc.tcp://plc.local:4840')\nscada.connect()\n\ncontroller = RealTimePlantControl(plant, scada)\ncontroller.start_control_loop()\n</code></pre>"},{"location":"development/architecture/#5-weather-and-market-data-integration","title":"5. Weather and Market Data Integration","text":"<p>Integrate external data sources for enhanced predictions:</p> <pre><code>import requests\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List\n\nclass ExternalDataIntegration:\n    \"\"\"Integrate weather and market data into simulations.\n\n    Sources:\n    - Weather forecasts (temperature, radiation)\n    - Energy market prices\n    - Agricultural commodity prices\n\n    Example:\n        &gt;&gt;&gt; data_source = ExternalDataIntegration(api_key='...')\n        &gt;&gt;&gt; weather = data_source.get_weather_forecast(location='Berlin', days=7)\n        &gt;&gt;&gt; prices = data_source.get_electricity_prices(market='DE', date='2024-01-15')\n    \"\"\"\n\n    def __init__(self, weather_api_key: str = None,\n                 market_api_key: str = None):\n        \"\"\"Initialize data integration.\n\n        Args:\n            weather_api_key: API key for weather service\n            market_api_key: API key for market data\n        \"\"\"\n        self.weather_api_key = weather_api_key\n        self.market_api_key = market_api_key\n\n    def get_weather_forecast(self, location: str,\n                            days: int = 7) -&gt; pd.DataFrame:\n        \"\"\"Get weather forecast.\n\n        Args:\n            location: Location name or coordinates\n            days: Forecast days\n\n        Returns:\n            DataFrame with weather data\n        \"\"\"\n        # Example using OpenWeatherMap API\n        url = f\"https://api.openweathermap.org/data/2.5/forecast\"\n        params = {\n            'q': location,\n            'appid': self.weather_api_key,\n            'units': 'metric',\n            'cnt': days * 8  # 3-hour intervals\n        }\n\n        response = requests.get(url, params=params)\n        data = response.json()\n\n        # Parse response\n        forecast = []\n        for item in data['list']:\n            forecast.append({\n                'timestamp': datetime.fromtimestamp(item['dt']),\n                'temperature': item['main']['temp'],\n                'humidity': item['main']['humidity'],\n                'wind_speed': item['wind']['speed']\n            })\n\n        return pd.DataFrame(forecast)\n\n    def get_electricity_prices(self, market: str = 'DE',\n                              start_date: str = None,\n                              end_date: str = None) -&gt; pd.DataFrame:\n        \"\"\"Get electricity market prices.\n\n        Args:\n            market: Market identifier (DE, FR, etc.)\n            start_date: Start date (YYYY-MM-DD)\n            end_date: End date (YYYY-MM-DD)\n\n        Returns:\n            DataFrame with price data\n        \"\"\"\n        # Example using ENTSO-E API\n        url = \"https://transparency.entsoe.eu/api\"\n        params = {\n            'securityToken': self.market_api_key,\n            'documentType': 'A44',  # Day-ahead prices\n            'in_Domain': f'{market}',\n            'out_Domain': f'{market}',\n            'periodStart': start_date.replace('-', '') + '0000',\n            'periodEnd': end_date.replace('-', '') + '0000'\n        }\n\n        response = requests.get(url, params=params)\n\n        # Parse XML response (simplified)\n        # Real implementation would parse ENTSO-E XML format\n\n        return pd.DataFrame({\n            'timestamp': pd.date_range(start_date, end_date, freq='H'),\n            'price_\u20ac_per_MWh': [45.5] * 24  # Example data\n        })\n\n    def optimize_operation(self, weather_forecast: pd.DataFrame,\n                          price_forecast: pd.DataFrame,\n                          plant: BiogasPlant) -&gt; Dict[str, Any]:\n        \"\"\"Optimize plant operation based on forecasts.\n\n        Args:\n            weather_forecast: Weather data\n            price_forecast: Electricity prices\n            plant: BiogasPlant instance\n\n        Returns:\n            Optimization recommendations\n        \"\"\"\n        # Simple example: Adjust CHP operation to price peaks\n        avg_price = price_forecast['price_\u20ac_per_MWh'].mean()\n        peak_hours = price_forecast[\n            price_forecast['price_\u20ac_per_MWh'] &gt; avg_price * 1.2\n        ]\n\n        recommendations = {\n            'strategy': 'price_optimized',\n            'peak_hours': peak_hours['timestamp'].tolist(),\n            'recommended_actions': [\n                f\"Run CHP at full load during {len(peak_hours)} peak hours\",\n                f\"Store gas during {24-len(peak_hours)} low-price hours\",\n                f\"Expected additional revenue: {(avg_price * 0.2 * len(peak_hours)):.0f} \u20ac/day\"\n            ]\n        }\n\n        return recommendations\n\n# Usage\ndata_integration = ExternalDataIntegration(\n    weather_api_key='your_openweather_key',\n    market_api_key='your_entsoe_key'\n)\n\n# Get forecasts\nweather = data_integration.get_weather_forecast('Berlin', days=7)\nprices = data_integration.get_electricity_prices(\n    market='DE',\n    start_date='2024-01-15',\n    end_date='2024-01-22'\n)\n\n# Optimize operation\noptimization = data_integration.optimize_operation(weather, prices, plant)\nprint(optimization['recommended_actions'])\n</code></pre>"},{"location":"development/architecture/#6-cloud-deployment","title":"6. Cloud Deployment","text":"<p>Deploy PyADM1ODE as cloud service:</p> <pre><code>from flask import Flask, request, jsonify\nfrom pyadm1.configurator import BiogasPlant\nfrom pyadm1.substrates import Feedstock\nimport json\n\napp = Flask(__name__)\n\nclass CloudSimulationService:\n    \"\"\"RESTful API for cloud-based biogas simulation.\n\n    Endpoints:\n    - POST /api/simulate: Run simulation\n    - GET /api/plant/{id}: Get plant configuration\n    - POST /api/plant: Create new plant\n\n    Example:\n        &gt;&gt;&gt; # Start service\n        &gt;&gt;&gt; service = CloudSimulationService()\n        &gt;&gt;&gt; service.run(host='0.0.0.0', port=5000)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Client request\n        &gt;&gt;&gt; import requests\n        &gt;&gt;&gt; response = requests.post(\n        ...     'http://api.example.com/api/simulate',\n        ...     json={'plant_id': 'plant_001', 'duration': 30}\n        ... )\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize cloud service.\"\"\"\n        self.plants = {}\n        self.feedstock = Feedstock(feeding_freq=48)\n\n    @app.route('/api/simulate', methods=['POST'])\n    def simulate(self):\n        \"\"\"Run simulation endpoint.\"\"\"\n        data = request.json\n        plant_id = data.get('plant_id')\n        duration = data.get('duration', 30)\n\n        # Get or create plant\n        if plant_id not in self.plants:\n            return jsonify({'error': 'Plant not found'}), 404\n\n        plant = self.plants[plant_id]\n\n        # Run simulation\n        try:\n            plant.initialize()\n            results = plant.simulate(duration=duration, dt=1/24)\n\n            # Extract summary\n            final = results[-1]\n            summary = {\n                'status': 'success',\n                'duration': duration,\n                'biogas_production': final['components']['main_digester']['Q_gas'],\n                'methane_production': final['components']['main_digester']['Q_ch4'],\n                'electrical_power': final['components'].get('chp1', {}).get('P_el', 0),\n                'pH': final['components']['main_digester']['pH']\n            }\n\n            return jsonify(summary), 200\n\n        except Exception as e:\n            return jsonify({'error': str(e)}), 500\n\n    @app.route('/api/plant', methods=['POST'])\n    def create_plant(self):\n        \"\"\"Create new plant endpoint.\"\"\"\n        config = request.json\n\n        try:\n            # Create plant from config\n            plant = BiogasPlant.from_dict(config, self.feedstock)\n            plant_id = config['plant_name']\n            self.plants[plant_id] = plant\n\n            return jsonify({\n                'status': 'created',\n                'plant_id': plant_id\n            }), 201\n\n        except Exception as e:\n            return jsonify({'error': str(e)}), 400\n\n    @app.route('/api/plant/', methods=['GET'])\n    def get_plant(self, plant_id):\n        \"\"\"Get plant configuration endpoint.\"\"\"\n        if plant_id not in self.plants:\n            return jsonify({'error': 'Plant not found'}), 404\n\n        plant = self.plants[plant_id]\n        config = plant.to_dict()\n\n        return jsonify(config), 200\n\n    def run(self, host='0.0.0.0', port=5000):\n        \"\"\"Start service.\"\"\"\n        app.run(host=host, port=port)\n\n# Deploy\nif __name__ == '__main__':\n    service = CloudSimulationService()\n    service.run()\n</code></pre> <p>Docker Deployment:</p> <pre><code># Dockerfile\nFROM python:3.10-slim\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    mono-complete \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install PyADM1ODE\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\nRUN pip install -e .\n\n# Expose port\nEXPOSE 5000\n\n# Run service\nCMD [\"python\", \"cloud_service.py\"]\n</code></pre> <pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  pyadm1-api:\n    build: .\n    ports:\n      - \"5000:5000\"\n    environment:\n      - FLASK_ENV=production\n    volumes:\n      - ./data:/app/data\n    restart: unless-stopped\n\n  postgres:\n    image: postgres:14\n    environment:\n      POSTGRES_DB: biogas_db\n      POSTGRES_USER: pyadm1\n      POSTGRES_PASSWORD: secure_password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:\n</code></pre>"},{"location":"development/architecture/#7-jupyter-notebook-integration","title":"7. Jupyter Notebook Integration","text":"<p>Interactive analysis and visualization:</p> <pre><code># biogas_analysis.ipynb\n\n# Cell 1: Setup\nfrom pyadm1.configurator import BiogasPlant, PlantConfigurator\nfrom pyadm1.substrates import Feedstock\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport ipywidgets as widgets\nfrom IPython.display import display\n\n%matplotlib inline\n\n# Cell 2: Interactive Plant Designer\ndef create_interactive_plant():\n    \"\"\"Interactive widget for plant design.\"\"\"\n\n    # Widgets\n    v_liq_slider = widgets.FloatSlider(\n        value=2000, min=500, max=5000, step=100,\n        description='V_liq [m\u00b3]:'\n    )\n\n    p_el_slider = widgets.FloatSlider(\n        value=500, min=100, max=2000, step=50,\n        description='CHP [kW]:'\n    )\n\n    corn_slider = widgets.FloatSlider(\n        value=15, min=0, max=50, step=1,\n        description='Corn [m\u00b3/d]:'\n    )\n\n    manure_slider = widgets.FloatSlider(\n        value=10, min=0, max=50, step=1,\n        description='Manure [m\u00b3/d]:'\n    )\n\n    button = widgets.Button(description='Simulate')\n    output = widgets.Output()\n\n    def on_button_click(b):\n        with output:\n            output.clear_output()\n\n            # Create plant\n            feedstock = Feedstock(feeding_freq=48)\n            plant = BiogasPlant(\"Interactive Plant\")\n            config = PlantConfigurator(plant, feedstock)\n\n            Q = [corn_slider.value, manure_slider.value, 0, 0, 0, 0, 0, 0, 0, 0]\n\n            config.add_digester(\"dig1\", V_liq=v_liq_slider.value,\n                               Q_substrates=Q)\n            config.add_chp(\"chp1\", P_el_nom=p_el_slider.value)\n            config.auto_connect_digester_to_chp(\"dig1\", \"chp1\")\n\n            # Simulate\n            plant.initialize()\n            results = plant.simulate(duration=30, dt=1/24, save_interval=1.0)\n\n            # Plot\n            times = [r['time'] for r in results]\n            biogas = [r['components']['dig1']['Q_gas'] for r in results]\n            power = [r['components']['chp1']['P_el'] for r in results]\n\n            fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))\n\n            ax1.plot(times, biogas)\n            ax1.set_ylabel('Biogas [m\u00b3/d]')\n            ax1.grid(True)\n\n            ax2.plot(times, power)\n            ax2.set_xlabel('Time [days]')\n            ax2.set_ylabel('Power [kW]')\n            ax2.grid(True)\n\n            plt.tight_layout()\n            plt.show()\n\n            # Summary\n            final = results[-1]\n            print(f\"\\nFinal Results:\")\n            print(f\"Biogas: {final['components']['dig1']['Q_gas']:.1f} m\u00b3/d\")\n            print(f\"Power: {final['components']['chp1']['P_el']:.1f} kW\")\n\n    button.on_click(on_button_click)\n\n    display(v_liq_slider, p_el_slider, corn_slider, manure_slider, button, output)\n\n# Cell 3: Run interactive designer\ncreate_interactive_plant()\n</code></pre>"},{"location":"development/architecture/#summary","title":"Summary","text":"<p>PyADM1ODE's architecture provides:</p> <ol> <li>Modularity: Independent, reusable components</li> <li>Extensibility: Multiple extension points for customization</li> <li>Integration: Interfaces to external systems (MCP, databases, SCADA, cloud)</li> <li>Scalability: From single simulations to large-scale parallel analyses</li> <li>Maintainability: Clean separation of concerns, well-documented APIs</li> </ol> <p>The design enables: - Rapid prototyping of biogas plant concepts - Integration with existing infrastructure - Extension for research and commercial applications - Deployment in various environments (local, cloud, embedded)</p> <p>For detailed implementation examples, see: - Adding Components Guide - API Reference - Examples Custom Substrates</p>"},{"location":"examples/basic_digester/","title":"Basic Digester Example","text":"<p>The examples/basic_digester.py example demonstrates the simplest possible PyADM1 configuration: a single digester with substrate feed and integrated gas storage.</p>"},{"location":"examples/basic_digester/#system-architecture","title":"System Architecture","text":"<pre><code>graph LR\n    %% Substrate input\n    Feed[Substrate Feed&lt;br/&gt;Corn silage: 15 m\u00b3/d&lt;br/&gt;Cattle manure: 10 m\u00b3/d] --&gt; Digester\n\n    %% Main digester\n    Digester[Digester&lt;br/&gt;V_liq: 2000 m\u00b3&lt;br/&gt;V_gas: 300 m\u00b3&lt;br/&gt;T: 35\u00b0C]\n\n    %% Integrated gas storage\n    Digester --&gt;|Biogas production| Storage[Gas Storage&lt;br/&gt;Membrane type&lt;br/&gt;Capacity: 300 m\u00b3&lt;br/&gt;P: 0.95-1.05 bar]\n\n    %% Gas output\n    Storage --&gt;|Available biogas| Output[Biogas Output&lt;br/&gt;~1250 m\u00b3/d&lt;br/&gt;CH\u2084: ~60%]\n\n    %% Excess venting\n    Storage -.-&gt;|Excess gas&lt;br/&gt;when full| Vent[Vented to atmosphere&lt;br/&gt;or flare]\n\n    %% Liquid output\n    Digester --&gt;|Effluent&lt;br/&gt;25 m\u00b3/d| Effluent[Digestate Output]\n\n    %% Styling\n    classDef processBox fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    classDef storageBox fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    classDef inputBox fill:#f1f8e9,stroke:#33691e,stroke-width:2px\n    classDef outputBox fill:#fce4ec,stroke:#880e4f,stroke-width:2px\n\n    class Digester processBox\n    class Storage storageBox\n    class Feed inputBox\n    class Output,Effluent,Vent outputBox</code></pre>"},{"location":"examples/basic_digester/#overview","title":"Overview","text":"<p>The basic digester example shows: - Loading substrate data (feedstock management) - Creating a single-stage biogas plant - Automatic gas storage creation per digester - Initializing from a steady-state CSV file - Running a short simulation (5 days) - Extracting and displaying key process indicators</p>"},{"location":"examples/basic_digester/#plant-configuration","title":"Plant Configuration","text":"<p>The plant consists of: - 1 Digester (2000 m\u00b3 liquid volume, 300 m\u00b3 gas volume) - 1 Gas Storage (automatically created, attached to digester) - Substrate Feed: Corn silage (15 m\u00b3/d) + Cattle manure (10 m\u00b3/d)</p> <p>Key Point: The gas storage is automatically created by <code>PlantConfigurator.add_digester()</code> and connected to the digester. This ensures realistic gas buffering and pressure management.</p>"},{"location":"examples/basic_digester/#code-walkthrough","title":"Code Walkthrough","text":""},{"location":"examples/basic_digester/#1-setup-and-imports","title":"1. Setup and Imports","text":"<pre><code>from pyadm1.configurator.plant_builder import BiogasPlant\nfrom pyadm1.substrates.feedstock import Feedstock\nfrom pyadm1.core.adm1 import get_state_zero_from_initial_state\nfrom pyadm1.configurator.plant_configurator import PlantConfigurator\n</code></pre> <p>The key imports are: - <code>BiogasPlant</code>: Container for all plant components - <code>Feedstock</code>: Manages substrate properties and mixing - <code>PlantConfigurator</code>: High-level helper for adding components (automatically handles gas storage) - <code>get_state_zero_from_initial_state</code>: Loads initial state from CSV</p>"},{"location":"examples/basic_digester/#2-create-feedstock","title":"2. Create Feedstock","text":"<pre><code>feeding_freq = 48  # Can change substrate every 48 hours\nfeedstock = Feedstock(feeding_freq=feeding_freq)\n</code></pre> <p>The feedstock object loads substrate parameters from <code>substrate_gummersbach.xml</code> and manages: - Substrate composition (Weender analysis) - ADM1 parameter calculation - Influent stream generation</p> <p>Feeding Frequency: The <code>feeding_freq</code> parameter (48 hours) defines how often the controller can adjust substrate feeds. This is important for optimization and control applications.</p>"},{"location":"examples/basic_digester/#3-load-initial-state","title":"3. Load Initial State","text":"<pre><code>initial_state_file = data_path / \"digester_initial8.csv\"\nadm1_state = get_state_zero_from_initial_state(str(initial_state_file))\n</code></pre> <p>The initial state CSV contains 37 ADM1 state variables representing a steady-state condition. This avoids long initialization periods where the model transitions from unrealistic starting values.</p> <p>ADM1 State Vector (37 variables): - Soluble components (0-11): S_su, S_aa, S_fa, S_va, S_bu, S_pro, S_ac, S_h2, S_ch4, S_co2, S_nh4, S_I - Particulate components (12-24): X_xc, X_ch, X_pr, X_li, X_su, X_aa, X_fa, X_c4, X_pro, X_ac, X_h2, X_I, X_p - Ions (25-32): S_cation, S_anion, S_va_ion, S_bu_ion, S_pro_ion, S_ac_ion, S_hco3_ion, S_nh3 - Gas phase (33-36): pi_Sh2, pi_Sch4, pi_Sco2, pTOTAL</p>"},{"location":"examples/basic_digester/#4-define-substrate-feed","title":"4. Define Substrate Feed","text":"<pre><code>Q_substrates = [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]  # Corn silage and manure\n</code></pre> <p>The feed vector <code>Q_substrates</code> specifies volumetric flow rates [m\u00b3/d] for each substrate defined in the XML file. In this example: - Substrate 1 (corn silage): 15 m\u00b3/d - Substrate 2 (cattle manure): 10 m\u00b3/d - Substrates 3-10: Not used (0 m\u00b3/d)</p> <p>Hydraulic retention time (HRT): 25 m\u00b3/d \u00f7 2000 m\u00b3 = 0.0125 d\u207b\u00b9 or HRT \u2248 80 days</p>"},{"location":"examples/basic_digester/#5-build-plant-with-plantconfigurator","title":"5. Build Plant with PlantConfigurator","text":"<pre><code>plant = BiogasPlant(\"Quickstart Plant\")\nconfigurator = PlantConfigurator(plant, feedstock)\n\nconfigurator.add_digester(\n    digester_id=\"main_digester\",\n    V_liq=2000.0,\n    V_gas=300.0,\n    T_ad=308.15,  # 35\u00b0C mesophilic\n    name=\"Main Digester\",\n    load_initial_state=True,\n    initial_state_file=str(initial_state_file),\n    Q_substrates=Q_substrates,\n)\n</code></pre> <p>PlantConfigurator provides a high-level API that: - Automatically creates and attaches a gas storage to each digester - Handles initialization with proper error checking - Validates component parameters - Manages connections between components</p> <p>The gas storage is created with: - Type: Membrane storage (low-pressure, typical for biogas) - Capacity: Based on V_gas parameter (300 m\u00b3) - Pressure range: 0.95-1.05 bar (typical membrane storage) - Initial fill: 10% of capacity</p> <p>Design Parameters: - <code>V_liq=2000.0</code>: Liquid volume [m\u00b3] - typical for medium-scale farm plant - <code>V_gas=300.0</code>: Gas headspace [m\u00b3] - about 15% of liquid volume - <code>T_ad=308.15</code>: Operating temperature [K] = 35\u00b0C (mesophilic range)</p>"},{"location":"examples/basic_digester/#6-initialize-and-simulate","title":"6. Initialize and Simulate","text":"<pre><code>plant.initialize()\n\nresults = plant.simulate(\n    duration=5.0,        # 5 days\n    dt=1.0 / 24.0,      # 1 hour time step\n    save_interval=1.0    # Save results daily\n)\n</code></pre> <p>Simulation Parameters: - <code>duration</code>: Total simulation time [days] - <code>dt</code>: Integration time step [days]. 1 hour (1/24 day) is standard for ADM1 - <code>save_interval</code>: How often to save results [days]. Daily saves reduce memory usage</p> <p>Note: The simulator uses a BDF (Backward Differentiation Formula) solver optimized for stiff ODEs like ADM1.</p> <p>Three-Pass Gas Flow Simulation: 1. Pass 1: Digester produces biogas \u2192 Gas storage receives 2. Pass 2: Gas storage updates internal state (pressure, volume) 3. Pass 3: Gas available for downstream consumers (CHPs, etc.)</p>"},{"location":"examples/basic_digester/#7-display-results","title":"7. Display Results","text":"<pre><code>for result in results:\n    comp_results = result[\"components\"][\"main_digester\"]\n    print(f\"Day {time:.1f}:\")\n    print(f\"  Biogas:  {comp_results.get('Q_gas', 0):&gt;8.1f} m\u00b3/d\")\n    print(f\"  Methane: {comp_results.get('Q_ch4', 0):&gt;8.1f} m\u00b3/d\")\n    print(f\"  pH:      {comp_results.get('pH', 0):&gt;8.2f}\")\n    print(f\"  VFA:     {comp_results.get('VFA', 0):&gt;8.2f} g/L\")\n    print(f\"  TAC:     {comp_results.get('TAC', 0):&gt;8.2f} g/L\")\n</code></pre> <p>Key Process Indicators: - Q_gas: Total biogas production [m\u00b3/d] - Q_ch4: Methane production [m\u00b3/d] - pH: Process pH (optimal: 6.8-7.5) - VFA: Volatile Fatty Acids [g HAc-eq/L] (optimal: &lt;3 g/L) - TAC: Total Alkalinity [g CaCO\u2083-eq/L] (optimal: &gt;6 g/L)</p> <p>Gas Storage Indicators (included in digester results): - stored_volume_m3: Current gas volume in storage [m\u00b3] - pressure_bar: Current storage pressure [bar] - vented_volume_m3: Gas vented this timestep [m\u00b3] - Q_gas_supplied_m3_per_day: Gas available for consumers [m\u00b3/d]</p>"},{"location":"examples/basic_digester/#expected-output","title":"Expected Output","text":"<p>Running this example produces output like:</p> <pre><code>======================================================================\nPyADM1 Quickstart Example (PlantConfigurator version)\n======================================================================\n\n1. Creating feedstock...\n2. Loading initial state from CSV...\n   Loading from: digester_initial8.csv\n3. Creating biogas plant...\n4. Adding digester with PlantConfigurator...\n   - Digester 'main_digester' created\n   - Gas storage 'main_digester_storage' automatically created\n   - Initial state: Loaded from digester_initial8.csv\n5. Initializing plant...\n6. Running simulation...\n   Duration: 5 days\n   Time step: 1 hour\n   Save interval: 1 day\n\n======================================================================\nSIMULATION RESULTS\n======================================================================\n\nGenerated 6 daily result snapshots\n\nDay 0.0:\n  Biogas:   1245.3 m\u00b3/d\n  Methane:   748.2 m\u00b3/d\n  pH:          7.28\n  VFA:         2.34 g/L\n  TAC:         8.45 g/L\n  Storage:\n    - Volume: 30.0 m\u00b3 (10% full)\n    - Pressure: 0.97 bar\n    - Vented: 0.0 m\u00b3\n\nDay 1.0:\n  Biogas:   1248.7 m\u00b3/d\n  Methane:   750.1 m\u00b3/d\n  pH:          7.29\n  VFA:         2.32 g/L\n  TAC:         8.47 g/L\n  Storage:\n    - Volume: 82.3 m\u00b3 (27% full)\n    - Pressure: 1.01 bar\n    - Vented: 0.0 m\u00b3\n\n...\n\n======================================================================\nFINAL SUMMARY\n======================================================================\nTotal biogas production:  1251.4 m\u00b3/d\nTotal methane production: 751.9 m\u00b3/d\nMethane content:          60.1%\nProcess stability (pH):   7.30\nGas storage utilization:  35%\n======================================================================\n\n\u2705 Simulation completed successfully!\n\n\ud83d\udcbe Configuration saved to: output/quickstart_config.json\n</code></pre>"},{"location":"examples/basic_digester/#process-interpretation","title":"Process Interpretation","text":""},{"location":"examples/basic_digester/#typical-performance-metrics","title":"Typical Performance Metrics","text":"<p>For this configuration (25 m\u00b3/d feed, HRT \u2248 80 days):</p> Metric Value Assessment Biogas production ~1250 m\u00b3/d Good Methane content ~60% Typical for agricultural substrates Specific gas yield ~50 m\u00b3/m\u00b3 feed Good for corn silage + manure mix pH 7.28-7.30 Optimal (stable) VFA 2.3-2.4 g/L Good (well below 3 g/L limit) TAC 8.4-8.5 g CaCO\u2083/L Excellent buffer capacity FOS/TAC ~0.27 Stable process (&lt; 0.3)"},{"location":"examples/basic_digester/#process-stability-indicators","title":"Process Stability Indicators","text":"<p>pH Stability: The pH remains around 7.3, indicating: - Good buffer capacity (high TAC) - Balanced VFA production and consumption - No acidification risk</p> <p>VFA/TAC Balance: VFA at 2.3 g/L with TAC at 8.4 g/L gives FOS/TAC \u2248 0.27: - &lt; 0.3: Stable process - 0.3-0.4: Monitor closely - &gt; 0.4: Risk of acidification</p> <p>Methane Content: 60% CH\u2084 is typical for: - Energy crops (corn silage) - Animal manure - Mesophilic digestion</p>"},{"location":"examples/basic_digester/#gas-storage-behavior","title":"Gas Storage Behavior","text":"<p>The automatically created gas storage: - Type: Low-pressure membrane storage - Capacity: ~300 m\u00b3 (based on V_gas) - Pressure range: 0.95-1.05 bar - Function: Buffers gas production fluctuations - Safety: Vents excess gas when full to prevent overpressure</p> <p>Storage Dynamics: <pre><code>'gas_storage': {\n    'stored_volume_m3': 150.0,      # Current gas volume\n    'pressure_bar': 1.01,            # Current pressure\n    'vented_volume_m3': 0.0,         # Vented this timestep\n    'utilization': 0.50,             # 50% full\n    'Q_gas_supplied_m3_per_day': 1250.0  # Available for consumers\n}\n</code></pre></p> <p>When storage fills up: - Pressure increases from 0.95 to 1.05 bar - At 1.05 bar (full capacity), excess gas is vented - Venting prevents overpressure and equipment damage - In real plants, vented gas goes to flare for safety combustion</p>"},{"location":"examples/basic_digester/#configuration-export","title":"Configuration Export","text":"<p>The plant configuration is saved to JSON:</p> <pre><code>{\n  \"plant_name\": \"Quickstart Plant\",\n  \"simulation_time\": 5.0,\n  \"components\": [\n    {\n      \"component_id\": \"main_digester\",\n      \"component_type\": \"digester\",\n      \"V_liq\": 2000.0,\n      \"V_gas\": 300.0,\n      \"T_ad\": 308.15,\n      \"state\": {...}\n    },\n    {\n      \"component_id\": \"main_digester_storage\",\n      \"component_type\": \"storage\",\n      \"storage_type\": \"membrane\",\n      \"capacity_m3\": 300.0,\n      \"p_min_bar\": 0.95,\n      \"p_max_bar\": 1.05\n    }\n  ],\n  \"connections\": [\n    {\n      \"from\": \"main_digester\",\n      \"to\": \"main_digester_storage\",\n      \"type\": \"gas\"\n    }\n  ]\n}\n</code></pre> <p>This JSON file can be reloaded to restore the exact plant state:</p> <pre><code>plant = BiogasPlant.from_json(\"output/quickstart_config.json\", feedstock)\n</code></pre>"},{"location":"examples/basic_digester/#next-steps","title":"Next Steps","text":"<p>After running this basic example:</p> <ol> <li>Try parameter variations:</li> <li>Adjust substrate feed rates in <code>Q_substrates</code></li> <li>Change digester temperature <code>T_ad</code></li> <li> <p>Modify digester volume <code>V_liq</code></p> </li> <li> <p>Extend simulation duration:    <pre><code>results = plant.simulate(duration=30.0, dt=1.0/24.0)\n</code></pre></p> </li> <li> <p>Add energy components:    See <code>two_stage_plant.md</code> for CHP and heating integration</p> </li> <li> <p>Implement control:    Use <code>Simulator.determine_best_feed_by_n_sims()</code> for optimization</p> </li> </ol>"},{"location":"examples/basic_digester/#common-issues","title":"Common Issues","text":""},{"location":"examples/basic_digester/#issue-initial-state-file-not-found","title":"Issue: \"Initial state file not found\"","text":"<p>Solution: Ensure <code>data/initial_states/digester_initial8.csv</code> exists, or set <code>load_initial_state=False</code>:</p> <pre><code>configurator.add_digester(\n    digester_id=\"main_digester\",\n    V_liq=2000.0,\n    load_initial_state=False,  # Use default initialization\n    Q_substrates=Q_substrates,\n)\n</code></pre>"},{"location":"examples/basic_digester/#issue-low-gas-production","title":"Issue: Low gas production","text":"<p>Causes: - HRT too short (increase V_liq or reduce Q_substrates) - Substrate feed too low (increase values in Q_substrates) - Temperature too low (increase T_ad)</p> <p>Example fix: <pre><code>Q_substrates = [20, 15, 0, 0, 0, 0, 0, 0, 0, 0]  # Increase feed\n</code></pre></p>"},{"location":"examples/basic_digester/#issue-process-instability-ph-drop","title":"Issue: Process instability (pH drop)","text":"<p>Causes: - Organic overload (reduce Q_substrates) - Insufficient buffer capacity</p> <p>Example fix: <pre><code># Add buffer substrate (e.g., lime at index 7)\nQ_substrates = [15, 10, 0, 0, 0, 0, 0, 1, 0, 0]  # 1 m\u00b3/d lime\n</code></pre></p>"},{"location":"examples/basic_digester/#issue-gas-storage-overpressure-warnings","title":"Issue: Gas storage overpressure warnings","text":"<p>Symptoms: - Frequent venting messages - Storage constantly at maximum pressure</p> <p>Solutions: <pre><code># Increase gas storage capacity\nconfigurator.add_digester(\n    digester_id=\"main_digester\",\n    V_liq=2000.0,\n    V_gas=500.0,  # Increased from 300\n    Q_substrates=Q_substrates,\n)\n</code></pre></p>"},{"location":"examples/basic_digester/#references","title":"References","text":"<ul> <li>ADM1 Model: Batstone et al. (2002). Anaerobic Digestion Model No. 1. IWA Publishing.</li> <li>PyADM1: Sadrimajd et al. (2021). PyADM1: a Python implementation of ADM1. bioRxiv.</li> <li>Substrate Characterization: Gaida (2014). Dynamic real-time substrate feed optimization of anaerobic co-digestion plants. PhD thesis, Leiden University.</li> <li>Leitfaden Biogas: FNR (2016). https://mediathek.fnr.de/leitfaden-biogas.html</li> </ul>"},{"location":"examples/basic_digester/#related-examples","title":"Related Examples","text":"<ul> <li><code>two_stage_plant.md</code>: Two-stage digestion with CHP and heating</li> <li><code>calibration_workflow.md</code>: Parameter estimation from measurement data</li> <li><code>substrate_optimization.py</code>: Optimal feed strategy</li> <li><code>parallel_two_stage_simulation.py</code>: Parallel simulations</li> </ul>"},{"location":"examples/parallel_simulation/","title":"Parallel Simulation Example","text":"<p>The examples/05_parallel_two_stage_simulation.py example demonstrates efficient parallel execution of multiple biogas plant simulation scenarios for parameter optimization, sensitivity analysis, and uncertainty quantification.</p>"},{"location":"examples/parallel_simulation/#overview","title":"Overview","text":"<p>This example demonstrates: - Parallel Scenario Execution: Running multiple simulations concurrently across CPU cores - Parameter Sweeps: Systematic exploration of single and multiple parameter variations - Monte Carlo Analysis: Uncertainty quantification with parameter distributions - Statistical Analysis: Result aggregation and comparative statistics - Performance Metrics: Speedup and parallel efficiency measurement</p>"},{"location":"examples/parallel_simulation/#architecture","title":"Architecture","text":"<pre><code>graph TB\n    subgraph \"Main Process\"\n        Config[Configuration]\n        Results[Result Collection]\n    end\n\n    subgraph \"Worker Pool (4 cores)\"\n        W1[Worker 1]\n        W2[Worker 2]\n        W3[Worker 3]\n        W4[Worker 4]\n    end\n\n    Config --&gt;|Scenario 1| W1\n    Config --&gt;|Scenario 2| W2\n    Config --&gt;|Scenario 3| W3\n    Config --&gt;|Scenario 4| W4\n\n    W1 --&gt;|Result 1| Results\n    W2 --&gt;|Result 2| Results\n    W3 --&gt;|Result 3| Results\n    W4 --&gt;|Result 4| Results\n\n    style Config fill:#e1f5fe\n    style Results fill:#c8e6c9\n    style W1 fill:#fff3e0\n    style W2 fill:#fff3e0\n    style W3 fill:#fff3e0\n    style W4 fill:#fff3e0</code></pre>"},{"location":"examples/parallel_simulation/#key-components","title":"Key Components","text":""},{"location":"examples/parallel_simulation/#1-parallelsimulator","title":"1. ParallelSimulator","text":"<p>The <code>ParallelSimulator</code> class orchestrates concurrent execution:</p> <pre><code>from pyadm1.simulation.parallel import ParallelSimulator\n\n# Create parallel simulator with 4 worker processes\nparallel = ParallelSimulator(adm1_model, n_workers=4, verbose=True)\n\n# Define scenarios\nscenarios = [\n    {\"k_dis\": 0.5, \"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]},\n    {\"k_dis\": 0.6, \"Q\": [20, 10, 0, 0, 0, 0, 0, 0, 0, 0]},\n    {\"k_dis\": 0.7, \"Q\": [15, 15, 0, 0, 0, 0, 0, 0, 0, 0]},\n]\n\n# Run parallel simulations\nresults = parallel.run_scenarios(\n    scenarios=scenarios,\n    duration=10.0,  # 10 days\n    initial_state=adm1_state,\n    compute_metrics=True\n)\n</code></pre> <p>Key Features: - Multiprocessing: Uses Python's <code>multiprocessing.Pool</code> for true parallelism - Automatic Workload Distribution: Scenarios distributed evenly across workers - Progress Tracking: Real-time progress reporting for long-running analyses - Error Isolation: Individual scenario failures don't crash entire execution</p>"},{"location":"examples/parallel_simulation/#2-scenarioresult","title":"2. ScenarioResult","text":"<p>Each simulation returns a <code>ScenarioResult</code> object:</p> <pre><code>@dataclass\nclass ScenarioResult:\n    scenario_id: int                          # Unique identifier\n    parameters: Dict[str, Any]                # Parameter values used\n    success: bool                             # Completion status\n    duration: float                           # Simulation duration [days]\n    final_state: Optional[List[float]]        # Final ADM1 state vector\n    time_series: Optional[Dict[str, List]]    # Optional time series data\n    metrics: Dict[str, float]                 # Performance metrics\n    error: Optional[str]                      # Error message if failed\n    execution_time: float                     # Wall clock time [seconds]\n</code></pre> <p>Computed Metrics (when <code>compute_metrics=True</code>): - <code>Q_gas</code>: Total biogas production [m\u00b3/d] - <code>Q_ch4</code>: Methane production [m\u00b3/d] - <code>Q_co2</code>: CO2 production [m\u00b3/d] - <code>CH4_content</code>: Methane fraction [0-1] - <code>pH</code>: pH value [-] - <code>VFA</code>: Volatile fatty acids [g/L] - <code>TAC</code>: Total alkalinity [g CaCO3/L] - <code>FOS_TAC</code>: VFA/TA ratio [-] - <code>HRT</code>: Hydraulic retention time [days] - <code>specific_gas_production</code>: Biogas yield [m\u00b3/m\u00b3 feed]</p>"},{"location":"examples/parallel_simulation/#simulation-types","title":"Simulation Types","text":""},{"location":"examples/parallel_simulation/#basic-parallel-scenarios","title":"Basic Parallel Scenarios","text":"<p>Run multiple independent scenarios with different configurations:</p> <pre><code># Define feed rate scenarios\nfeed_scenarios = [\n    {\"name\": \"Low Feed\", \"Q_digester_1\": [10, 8, 0, 0, 0, 0, 0, 0, 0, 0]},\n    {\"name\": \"Base Feed\", \"Q_digester_1\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]},\n    {\"name\": \"High Feed\", \"Q_digester_1\": [20, 12, 0, 0, 0, 0, 0, 0, 0, 0]},\n]\n\nscenarios = [{\"Q\": s[\"Q_digester_1\"]} for s in feed_scenarios]\n\nresults = parallel.run_scenarios(\n    scenarios=scenarios,\n    duration=10.0,\n    initial_state=adm1_state,\n    dt=1.0/24.0,  # 1 hour time step\n    compute_metrics=True,\n    save_time_series=False  # Set True for detailed time series\n)\n</code></pre> <p>Use Cases: - Comparing different operational strategies - Testing substrate composition variations - Evaluating design alternatives</p>"},{"location":"examples/parallel_simulation/#single-parameter-sweep","title":"Single-Parameter Sweep","text":"<p>Systematic exploration of one parameter:</p> <pre><code>from pyadm1.simulation.parallel import ParameterSweepConfig\n\n# Sweep disintegration rate\nsweep_config = ParameterSweepConfig(\n    parameter_name=\"k_dis\",\n    values=[0.10, 0.14, 0.18, 0.22, 0.26, 0.30],\n    other_params={\"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]}\n)\n\nresults = parallel.parameter_sweep(\n    config=sweep_config,\n    duration=10.0,\n    initial_state=adm1_state,\n    compute_metrics=True\n)\n\n# Find optimal value\nch4_productions = [r.metrics.get('Q_ch4', 0) for r in results if r.success]\nbest_idx = np.argmax(ch4_productions)\noptimal_k_dis = sweep_config.values[best_idx]\n</code></pre> <p>Common Parameters to Sweep: - Kinetic parameters: <code>k_dis</code>, <code>k_hyd_ch</code>, <code>k_hyd_pr</code>, <code>k_hyd_li</code> - Yield parameters: <code>Y_su</code>, <code>Y_aa</code>, <code>Y_fa</code>, <code>Y_c4</code>, <code>Y_pro</code>, <code>Y_ac</code>, <code>Y_h2</code> - Uptake rates: <code>k_m_su</code>, <code>k_m_aa</code>, <code>k_m_fa</code>, <code>k_m_c4</code>, <code>k_m_pro</code>, <code>k_m_ac</code> - Operational parameters: Feed rates, temperatures, retention times</p>"},{"location":"examples/parallel_simulation/#multi-parameter-sweep","title":"Multi-Parameter Sweep","text":"<p>Full factorial design exploring parameter interactions:</p> <pre><code>parameter_configs = {\n    \"k_dis\": [0.14, 0.18, 0.22],\n    \"Y_su\": [0.09, 0.10, 0.11],\n    \"Q_substrate_0\": [12, 15, 18]  # Corn silage feed rate\n}\n\nresults = parallel.multi_parameter_sweep(\n    parameter_configs=parameter_configs,\n    duration=10.0,\n    initial_state=adm1_state,\n    fixed_params={\"Q_substrate_1\": 10}  # Manure fixed at 10 m\u00b3/d\n)\n\n# Total combinations: 3 \u00d7 3 \u00d7 3 = 27 scenarios\n</code></pre> <p>Analysis: <pre><code># Find best combination\nbest_result = max(\n    (r for r in results if r.success),\n    key=lambda r: r.metrics.get('Q_ch4', 0)\n)\n\nprint(f\"Optimal parameters:\")\nprint(f\"  k_dis = {best_result.parameters['k_dis']:.2f}\")\nprint(f\"  Y_su = {best_result.parameters['Y_su']:.2f}\")\nprint(f\"  Q_substrate_0 = {best_result.parameters['Q_substrate_0']:.1f} m\u00b3/d\")\nprint(f\"  Methane production = {best_result.metrics['Q_ch4']:.1f} m\u00b3/d\")\n</code></pre></p>"},{"location":"examples/parallel_simulation/#monte-carlo-simulation","title":"Monte Carlo Simulation","text":"<p>Uncertainty quantification with parameter distributions:</p> <pre><code>from pyadm1.simulation.parallel import MonteCarloConfig\n\nmc_config = MonteCarloConfig(\n    n_samples=100,\n    parameter_distributions={\n        \"k_dis\": (0.18, 0.03),      # mean=0.18, std=0.03\n        \"Y_su\": (0.10, 0.01),       # mean=0.10, std=0.01\n        \"k_hyd_ch\": (10.0, 1.5)     # mean=10.0, std=1.5\n    },\n    fixed_params={\"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]},\n    seed=42  # For reproducibility\n)\n\nresults = parallel.monte_carlo(\n    config=mc_config,\n    duration=30.0,\n    initial_state=adm1_state,\n    compute_metrics=True\n)\n\n# Summarize uncertainty\nsummary = parallel.summarize_results(results)\n\nprint(f\"Methane production [m\u00b3/d]:\")\nprint(f\"  Mean: {summary['metrics']['Q_ch4']['mean']:.1f}\")\nprint(f\"  Std:  {summary['metrics']['Q_ch4']['std']:.1f}\")\nprint(f\"  95% CI: [{summary['metrics']['Q_ch4']['q25']:.1f}, \"\n      f\"{summary['metrics']['Q_ch4']['q75']:.1f}]\")\n</code></pre> <p>Probability Distribution Selection: - Normal: Most kinetic parameters (symmetric uncertainty) - Log-normal: Always-positive parameters with multiplicative uncertainty - Uniform: When only bounds are known - Triangular: Expert judgment with most likely value</p>"},{"location":"examples/parallel_simulation/#expected-output","title":"Expected Output","text":""},{"location":"examples/parallel_simulation/#basic-scenario-comparison","title":"Basic Scenario Comparison","text":"<pre><code>================================================================================\nSCENARIO COMPARISON RESULTS\n================================================================================\n\nLow Feed:\n  Feed Rate: 18.0 m\u00b3/d\n  Biogas:    723.5 m\u00b3/d\n  Methane:   434.1 m\u00b3/d\n  CH4 %:     60.0%\n  pH:        7.28\n  VFA:       1.85 g/L\n  FOS/TAC:   0.228\n  HRT:       109.8 days\n  Exec Time: 2.34 seconds\n\nBase Feed:\n  Feed Rate: 25.0 m\u00b3/d\n  Biogas:    1005.2 m\u00b3/d\n  Methane:   603.1 m\u00b3/d\n  CH4 %:     60.0%\n  pH:        7.20\n  VFA:       2.45 g/L\n  FOS/TAC:   0.289\n  HRT:       79.1 days\n  Exec Time: 2.41 seconds\n\nHigh Feed:\n  Feed Rate: 32.0 m\u00b3/d\n  Biogas:    1265.8 m\u00b3/d\n  Methane:   759.5 m\u00b3/d\n  CH4 %:     60.0%\n  pH:        7.15\n  VFA:       3.12 g/L\n  FOS/TAC:   0.341\n  HRT:       61.8 days\n  Exec Time: 2.38 seconds\n</code></pre> <p>Interpretation: - Biogas production scales linearly with feed rate (expected for stable operation) - pH decreases with higher loading (more VFA production) - FOS/TAC increases but remains below critical threshold (0.4) - Execution time is similar across scenarios (same computational complexity)</p>"},{"location":"examples/parallel_simulation/#parameter-sweep-results","title":"Parameter Sweep Results","text":"<pre><code>================================================================================\n4. Running parameter sweep (Disintegration Rate k_dis)\n================================================================================\n\n   Testing 6 different k_dis values...\n\n   Parameter Sweep Results:\n   ------------------------------------------------------------\n      k_dis |      Q_gas |      Q_ch4 |     pH |      VFA\n   ------------------------------------------------------------\n       0.10 |      865.3 |      519.2 |   7.35 |     1.52\n       0.14 |      925.8 |      555.5 |   7.28 |     1.85\n       0.18 |      982.4 |      589.4 |   7.22 |     2.18\n       0.22 |     1005.2 |      603.1 |   7.20 |     2.45\n       0.26 |     1015.6 |      609.4 |   7.18 |     2.68\n       0.30 |     1018.2 |      610.9 |   7.17 |     2.85\n\n   \u2713 Optimal k_dis = 0.30 (CH4 = 610.9 m\u00b3/d)\n</code></pre> <p>Observations: - Methane production increases with k_dis (faster disintegration) - Diminishing returns above k_dis = 0.26 (only 1.5 m\u00b3/d increase) - pH decreases slightly due to faster organic acid production - Trade-off: Higher k_dis \u2192 more gas but lower pH stability</p>"},{"location":"examples/parallel_simulation/#monte-carlo-statistics","title":"Monte Carlo Statistics","text":"<pre><code>================================================================================\n6. Running Monte Carlo uncertainty analysis\n================================================================================\n\n   Running 50 Monte Carlo samples...\n\n   Monte Carlo Summary Statistics:\n   ------------------------------------------------------------\n\n   Q_gas:\n      Mean:      1002.45\n      Std:         58.32\n      Min:        885.20\n      Max:       1125.80\n      Median:     998.60\n      Q25:        965.15\n      Q75:       1038.22\n\n   Q_ch4:\n      Mean:       601.47\n      Std:         35.00\n      Min:        531.12\n      Max:        675.48\n      Median:     599.16\n      Q25:        579.09\n      Q75:        622.93\n\n   pH:\n      Mean:          7.21\n      Std:           0.08\n      Min:           7.05\n      Max:           7.38\n      Median:        7.20\n      Q25:           7.15\n      Q75:           7.26\n\n   Success Rate: 100.0%\n</code></pre> <p>Uncertainty Analysis: - Coefficient of variation (CV):   - Biogas: 58.32 / 1002.45 = 5.8% (moderate uncertainty)   - Methane: 35.00 / 601.47 = 5.8% (same relative uncertainty)   - pH: 0.08 / 7.21 = 1.1% (very stable) - 95% Confidence Interval (\u2248 Q25 to Q75):   - Biogas: 965\u20131038 m\u00b3/d (\u00b13.7% from median)   - Methane: 579\u2013623 m\u00b3/d (\u00b13.7% from median) - Interpretation: Parameter uncertainty has moderate impact on gas production predictions</p>"},{"location":"examples/parallel_simulation/#performance-analysis","title":"Performance Analysis","text":""},{"location":"examples/parallel_simulation/#parallel-efficiency","title":"Parallel Efficiency","text":"<pre><code>================================================================================\nSIMULATION SUMMARY\n================================================================================\n\nTotal execution time: 125.3 seconds\nAverage time per simulation: 1.05 seconds\n\nParallel efficiency:\n  Workers used: 4\n  Theoretical sequential time: 475.8 seconds\n  Speedup: 3.80x\n  Parallel efficiency: 95.0%\n</code></pre> <p>Performance Metrics: - Speedup: 475.8 / 125.3 = 3.80\u00d7 - Efficiency: 3.80 / 4 = 95.0% - Overhead: 5% due to:   - Process creation/destruction   - Data serialization/deserialization   - Result aggregation</p> <p>Optimal Worker Count: <pre><code>import multiprocessing as mp\n\n# Rule of thumb: n_workers = CPU_count - 1\noptimal_workers = max(1, mp.cpu_count() - 1)\n\nparallel = ParallelSimulator(adm1, n_workers=optimal_workers)\n</code></pre></p> <p>Scalability: - Linear speedup: Up to CPU core count (ideal: 95%+ efficiency) - Diminishing returns: Beyond core count (hyperthreading limited) - Overhead dominates: Very short simulations (&lt;1 second)</p>"},{"location":"examples/parallel_simulation/#memory-considerations","title":"Memory Considerations","text":"<p>Each worker process creates a full copy of the ADM1 model:</p> <pre><code># Memory per worker \u2248 50-100 MB (depends on model complexity)\n# Total memory = n_workers \u00d7 memory_per_worker + overhead\n\n# For 100 scenarios on 4 cores:\n# Memory usage \u2248 4 \u00d7 75 MB \u2248 300 MB (manageable)\n\n# For very large parameter sweeps:\nif n_scenarios &gt; 1000:\n    # Use batching to limit memory\n    batch_size = 100\n    all_results = []\n\n    for i in range(0, len(scenarios), batch_size):\n        batch = scenarios[i:i+batch_size]\n        results = parallel.run_scenarios(batch, duration=30, ...)\n        all_results.extend(results)\n</code></pre>"},{"location":"examples/parallel_simulation/#advanced-usage","title":"Advanced Usage","text":""},{"location":"examples/parallel_simulation/#custom-result-processing","title":"Custom Result Processing","text":"<pre><code>def analyze_stability(results):\n    \"\"\"Classify scenarios by process stability.\"\"\"\n    stable = []\n    unstable = []\n\n    for r in results:\n        if not r.success:\n            continue\n\n        fos_tac = r.metrics.get('FOS_TAC', 0)\n        pH = r.metrics.get('pH', 0)\n\n        # Stability criteria\n        is_stable = (\n            0.2 &lt;= fos_tac &lt;= 0.4 and\n            6.8 &lt;= pH &lt;= 7.5\n        )\n\n        if is_stable:\n            stable.append(r)\n        else:\n            unstable.append(r)\n\n    return stable, unstable\n\nstable, unstable = analyze_stability(results)\nprint(f\"Stable scenarios: {len(stable)}/{len(results)}\")\n</code></pre>"},{"location":"examples/parallel_simulation/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<pre><code>def calculate_sensitivity(param_name, sweep_results):\n    \"\"\"Calculate parameter sensitivity coefficient.\"\"\"\n    params = [r.parameters[param_name] for r in sweep_results if r.success]\n    ch4 = [r.metrics['Q_ch4'] for r in sweep_results if r.success]\n\n    # Linear regression: \u0394CH4/\u0394param\n    from numpy.polynomial import Polynomial\n\n    p = Polynomial.fit(params, ch4, deg=1)\n    sensitivity = p.convert().coef[1]  # Slope\n\n    return sensitivity\n\n# Compare sensitivities\nk_dis_sens = calculate_sensitivity('k_dis', sweep_results_1)\nY_su_sens = calculate_sensitivity('Y_su', sweep_results_2)\n\nprint(f\"Sensitivity of CH4 production:\")\nprint(f\"  k_dis: {k_dis_sens:.1f} m\u00b3/d per unit\")\nprint(f\"  Y_su:  {Y_su_sens:.1f} m\u00b3/d per unit\")\n</code></pre>"},{"location":"examples/parallel_simulation/#response-surface-modeling","title":"Response Surface Modeling","text":"<p>For multi-parameter sweeps, fit response surfaces:</p> <pre><code>from sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF, ConstantKernel\n\n# Extract training data\nX = []  # Parameter combinations\ny = []  # Methane production\n\nfor r in multi_results:\n    if r.success:\n        X.append([r.parameters['k_dis'], r.parameters['Y_su']])\n        y.append(r.metrics['Q_ch4'])\n\nX = np.array(X)\ny = np.array(y)\n\n# Fit Gaussian Process\nkernel = ConstantKernel(1.0) * RBF(length_scale=1.0)\ngp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=10)\ngp.fit(X, y)\n\n# Predict at new points\nk_dis_new = np.linspace(0.10, 0.30, 50)\nY_su_new = np.linspace(0.08, 0.12, 50)\nK, Y = np.meshgrid(k_dis_new, Y_su_new)\n\nX_pred = np.c_[K.ravel(), Y.ravel()]\nch4_pred, ch4_std = gp.predict(X_pred, return_std=True)\n\n# Find optimum\nopt_idx = np.argmax(ch4_pred)\nopt_k_dis = X_pred[opt_idx, 0]\nopt_Y_su = X_pred[opt_idx, 1]\nopt_ch4 = ch4_pred[opt_idx]\n\nprint(f\"Predicted optimum:\")\nprint(f\"  k_dis = {opt_k_dis:.3f}\")\nprint(f\"  Y_su = {opt_Y_su:.3f}\")\nprint(f\"  CH4 = {opt_ch4:.1f} \u00b1 {ch4_std[opt_idx]:.1f} m\u00b3/d\")\n</code></pre>"},{"location":"examples/parallel_simulation/#best-practices","title":"Best Practices","text":""},{"location":"examples/parallel_simulation/#1-choose-appropriate-number-of-workers","title":"1. Choose Appropriate Number of Workers","text":"<pre><code>import multiprocessing as mp\n\n# Rule of thumb\nn_workers = max(1, mp.cpu_count() - 1)  # Leave one core for OS\n\n# For I/O-bound tasks (rare in biogas simulation)\nn_workers = 2 * mp.cpu_count()\n\n# For memory-limited systems\navailable_memory_gb = 16  # Your system RAM\nmemory_per_worker_gb = 0.1\nn_workers = min(n_workers, int(available_memory_gb / memory_per_worker_gb))\n</code></pre>"},{"location":"examples/parallel_simulation/#2-balance-simulation-duration-and-number-of-scenarios","title":"2. Balance Simulation Duration and Number of Scenarios","text":"<pre><code># Short simulations (&lt; 1 second): Overhead dominates\n# \u2192 Increase duration or use sequential execution\n\n# Medium simulations (1-10 seconds): Good parallelization\n# \u2192 Ideal for parameter sweeps\n\n# Long simulations (&gt; 60 seconds): Memory intensive\n# \u2192 Consider reducing n_workers or using batching\n</code></pre>"},{"location":"examples/parallel_simulation/#3-save-results-incrementally","title":"3. Save Results Incrementally","text":"<pre><code>import pickle\nfrom pathlib import Path\n\nresults_dir = Path(\"results/parallel_sweep\")\nresults_dir.mkdir(parents=True, exist_ok=True)\n\n# Run in batches\nbatch_size = 50\nfor batch_id, i in enumerate(range(0, len(scenarios), batch_size)):\n    batch = scenarios[i:i+batch_size]\n\n    results = parallel.run_scenarios(\n        batch, duration=30, initial_state=adm1_state\n    )\n\n    # Save batch results\n    with open(results_dir / f\"batch_{batch_id:03d}.pkl\", \"wb\") as f:\n        pickle.dump(results, f)\n\n    print(f\"Saved batch {batch_id}\")\n\n# Load all results later\nall_results = []\nfor batch_file in sorted(results_dir.glob(\"batch_*.pkl\")):\n    with open(batch_file, \"rb\") as f:\n        all_results.extend(pickle.load(f))\n</code></pre>"},{"location":"examples/parallel_simulation/#4-handle-failed-scenarios-gracefully","title":"4. Handle Failed Scenarios Gracefully","text":"<pre><code># Check for failures\nfailed = [r for r in results if not r.success]\n\nif failed:\n    print(f\"Warning: {len(failed)} scenarios failed\")\n\n    # Log failures\n    with open(\"failed_scenarios.log\", \"w\") as f:\n        for r in failed:\n            f.write(f\"\\nScenario {r.scenario_id}:\\n\")\n            f.write(f\"Parameters: {r.parameters}\\n\")\n            f.write(f\"Error: {r.error}\\n\")\n\n    # Retry with tighter tolerances\n    retry_scenarios = [r.parameters for r in failed]\n\n    # Create new simulator with stricter settings\n    from pyadm1.core.solver import create_solver\n\n    strict_solver = create_solver(method='BDF', rtol=1e-8, atol=1e-10)\n    retry_results = parallel.run_scenarios(retry_scenarios, ...)\n</code></pre>"},{"location":"examples/parallel_simulation/#5-validate-results","title":"5. Validate Results","text":"<pre><code>def validate_results(results):\n    \"\"\"Check for physically unrealistic results.\"\"\"\n    issues = []\n\n    for r in results:\n        if not r.success:\n            continue\n\n        # Check for unrealistic values\n        if r.metrics.get('Q_ch4', 0) &lt; 0:\n            issues.append(f\"Scenario {r.scenario_id}: Negative methane\")\n\n        if r.metrics.get('pH', 7) &lt; 5 or r.metrics.get('pH', 7) &gt; 9:\n            issues.append(f\"Scenario {r.scenario_id}: pH out of range\")\n\n        if r.metrics.get('CH4_content', 0) &gt; 1 or r.metrics.get('CH4_content', 0) &lt; 0:\n            issues.append(f\"Scenario {r.scenario_id}: Invalid CH4 fraction\")\n\n    return issues\n\nissues = validate_results(results)\nif issues:\n    print(\"Validation warnings:\")\n    for issue in issues:\n        print(f\"  - {issue}\")\n</code></pre>"},{"location":"examples/parallel_simulation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/parallel_simulation/#common-issues","title":"Common Issues","text":"<p>Issue: \"Pool workers hanging, no progress\" <pre><code># Solution: Reduce complexity or increase timeout\nparallel = ParallelSimulator(adm1, n_workers=2)  # Fewer workers\nresults = parallel.run_scenarios(scenarios, duration=10, ...)  # Shorter duration\n</code></pre></p> <p>Issue: \"MemoryError during parallel execution\" <pre><code># Solution: Use batching\nbatch_size = min(50, len(scenarios))\nall_results = []\n\nfor i in range(0, len(scenarios), batch_size):\n    batch = scenarios[i:i+batch_size]\n    results = parallel.run_scenarios(batch, ...)\n    all_results.extend(results)\n\n    # Force garbage collection\n    import gc\n    gc.collect()\n</code></pre></p> <p>Issue: \"Inconsistent results across runs\" <pre><code># Solution: Set random seeds for Monte Carlo\nmc_config = MonteCarloConfig(\n    n_samples=100,\n    parameter_distributions={...},\n    seed=42  # Fixed seed for reproducibility\n)\n</code></pre></p> <p>Issue: \"Low parallel efficiency (&lt; 70%)\" <pre><code># Possible causes:\n# 1. Simulations too short (overhead dominates)\n# 2. Too many workers for available cores\n# 3. I/O bottleneck (disk access)\n\n# Solutions:\n# 1. Increase simulation duration\nparallel = ParallelSimulator(adm1, n_workers=mp.cpu_count() - 1)\n\n# 2. Disable time series saving\nresults = parallel.run_scenarios(..., save_time_series=False)\n\n# 3. Batch processing instead of parallel\n</code></pre></p>"},{"location":"examples/parallel_simulation/#related-examples","title":"Related Examples","text":"<ul> <li><code>basic_digester.md</code>: Single digester simulation basics</li> <li><code>two_stage_plant.md</code>: Two-stage plant configuration</li> <li><code>calibration_workflow.md</code>: Parameter calibration using parallel optimization</li> </ul>"},{"location":"examples/parallel_simulation/#references","title":"References","text":"<ul> <li>Multiprocessing: Python documentation on <code>multiprocessing</code> module</li> <li>Parallel Computing: Pacheco, P. (2011). An Introduction to Parallel Programming</li> <li>Design of Experiments: Montgomery, D.C. (2017). Design and Analysis of Experiments</li> <li>Uncertainty Quantification: Sullivan, T.J. (2015). Introduction to Uncertainty Quantification</li> </ul>"},{"location":"examples/parallel_simulation/#summary","title":"Summary","text":"<p>The parallel simulation example demonstrates:</p> <ol> <li>Efficient Parameter Exploration: Test multiple scenarios 3-4\u00d7 faster using parallel execution</li> <li>Systematic Optimization: Parameter sweeps identify optimal operating conditions</li> <li>Uncertainty Quantification: Monte Carlo analysis quantifies prediction uncertainty</li> <li>Scalable Architecture: Handle 100s of scenarios with proper batching and error handling</li> <li>Statistical Analysis: Comprehensive result aggregation and comparative statistics</li> </ol> <p>Key Takeaway: Parallel simulation enables rapid exploration of the design and operating space, making it feasible to perform comprehensive sensitivity analysis, optimization, and uncertainty quantification that would be impractical with sequential execution.</p>"},{"location":"examples/two_stage_plant/","title":"Two-Stage Biogas Plant Example","text":"<p>The examples/two_stage_plant.py example demonstrates a complete two-stage biogas plant with mechanical components, energy integration, and comprehensive process monitoring.</p>"},{"location":"examples/two_stage_plant/#plant-schematic","title":"Plant Schematic","text":""},{"location":"examples/two_stage_plant/#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    %% Substrate feed\n    Feed[Substrate Feed&lt;br/&gt;Corn silage: 15 m\u00b3/d&lt;br/&gt;Cattle manure: 10 m\u00b3/d]\n\n    %% Feed pump\n    Feed --&gt;|25 m\u00b3/d| FeedPump[Feed Pump&lt;br/&gt;Progressive Cavity&lt;br/&gt;30 m\u00b3/h capacity]\n\n    %% First stage - Hydrolysis\n    FeedPump --&gt; Dig1[Digester 1 - Hydrolysis&lt;br/&gt;V_liq: 1977 m\u00b3, V_gas: 304 m\u00b3&lt;br/&gt;T: 45\u00b0C thermophilic&lt;br/&gt;Enhanced hydrolysis]\n\n    %% Mixer 1\n    Mixer1[Mixer 1&lt;br/&gt;Propeller, 15 kW&lt;br/&gt;High intensity&lt;br/&gt;25% duty cycle] -.-&gt;|Mixing| Dig1\n\n    %% Gas storage 1\n    Dig1 --&gt;|Biogas ~850 m\u00b3/d| Storage1[Gas Storage 1&lt;br/&gt;Membrane&lt;br/&gt;304 m\u00b3 capacity]\n\n    %% Heating 1\n    Heating1[Heating System 1&lt;br/&gt;Target: 45\u00b0C&lt;br/&gt;Heat loss: 0.5 kW/K] -.-&gt;|Heat| Dig1\n\n    %% Transfer pump\n    Dig1 --&gt;|Effluent 25 m\u00b3/d| TransPump[Transfer Pump&lt;br/&gt;Progressive Cavity&lt;br/&gt;25 m\u00b3/h capacity]\n\n    %% Second stage - Methanogenesis\n    TransPump --&gt; Dig2[Digester 2 - Methanogenesis&lt;br/&gt;V_liq: 1000 m\u00b3, V_gas: 150 m\u00b3&lt;br/&gt;T: 35\u00b0C mesophilic&lt;br/&gt;Stable CH\u2084 production]\n\n    %% Mixer 2\n    Mixer2[Mixer 2&lt;br/&gt;Propeller, 10 kW&lt;br/&gt;Medium intensity&lt;br/&gt;25% duty cycle] -.-&gt;|Mixing| Dig2\n\n    %% Gas storage 2\n    Dig2 --&gt;|Biogas ~400 m\u00b3/d| Storage2[Gas Storage 2&lt;br/&gt;Membrane&lt;br/&gt;150 m\u00b3 capacity]\n\n    %% Heating 2\n    Heating2[Heating System 2&lt;br/&gt;Target: 35\u00b0C&lt;br/&gt;Heat loss: 0.3 kW/K] -.-&gt;|Heat| Dig2\n\n    %% Combined gas flow to CHP\n    Storage1 --&gt;|Gas supply| CHP[CHP Unit&lt;br/&gt;500 kWe nominal&lt;br/&gt;\u03b7e: 40%, \u03b7th: 45%&lt;br/&gt;Total: ~1250 m\u00b3/d]\n    Storage2 --&gt;|Gas supply| CHP\n\n    %% CHP outputs\n    CHP --&gt;|Electrical| Power[Power Output&lt;br/&gt;~480 kWe]\n    CHP --&gt;|Thermal ~540 kW| HeatDist[Heat Distribution]\n    CHP --&gt;|Excess gas| Flare[Flare&lt;br/&gt;Safety combustion&lt;br/&gt;98% destruction]\n\n    %% Heat distribution\n    HeatDist --&gt;|Heat supply| Heating1\n    HeatDist --&gt;|Heat supply| Heating2\n\n    %% Final outputs\n    Dig2 --&gt;|Digestate&lt;br/&gt;25 m\u00b3/d| Effluent[Digestate Output]\n\n    %% Styling\n    classDef processBox fill:#e1f5fe,stroke:#01579b,stroke-width:3px\n    classDef storageBox fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    classDef mechanicalBox fill:#f3e5f5,stroke:#4a148c,stroke-width:2px\n    classDef energyBox fill:#e8f5e9,stroke:#1b5e20,stroke-width:3px\n    classDef inputBox fill:#f1f8e9,stroke:#33691e,stroke-width:2px\n    classDef outputBox fill:#fce4ec,stroke:#880e4f,stroke-width:2px\n\n    class Dig1,Dig2 processBox\n    class Storage1,Storage2 storageBox\n    class FeedPump,TransPump,Mixer1,Mixer2 mechanicalBox\n    class CHP,Heating1,Heating2,HeatDist,Flare energyBox\n    class Feed inputBox\n    class Power,Effluent outputBox</code></pre>"},{"location":"examples/two_stage_plant/#overview","title":"Overview","text":"<p>The two-stage plant demonstrates: - Temperature-Phased Anaerobic Digestion (TPAD): Thermophilic hydrolysis (45\u00b0C) followed by mesophilic methanogenesis (35\u00b0C) - Mechanical Components: Pumps for material transport and mixers for process enhancement - Energy Integration: CHP for power generation and waste heat recovery - Process Control: Multiple heating systems for precise temperature management - Gas Management: Dedicated storage for each digester with automatic overflow protection and centralized flare</p>"},{"location":"examples/two_stage_plant/#plant-configuration","title":"Plant Configuration","text":""},{"location":"examples/two_stage_plant/#biological-components","title":"Biological Components","text":"Component Volume Temperature Function HRT Digester 1 1977 m\u00b3 liq + 304 m\u00b3 gas 45\u00b0C (thermophilic) Hydrolysis of complex organics 79 days Digester 2 1000 m\u00b3 liq + 150 m\u00b3 gas 35\u00b0C (mesophilic) Methanogenesis (CH\u2084 production) 40 days Total 2977 m\u00b3 - - 119 days <p>Total Organic Loading Rate (OLR): 25 m\u00b3/d \u00f7 2977 m\u00b3 \u2248 0.0084 d\u207b\u00b9 or 8.4 kg COD/(m\u00b3\u00b7d)</p>"},{"location":"examples/two_stage_plant/#mechanical-components","title":"Mechanical Components","text":"Component Type Capacity Power Function Feed Pump Progressive cavity 30 m\u00b3/h ~5 kW Substrate feeding into Digester 1 Transfer Pump Progressive cavity 25 m\u00b3/h ~8 kW Effluent transfer: D1 \u2192 D2 Mixer 1 Propeller 15 kW 15 kW High-intensity mixing for hydrolysis Mixer 2 Propeller 10 kW 10 kW Medium mixing for methanogenesis <p>Total Parasitic Load: ~20 kW (mixers run 25% duty cycle)</p>"},{"location":"examples/two_stage_plant/#energy-components","title":"Energy Components","text":"Component Specification Efficiency Output CHP Unit 500 kW$_e$ nominal \u03b7$e$ = 40%, \u03b7$$ = 45% 500 kW$e$ + 562 kW$$ Heating 1 Digester 1 heating - Maintains 45\u00b0C Heating 2 Digester 2 heating - Maintains 35\u00b0C Flare Safety combustion 98% destruction Excess gas disposal"},{"location":"examples/two_stage_plant/#gas-management-system","title":"Gas Management System","text":"Component Type Capacity Function Storage 1 Membrane 304 m\u00b3 Buffer for Digester 1 gas Storage 2 Membrane 150 m\u00b3 Buffer for Digester 2 gas CHP Flare Combustion Variable Safety disposal of excess gas <p>Gas Flow Architecture: 1. Each digester produces gas \u2192 Dedicated storage 2. Both storages supply gas \u2192 Single CHP unit 3. CHP excess/overflow \u2192 Automatic flare combustion</p>"},{"location":"examples/two_stage_plant/#code-walkthrough","title":"Code Walkthrough","text":""},{"location":"examples/two_stage_plant/#1-enhanced-imports","title":"1. Enhanced Imports","text":"<pre><code>from pyadm1.components.mechanical.mixer import Mixer\nfrom pyadm1.components.mechanical.pump import Pump\n</code></pre> <p>These import the mechanical components that weren't used in the basic example.</p>"},{"location":"examples/two_stage_plant/#2-two-stage-digester-configuration","title":"2. Two-Stage Digester Configuration","text":"<pre><code># Digester 1: Thermophilic hydrolysis\nconfigurator.add_digester(\n    digester_id=\"digester_1\",\n    V_liq=1977.0,\n    V_gas=304.0,\n    T_ad=318.15,  # 45\u00b0C for enhanced hydrolysis\n    Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0],\n)\n\n# Digester 2: Mesophilic methanogenesis\nconfigurator.add_digester(\n    digester_id=\"digester_2\",\n    V_liq=1000.0,\n    V_gas=150.0,\n    T_ad=308.15,  # 35\u00b0C optimal for methanogens\n    Q_substrates=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],  # Only receives effluent\n)\n</code></pre> <p>Design Rationale: - Stage 1 (Thermophilic): Higher temperature enhances hydrolysis of complex substrates (cellulose, hemicellulose, proteins) - Stage 2 (Mesophilic): Lower temperature is more stable and efficient for methanogenesis - Effluent-only feed to Stage 2: Prevents overloading, receives pre-hydrolyzed material</p> <p>Automatic Gas Storage Creation: - <code>add_digester()</code> automatically creates:   - <code>digester_1_storage</code> (304 m\u00b3 membrane storage)   - <code>digester_2_storage</code> (150 m\u00b3 membrane storage) - Storages are automatically connected to their digesters</p>"},{"location":"examples/two_stage_plant/#3-adding-mechanical-components","title":"3. Adding Mechanical Components","text":""},{"location":"examples/two_stage_plant/#feed-pump","title":"Feed Pump","text":"<pre><code>feed_pump = Pump(\n    component_id=\"feed_pump\",\n    pump_type=\"progressive_cavity\",  # Handles thick slurries\n    Q_nom=30.0,  # m\u00b3/h nominal\n    pressure_head=5.0,  # Low pressure (gravity assist)\n)\n</code></pre> <p>Progressive Cavity Pumps are ideal for biogas substrates because: - Handle high solids content (&gt;12% TS) - Low shear (preserves fiber structure) - Self-priming capability - Wide viscosity range</p>"},{"location":"examples/two_stage_plant/#transfer-pump","title":"Transfer Pump","text":"<pre><code>transfer_pump = Pump(\n    component_id=\"transfer_pump\",\n    pump_type=\"progressive_cavity\",\n    Q_nom=25.0,  # m\u00b3/h\n    pressure_head=8.0,  # Higher head for inter-digester transfer\n)\n</code></pre> <p>Higher pressure head needed for: - Overcoming pipe friction losses - Elevation differences - Injection into pressurized digester</p>"},{"location":"examples/two_stage_plant/#mixers","title":"Mixers","text":"<pre><code>mixer_1 = Mixer(\n    component_id=\"mixer_1\",\n    mixer_type=\"propeller\",\n    tank_volume=1977.0,\n    mixing_intensity=\"high\",  # Aggressive for hydrolysis\n    power_installed=15.0,\n    intermittent=True,\n    on_time_fraction=0.25,  # 6 hours on, 18 hours off\n)\n</code></pre> <p>Mixing Strategy: - Intermittent operation: Reduces energy consumption by 75% - High intensity in hydrolysis: Breaks up floating layers, enhances substrate contact - Medium intensity in methanogenesis: Gentle mixing prevents inhibition of sensitive methanogens</p> <p>Specific Power Input: - Digester 1: 15 kW \u00d7 0.25 \u00f7 1977 m\u00b3 = 1.9 W/m\u00b3 (high) - Digester 2: 10 kW \u00d7 0.25 \u00f7 1000 m\u00b3 = 2.5 W/m\u00b3 (medium)</p>"},{"location":"examples/two_stage_plant/#4-energy-integration-with-automatic-flare","title":"4. Energy Integration with Automatic Flare","text":"<pre><code># Add CHP (automatically creates flare)\nconfigurator.add_chp(\n    chp_id=\"chp_1\",\n    P_el_nom=500.0,\n    eta_el=0.40,\n    eta_th=0.45,\n    name=\"Main CHP Unit\",\n)\n\n# Automatic connections handle gas routing\nconfigurator.auto_connect_digester_to_chp(\"digester_1\", \"chp_1\")\nconfigurator.auto_connect_digester_to_chp(\"digester_2\", \"chp_1\")\n\n# Heat recovery for both digesters\nconfigurator.auto_connect_chp_to_heating(\"chp_1\", \"heating_1\")\nconfigurator.auto_connect_chp_to_heating(\"chp_1\", \"heating_2\")\n</code></pre> <p>Connection Chain: <pre><code>Digester 1 \u2192 Storage 1 \u2198\n                        \u2192 CHP \u2192 Flare (automatic)\nDigester 2 \u2192 Storage 2 \u2197      \u2193\n                          Heat \u2192 Heating 1 &amp; 2\n</code></pre></p> <p>Automatic Flare Creation: - <code>add_chp()</code> automatically creates a flare component - Flare ID: <code>{chp_id}_flare</code> (e.g., \"chp_1_flare\") - Function: Safety combustion of excess gas (98% CH\u2084 destruction) - Automatic connection: CHP \u2192 Flare</p>"},{"location":"examples/two_stage_plant/#5-three-pass-gas-flow-simulation","title":"5. Three-Pass Gas Flow Simulation","text":"<p>The simulation executes in three passes for realistic gas management:</p> <p>Pass 1 - Gas Production: <pre><code># Digesters produce gas \u2192 Storage tanks\nDigester 1: Q_gas = 850 m\u00b3/d \u2192 Storage 1\nDigester 2: Q_gas = 400 m\u00b3/d \u2192 Storage 2\n</code></pre></p> <p>Pass 2 - Storage Update: <pre><code># Storages receive gas, update pressure and volume\nStorage 1: stored_volume += 850 * dt\nStorage 2: stored_volume += 400 * dt\n# If full: vent excess to atmosphere\n</code></pre></p> <p>Pass 3 - Gas Consumption: <pre><code># CHP requests gas from storages\nCHP demand: 1150 m\u00b3/d biogas\nStorage 1 supplies: ~675 m\u00b3/d\nStorage 2 supplies: ~475 m\u00b3/d\n# CHP operates with actual supply\n# Excess to flare: (supply - consumption)\n</code></pre></p> <p>This ensures: - Realistic pressure management in storages - CHP operates with available gas, not idealized supply - Automatic venting prevents overpressure - Flare handles all excess gas safely</p>"},{"location":"examples/two_stage_plant/#expected-output","title":"Expected Output","text":""},{"location":"examples/two_stage_plant/#plant-summary","title":"Plant Summary","text":"<pre><code>=== Two-Stage Plant with Mechanical Components ===\nSimulation time: 0.00 days\n\nComponents (12):\n  - Hydrolysis Digester (digester)\n  - Hydrolysis Digester Gas Storage (storage)\n  - Methanogenesis Digester (digester)\n  - Methanogenesis Digester Gas Storage (storage)\n  - Substrate Feed Pump (pump)\n  - Digester Transfer Pump (pump)\n  - Hydrolysis Mixer (mixer)\n  - Methanogenesis Mixer (mixer)\n  - Main CHP Unit (chp)\n  - Main CHP Unit Flare (flare)\n  - Hydrolysis Heating (heating)\n  - Methanogenesis Heating (heating)\n\nConnections (10):\n  - Hydrolysis Digester -&gt; Methanogenesis Digester (liquid)\n  - Hydrolysis Digester Gas Storage -&gt; Main CHP Unit (gas)\n  - Methanogenesis Digester Gas Storage -&gt; Main CHP Unit (gas)\n  - Main CHP Unit -&gt; Main CHP Unit Flare (gas)\n  - Main CHP Unit -&gt; Hydrolysis Heating (heat)\n  - Main CHP Unit -&gt; Methanogenesis Heating (heat)\n</code></pre>"},{"location":"examples/two_stage_plant/#final-results-day-10","title":"Final Results (Day 10)","text":"<pre><code>RESULTS ANALYSIS\n======================================================================\n\nFinal State (Day 10.0):\n----------------------------------------------------------------------\n\nHydrolysis Digester:\n  Biogas production:        850.3 m\u00b3/d\n  Methane production:       493.2 m\u00b3/d\n  pH:                         7.15\n  VFA:                        3.82 g/L\n  Temperature:               45.0 \u00b0C\n  Gas Storage:\n    - Stored volume:         152.1 m\u00b3 (50%)\n    - Pressure:               1.00 bar\n    - Vented:                  0.0 m\u00b3\n\nMethanogenesis Digester:\n  Biogas production:        402.8 m\u00b3/d\n  Methane production:       258.7 m\u00b3/d\n  pH:                         7.32\n  VFA:                        1.95 g/L\n  Temperature:               35.0 \u00b0C\n  Gas Storage:\n    - Stored volume:          75.0 m\u00b3 (50%)\n    - Pressure:               1.00 bar\n    - Vented:                  0.0 m\u00b3\n\nTotal Plant Production:\n  Total biogas:            1253.1 m\u00b3/d\n  Total methane:            751.9 m\u00b3/d\n  Methane content:           60.0 %\n\nCHP Performance:\n  Electrical output:        480.5 kW\n  Thermal output:           540.6 kW\n  Gas consumption:         1150.0 m\u00b3/d\n  Gas from Storage 1:       675.2 m\u00b3/d\n  Gas from Storage 2:       474.8 m\u00b3/d\n  Excess to flare:          103.1 m\u00b3/d\n  Operating hours:          240.0 h\n\nFlare Performance:\n  Gas received:             103.1 m\u00b3/d\n  CH\u2084 destroyed:             60.6 m\u00b3/d (98% efficiency)\n  Cumulative vented:       1031.0 m\u00b3\n\nHydrolysis Mixer:\n  Power consumption:          3.75 kW\n  Mixing quality:             0.92\n  Reynolds number:         12500\n\nMethanogenesis Mixer:\n  Power consumption:          2.50 kW\n  Mixing quality:             0.88\n  Reynolds number:          8300\n</code></pre>"},{"location":"examples/two_stage_plant/#energy-balance","title":"Energy Balance","text":"<pre><code>ENERGY BALANCE\n======================================================================\n\nEnergy Production:\n  Electrical (gross):       480.5 kW\n  Thermal:                  540.6 kW\n\nParasitic Load:\n  Mixer 1:                    3.75 kW\n  Mixer 2:                    2.50 kW\n  Pumps (estimated):          2.00 kW\n  Total parasitic:            8.25 kW\n\nNet Electrical Output:      472.3 kW\n\nHeat Utilization:\n  Heating demand:           125.4 kW\n  CHP thermal supply:       540.6 kW\n  Heat coverage:            431.0 %\n\nGas Management:\n  Total production:        1253.1 m\u00b3/d\n  CHP consumption:         1150.0 m\u00b3/d\n  To flare:                 103.1 m\u00b3/d (8.2%)\n</code></pre> <p>Analysis: - Net efficiency: (472 kW + 125 kW) \u00f7 (751.9 m\u00b3/d \u00d7 10 kWh/m\u00b3 \u00f7 24 h) = 190% (excellent heat recovery) - Parasitic ratio: 8.25 \u00f7 480.5 = 1.7% (very low) - Excess heat: 540.6 - 125.4 = 415 kW available for external use - Flare usage: 8.2% of production vented (typical when CHP at part load)</p>"},{"location":"examples/two_stage_plant/#process-stability","title":"Process Stability","text":"<pre><code>PROCESS STABILITY ASSESSMENT\n======================================================================\n\nDigester 1 (Hydrolysis):\n  pH stability:         CHECK (7.15 - slightly low)\n  VFA level:            HIGH (3.82 g/L)\n  FOS/TAC ratio:        0.418 (Monitor)\n  Storage status:       NORMAL (50% full)\n\nDigester 2 (Methanogenesis):\n  pH stability:         GOOD (7.32)\n  VFA level:            GOOD (1.95 g/L)\n  FOS/TAC ratio:        0.245 (Stable)\n  Storage status:       NORMAL (50% full)\n</code></pre> <p>Interpretation: - Digester 1: Higher VFA is expected in thermophilic hydrolysis stage - acids are consumed in stage 2 - Digester 2: Excellent stability indicators - methanogens effectively consume VFAs - pH gradient: 7.15 \u2192 7.32 shows proper two-stage function - Gas storages: Both at healthy 50% fill level with stable pressure</p>"},{"location":"examples/two_stage_plant/#advantages-of-two-stage-design","title":"Advantages of Two-Stage Design","text":""},{"location":"examples/two_stage_plant/#1-process-optimization","title":"1. Process Optimization","text":"Aspect Single-Stage Two-Stage Hydrolysis Limited by mesophilic temp Enhanced at 45\u00b0C Methanogenesis Must tolerate VFA spikes Stable, pre-buffered feed OLR capacity 3-4 kg COD/(m\u00b3\u00b7d) 5-8 kg COD/(m\u00b3\u00b7d) Process stability Moderate High"},{"location":"examples/two_stage_plant/#2-substrate-flexibility","title":"2. Substrate Flexibility","text":"<p>The two-stage system handles difficult substrates better: - High-fiber materials: Enhanced hydrolysis in Stage 1 - High-protein substrates: Ammonia buffering across stages - Variable feed composition: Stage 2 provides buffer capacity</p>"},{"location":"examples/two_stage_plant/#3-operational-benefits","title":"3. Operational Benefits","text":"<ul> <li>Reduced foaming: Separate hydrolysis phase</li> <li>Better pathogen reduction: Thermophilic stage (45\u00b0C) kills pathogens</li> <li>Easier process control: Monitor and control each stage independently</li> <li>Recovery from upsets: Stage 2 can buffer Stage 1 disturbances</li> </ul>"},{"location":"examples/two_stage_plant/#performance-comparison","title":"Performance Comparison","text":""},{"location":"examples/two_stage_plant/#single-stage-vs-two-stage","title":"Single-Stage vs Two-Stage","text":"Metric Single-Stage (2000 m\u00b3 @ 35\u00b0C) Two-Stage (1977+1000 m\u00b3) Improvement Biogas yield 1150 m\u00b3/d 1253 m\u00b3/d +9% CH\u2084 content 58% 60% +3.4% Specific yield 46 m\u00b3/m\u00b3 feed 50 m\u00b3/m\u00b3 feed +8.7% Process stability Moderate (FOS/TAC: 0.35) High (FOS/TAC: 0.25) Better OLR capacity 3.5 kg COD/(m\u00b3\u00b7d) 8.4 kg COD/(m\u00b3\u00b7d) +140% <p>Cost-Benefit: - Additional investment: ~15-20% (second digester, pumps) - Energy gain: ~9% more biogas - Stability: Significantly reduced risk of process failure - ROI: Typically 3-5 years for difficult substrates</p>"},{"location":"examples/two_stage_plant/#mechanical-component-performance","title":"Mechanical Component Performance","text":""},{"location":"examples/two_stage_plant/#pump-operation","title":"Pump Operation","text":"<p>Feed Pump: - Operating point: 25 m\u00b3/d \u00f7 24 = 1.04 m\u00b3/h (3.5% of nominal capacity) - Efficiency at low flow: Progressive cavity pumps maintain ~60% efficiency even at 3% capacity - Annual energy: 5 kW \u00d7 8760 h = 43,800 kWh</p> <p>Transfer Pump: - Operating point: 25 m\u00b3/d \u00f7 24 = 1.04 m\u00b3/h - Actual power: 8 kW \u00d7 (1.04/25) \u00d7 1.2 (low efficiency penalty) \u2248 0.4 kW - Annual energy: 0.4 kW \u00d7 8760 h = 3,504 kWh</p>"},{"location":"examples/two_stage_plant/#mixer-performance","title":"Mixer Performance","text":"<p>Hydrolysis Mixer: - Mixing time: ~15 minutes (from Reynolds number and geometry) - Tip speed: ~4.5 m/s (turbulent regime) - Shear rate: ~50 s\u207b\u00b9 (high intensity) - Power number: 0.32 (typical for propeller at Re &gt; 10,000)</p> <p>Methanogenesis Mixer: - Mixing time: ~20 minutes - Tip speed: ~3.8 m/s - Shear rate: ~35 s\u207b\u00b9 (medium intensity) - Prevents stratification without damaging sensitive methanogens</p>"},{"location":"examples/two_stage_plant/#gas-storage-and-flare-management","title":"Gas Storage and Flare Management","text":""},{"location":"examples/two_stage_plant/#storage-dynamics","title":"Storage Dynamics","text":"<p>Storage 1 (Hydrolysis): - Receives ~850 m\u00b3/d (higher production due to enhanced hydrolysis) - Supplies ~675 m\u00b3/d to CHP (proportional to total demand) - Net accumulation: +175 m\u00b3/d - Reaches 50% capacity in ~0.9 days</p> <p>Storage 2 (Methanogenesis): - Receives ~400 m\u00b3/d (lower but more stable) - Supplies ~475 m\u00b3/d to CHP - Net draw: -75 m\u00b3/d (supplements Storage 1) - Provides buffer for production variations</p>"},{"location":"examples/two_stage_plant/#flare-operation","title":"Flare Operation","text":"<p>When does the flare activate?: 1. Storage overflow: When either storage reaches 100% capacity 2. CHP part-load: When CHP operates below full capacity 3. Maintenance: When CHP is offline but digesters continue 4. Start-up/shutdown: During transient operations</p> <p>Flare performance: - Destruction efficiency: 98% CH\u2084 conversion to CO\u2082 - Temperature: ~1000\u00b0C combustion temperature - Emissions: 2% uncombusted CH\u2084 + CO\u2082 from combustion - Safety: Automatic ignition, flame detection</p>"},{"location":"examples/two_stage_plant/#process-control-strategies","title":"Process Control Strategies","text":""},{"location":"examples/two_stage_plant/#temperature-control","title":"Temperature Control","text":"<pre><code># Heating 1 maintains 45\u00b0C for hydrolysis\nheating_1.target_temperature = 318.15  # K\nheating_1.heat_loss_coefficient = 0.5  # Higher due to \u0394T\n\n# Heating 2 maintains 35\u00b0C for methanogenesis\nheating_2.target_temperature = 308.15  # K\nheating_2.heat_loss_coefficient = 0.3  # Lower \u0394T\n</code></pre> <p>Heat Demand Calculation: - Digester 1: Q = 0.5 kW/K \u00d7 (45 - 15)\u00b0C = 15 kW base loss + 80 kW process heating = 95 kW - Digester 2: Q = 0.3 kW/K \u00d7 (35 - 15)\u00b0C = 6 kW base loss + 24 kW process = 30 kW - Total: 125 kW (well covered by 541 kW CHP thermal output)</p>"},{"location":"examples/two_stage_plant/#mixing-control","title":"Mixing Control","text":"<p>Strategy: Intermittent mixing with adaptive timing <pre><code># High mixing when feeding (4\u00d7 daily)\nif feeding_event:\n    mixer.on_time_fraction = 0.5  # 50% duty cycle\nelse:\n    mixer.on_time_fraction = 0.15  # 15% baseline\n</code></pre></p>"},{"location":"examples/two_stage_plant/#feed-control","title":"Feed Control","text":"<p>Model Predictive Control (MPC) approach: 1. Measure current VFA and pH 2. Predict 48h response with different feed rates 3. Select feed rate optimizing CH\u2084 while maintaining pH &gt; 7.0</p>"},{"location":"examples/two_stage_plant/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"examples/two_stage_plant/#issue-1-high-vfa-in-digester-1","title":"Issue 1: High VFA in Digester 1","text":"<p>Symptoms: - VFA &gt; 5 g/L - pH &lt; 7.0 - Reduced gas production</p> <p>Solutions: <pre><code># Reduce organic loading\nQ_substrates = [12, 8, 0, 0, 0, 0, 0, 0, 0, 0]  # Reduce from [15, 10, ...]\n\n# Increase Stage 1 temperature (careful - max 55\u00b0C)\nT_ad_1 = 323.15  # 50\u00b0C\n\n# Increase mixing to prevent accumulation\nmixer_1.on_time_fraction = 0.35\n</code></pre></p>"},{"location":"examples/two_stage_plant/#issue-2-low-methane-content","title":"Issue 2: Low Methane Content","text":"<p>Symptoms: - CH\u2084 &lt; 55% - CO\u2082 elevated - Low specific gas production</p> <p>Solutions: <pre><code># Increase HRT (reduce feed)\nQ_substrates = [12, 8, 0, 0, 0, 0, 0, 0, 0, 0]\n\n# Optimize Stage 2 temperature\nT_ad_2 = 311.15  # 38\u00b0C (optimal for many methanogens)\n\n# Check for air leaks (O\u2082 inhibits methanogens)\n</code></pre></p>"},{"location":"examples/two_stage_plant/#issue-3-foaming-in-digester-1","title":"Issue 3: Foaming in Digester 1","text":"<p>Symptoms: - Gas storage shows pressure fluctuations - Effluent contains excessive gas bubbles</p> <p>Solutions: <pre><code># Reduce mixing intensity\nmixer_1.mixing_intensity = \"medium\"\n\n# Add antifoaming agent (substrate index 8)\nQ_substrates = [15, 10, 0, 0, 0, 0, 0, 0, 0.05, 0]  # 50 L/d antifoam\n\n# Increase transfer rate to Stage 2\n# (implement timer-based periodic drawdown)\n</code></pre></p>"},{"location":"examples/two_stage_plant/#issue-4-excessive-flare-usage","title":"Issue 4: Excessive Flare Usage","text":"<p>Symptoms: - Flare operates continuously - &gt;20% of production to flare - High storage pressure</p> <p>Causes: - CHP undersized for gas production - CHP in part-load operation - Excess substrate feed</p> <p>Solutions: <pre><code># Option 1: Reduce substrate feed\nQ_substrates = [12, 8, 0, 0, 0, 0, 0, 0, 0, 0]\n\n# Option 2: Increase CHP capacity\nconfigurator.add_chp(\"chp1\", P_el_nom=600, ...)  # Increase from 500\n\n# Option 3: Add second CHP unit\nconfigurator.add_chp(\"chp2\", P_el_nom=200, ...)\nconfigurator.auto_connect_digester_to_chp(\"digester_1\", \"chp2\")\n\n# Option 4: Increase gas storage capacity\n# (modify V_gas when adding digesters)\n</code></pre></p>"},{"location":"examples/two_stage_plant/#advanced-applications","title":"Advanced Applications","text":""},{"location":"examples/two_stage_plant/#1-parameter-sweep-for-optimization","title":"1. Parameter Sweep for Optimization","text":"<pre><code>from pyadm1.simulation import ParallelSimulator\n\n# Test different Stage 1 temperatures\nparallel = ParallelSimulator(adm1, n_workers=4)\nscenarios = [\n    {\"T_ad_1\": 313.15, \"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]},  # 40\u00b0C\n    {\"T_ad_1\": 318.15, \"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]},  # 45\u00b0C\n    {\"T_ad_1\": 323.15, \"Q\": [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]},  # 50\u00b0C\n]\nresults = parallel.run_scenarios(scenarios, duration=30)\n</code></pre>"},{"location":"examples/two_stage_plant/#2-online-calibration","title":"2. Online Calibration","text":"<pre><code>from pyadm1.calibration import Calibrator\n\n# Calibrate Stage 1 hydrolysis parameters\ncalibrator = Calibrator(plant.components[\"digester_1\"])\nparams = calibrator.calibrate_initial(\n    measurements=measurement_data,\n    parameters=[\"k_hyd_ch\", \"k_hyd_pr\", \"k_hyd_li\"],\n)\n</code></pre>"},{"location":"examples/two_stage_plant/#3-model-predictive-control","title":"3. Model Predictive Control","text":"<pre><code># Predict optimal feed for next 48 hours\nQ_best, Q_ch4_pred = simulator.determine_best_feed_by_n_sims(\n    state_zero=current_state,\n    Q=current_feed,\n    Qch4sp=800,  # Setpoint: 800 m\u00b3/d CH4\n    feeding_freq=48,\n    n=20  # Test 20 scenarios\n)\n</code></pre>"},{"location":"examples/two_stage_plant/#references","title":"References","text":"<ul> <li>TPAD Design: Simeonov, I., Chorukova, E., &amp; Kabaivanova, L. (2025). Two-stage anaerobic digestion for green energy production: A review. Processes, 13(2), 294.</li> <li>Process Control: Gaida (2014). Dynamic real-time substrate feed optimization of anaerobic co-digestion plants. PhD thesis, Leiden University.</li> </ul>"},{"location":"examples/two_stage_plant/#related-examples","title":"Related Examples","text":"<ul> <li><code>basic_digester.md</code>: Simple single-stage system</li> <li><code>calibration_workflow.md</code>(calibration_workflow.md): Parameter estimation from measurement data</li> <li><code>substrate_optimization.py</code>: Optimal feed strategy</li> <li><code>parallel_two_stage_simulation.py</code>: Parallel simulations</li> </ul>"},{"location":"user_guide/installation/","title":"Installation Guide","text":"<p>This guide covers the installation of PyADM1ODE on different operating systems.</p>"},{"location":"user_guide/installation/#system-requirements","title":"System Requirements","text":""},{"location":"user_guide/installation/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Python: 3.8 or higher (3.10+ recommended, needed by fastmcp package, used in the optional package PyADM1ODE_mcp)</li> <li>Operating System: Windows, Linux, or macOS</li> <li>Memory: 2 GB RAM minimum (4 GB recommended)</li> <li>Disk Space: 10 MB for installation</li> </ul>"},{"location":"user_guide/installation/#runtime-requirements","title":"Runtime Requirements","text":"<p>PyADM1ODE uses C# DLLs for substrate characterization, which requires: - Linux/macOS: Mono runtime - Windows: .NET Framework (usually pre-installed)</p>"},{"location":"user_guide/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"user_guide/installation/#method-1-install-from-pypi-recommended-but-not-yet-supported","title":"Method 1: Install from PyPI (Recommended, but not yet supported)","text":"<p>Once released, install via pip:</p> <pre><code>pip install pyadm1ode\n</code></pre>"},{"location":"user_guide/installation/#method-2-install-from-source","title":"Method 2: Install from Source","text":"<p>For development or the latest features:</p> <pre><code># Clone the repository\ngit clone https://github.com/dgaida/PyADM1ODE.git\ncd PyADM1ODE\n\n# Install in development mode\npip install -e .\n</code></pre>"},{"location":"user_guide/installation/#method-3-using-conda","title":"Method 3: Using Conda","text":"<p>Create a dedicated environment:</p> <pre><code># Create environment from environment.yml\nconda env create -f environment.yml\n\n# Activate the environment\nconda activate biogas\n\n# Install PyADM1\npip install -e .\n</code></pre>"},{"location":"user_guide/installation/#platform-specific-setup","title":"Platform-Specific Setup","text":""},{"location":"user_guide/installation/#windows-installation","title":"Windows Installation","text":"<ol> <li>Install Python (if not already installed):</li> <li>Download from python.org</li> <li> <p>Ensure \"Add Python to PATH\" is checked during installation</p> </li> <li> <p>Install PyADM1:    <pre><code>pip install pyadm1ode  # pip not yet supported\n# or from source:\ngit clone https://github.com/dgaida/PyADM1ODE.git\ncd PyADM1ODE\npip install -e .\n\n# Windows-specific dependencies\npip install -r requirements-windows.txt\n</code></pre></p> </li> <li> <p>.NET Framework should be pre-installed on Windows 10/11. If needed:</p> </li> <li> <p>Download from Microsoft .NET Framework</p> </li> <li> <p>Verify Installation:    <pre><code>python -c \"import pyadm1; print(pyadm1.__version__)\"\n</code></pre></p> </li> </ol>"},{"location":"user_guide/installation/#linux-installation-ubuntudebian","title":"Linux Installation (Ubuntu/Debian)","text":"<ol> <li> <p>Install Python and dependencies:    <pre><code>sudo apt-get update\nsudo apt-get install python3 python3-pip\n</code></pre></p> </li> <li> <p>Install Mono runtime (required for C# DLLs):    <pre><code>sudo apt-get install mono-complete\nmono --version\n</code></pre></p> </li> <li> <p>Install PyADM1ODE:    <pre><code>pip install pyadm1ode\n# or from source:\ngit clone https://github.com/dgaida/PyADM1ODE.git\ncd PyADM1ODE\npip install -e .\n</code></pre></p> </li> <li> <p>Verify Installation:    <pre><code>python3 -c \"import pyadm1; print(pyadm1.__version__)\"\n</code></pre></p> </li> </ol>"},{"location":"user_guide/installation/#macos-installation","title":"macOS Installation","text":"<ol> <li> <p>Install Homebrew (if not already installed):    <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></p> </li> <li> <p>Install Python:    <pre><code>brew install python@3.11\n</code></pre></p> </li> <li> <p>Install Mono runtime:    <pre><code>brew install mono\nmono --version\n</code></pre></p> </li> <li> <p>Install PyADM1ODE:    <pre><code>pip3 install pyadm1ode\n# or from source:\ngit clone https://github.com/dgaida/PyADM1ODE.git\ncd PyADM1ODE\npip3 install -e .\n</code></pre></p> </li> <li> <p>Verify Installation:    <pre><code>python3 -c \"import pyadm1; print(pyadm1.__version__)\"\n</code></pre></p> </li> </ol>"},{"location":"user_guide/installation/#core-dependencies","title":"Core Dependencies","text":"<p>PyADM1 automatically installs these core dependencies:</p> <pre><code>pythonnet&gt;=3.0.0      # .NET interop for C# DLLs\nnumpy&gt;=1.20.0         # Numerical computing\npandas&gt;=1.3.0         # Data manipulation\nscipy&gt;=1.7.0          # Scientific computing\nmatplotlib&gt;=3.5.0     # Plotting\n</code></pre>"},{"location":"user_guide/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"user_guide/installation/#for-development","title":"For Development","text":"<pre><code>pip install pytest pytest-cov black ruff mypy\n</code></pre>"},{"location":"user_guide/installation/#verifying-your-installation","title":"Verifying Your Installation","text":""},{"location":"user_guide/installation/#quick-verification","title":"Quick Verification","text":"<p>Run this Python script to verify all components:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"Verify PyADM1 installation.\"\"\"\n\ndef verify_installation():\n    \"\"\"Check all PyADM1 components.\"\"\"\n\n    # 1. Check core import\n    try:\n        import pyadm1\n        print(f\"\u2713 PyADM1 version: {pyadm1.__version__}\")\n    except ImportError as e:\n        print(f\"\u2717 Failed to import pyadm1: {e}\")\n        return False\n\n    # 2. Check core modules\n    try:\n        from pyadm1.core import ADM1\n        from pyadm1.substrates import Feedstock\n        from pyadm1.simulation import Simulator\n        print(\"\u2713 Core modules imported successfully\")\n    except ImportError as e:\n        print(f\"\u2717 Failed to import core modules: {e}\")\n        return False\n\n    # 3. Check .NET/Mono runtime\n    try:\n        import clr\n        print(\"\u2713 pythonnet (CLR) available\")\n    except ImportError:\n        print(\"\u2717 pythonnet not available\")\n        return False\n\n    # 4. Check C# DLLs\n    try:\n        feedstock = Feedstock(feeding_freq=48)\n        substrates = feedstock.mySubstrates()\n        n_substrates = substrates.getNumSubstrates()\n        print(f\"\u2713 C# DLLs working ({n_substrates} substrates loaded)\")\n    except Exception as e:\n        print(f\"\u2717 C# DLL access failed: {e}\")\n        return False\n\n    # 5. Quick simulation test\n    try:\n        from pyadm1.core.adm1 import ADM1\n        adm1 = ADM1(feedstock, V_liq=2000, T_ad=308.15)\n        initial_state = [0.01] * 37\n        adm1.create_influent([15, 10, 0, 0, 0, 0, 0, 0, 0, 0], 0)\n        print(\"\u2713 Basic simulation setup works\")\n    except Exception as e:\n        print(f\"\u2717 Simulation test failed: {e}\")\n        return False\n\n    print(\"\\n\u2705 All verification checks passed!\")\n    return True\n\nif __name__ == \"__main__\":\n    verify_installation()\n</code></pre> <p>Save as <code>verify_install.py</code> and run: <pre><code>python verify_install.py\n</code></pre></p>"},{"location":"user_guide/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/installation/#common-issues","title":"Common Issues","text":""},{"location":"user_guide/installation/#1-cannot-find-c-dlls","title":"1. \"Cannot find C# DLLs\"","text":"<p>Problem: Python can't locate the C# DLL files.</p> <p>Solution: <pre><code># Verify DLL files exist\nls pyadm1/dlls/\n\n# Should show: plant.dll, substrates.dll, biogas.dll, physchem.dll\n</code></pre></p> <p>If missing, reinstall from source: <pre><code>git clone https://github.com/dgaida/PyADM1ODE.git\ncd PyADM1ODE\npip install -e .\n</code></pre></p>"},{"location":"user_guide/installation/#2-pythonnet-import-error","title":"2. \"pythonnet import error\"","text":"<p>Problem: pythonnet fails to import or find .NET runtime.</p> <p>Linux/macOS Solution: <pre><code># Install Mono\nsudo apt-get install mono-complete  # Ubuntu/Debian\nbrew install mono                    # macOS\n\n# Verify Mono\nmono --version\n</code></pre></p> <p>Windows Solution: <pre><code># Install .NET Framework\n# Download from: https://dotnet.microsoft.com/download/dotnet-framework\n</code></pre></p>"},{"location":"user_guide/installation/#3-module-biogas-has-no-attribute","title":"3. \"Module 'biogas' has no attribute...\"","text":"<p>Problem: C# DLL methods not accessible.</p> <p>Solution: This usually indicates Mono/CLR issues. <pre><code># Reinstall pythonnet\npip uninstall pythonnet\npip install pythonnet&gt;=3.0.0\n\n# Restart Python interpreter\n</code></pre></p>"},{"location":"user_guide/installation/#4-import-errors-on-first-run","title":"4. Import errors on first run","text":"<p>Problem: First import takes long or fails.</p> <p>Solution: pythonnet needs to compile CLR bindings on first run: <pre><code>import clr  # First import may take 10-30 seconds\n# Subsequent imports will be fast\n</code></pre></p>"},{"location":"user_guide/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check GitHub Issues: PyADM1ODE Issues</li> <li>Create New Issue: Include:</li> <li>Operating system and version</li> <li>Python version (<code>python --version</code>)</li> <li>Error messages and stack traces</li> <li> <p>Output from <code>verify_install.py</code></p> </li> <li> <p>Contact: daniel.gaida@th-koeln.de</p> </li> </ol>"},{"location":"user_guide/installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Try the Quickstart: See Quickstart Guide</li> <li>Explore Examples: See Example: Basic Digester</li> <li>Read Component Documentation: Components Guide</li> </ol>"},{"location":"user_guide/installation/#updating-pyadm1ode","title":"Updating PyADM1ODE","text":""},{"location":"user_guide/installation/#update-from-pypi-not-yet-supported","title":"Update from PyPI (not yet supported)","text":"<pre><code>pip install --upgrade pyadm1\n</code></pre>"},{"location":"user_guide/installation/#update-from-source","title":"Update from Source","text":"<pre><code>cd PyADM1ODE\ngit pull origin master\npip install -e . --upgrade\n</code></pre>"},{"location":"user_guide/installation/#optional-packages","title":"Optional Packages","text":""},{"location":"user_guide/installation/#pyadm1ode_mcp-model-context-protocol-server","title":"PyADM1ODE_mcp - Model Context Protocol Server","text":"<p>For LLM-driven biogas plant modeling with natural language interface:</p> <pre><code># Install from GitHub\ngit clone https://github.com/dgaida/PyADM1ODE_mcp.git\ncd PyADM1ODE_mcp\npip install -e .\n</code></pre> <p>Features: - Natural language plant design via LLM (e.g., Claude) - MCP server for LLM integration - Interactive plant configuration</p> <p>Use cases: Non-expert plant design, rapid prototyping, educational tools</p> <p>See PyADM1ODE_mcp documentation for details.</p>"},{"location":"user_guide/installation/#pyadm1ode_calibration-parameter-calibration-framework","title":"PyADM1ODE_calibration - Parameter Calibration Framework","text":"<p>For automated model calibration from measurement data:</p> <pre><code># Install from GitHub\ngit clone https://github.com/dgaida/PyADM1ODE_calibration.git\ncd PyADM1ODE_calibration\npip install -e .\n</code></pre> <p>Features: - Initial calibration from historical data - Online re-calibration during operation - Multiple optimization algorithms (DE, PSO, Nelder-Mead) - Comprehensive validation metrics - Database integration for measurement data</p> <p>Use cases: Model parameterization, real plant adaptation, uncertainty quantification</p> <p>See PyADM1ODE_calibration documentation for details.</p>"},{"location":"user_guide/installation/#uninstallation","title":"Uninstallation","text":"<p>To remove PyADM1ODE (not yet supported): <pre><code>pip uninstall pyadm1ode\n</code></pre></p> <p>To also remove dependencies: <pre><code>pip uninstall pyadm1ode pythonnet numpy pandas scipy matplotlib\n</code></pre></p> <p>To remove optional packages (not yet supported): <pre><code>pip uninstall pyadm1ode_mcp pyadm1ode_calibration\n</code></pre></p>"},{"location":"user_guide/quickstart/","title":"Quickstart Guide","text":"<p>This guide will get you up and running with PyADM1ODE in minutes.</p>"},{"location":"user_guide/quickstart/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Your First Simulation</li> <li>Basic Single Digester</li> <li>Complete Plant with CHP and Heating</li> <li>Two-Stage Digestion</li> <li>Working with Different Substrates</li> <li>Save and Load Configurations</li> <li>Understanding Results</li> <li>Common Patterns</li> <li>Next Steps</li> </ol>"},{"location":"user_guide/quickstart/#your-first-simulation","title":"Your First Simulation","text":"<p>Let's simulate a simple single-stage biogas digester with corn silage and manure.</p> <pre><code>from pathlib import Path\nfrom pyadm1.configurator.plant_builder import BiogasPlant\nfrom pyadm1.substrates.feedstock import Feedstock\nfrom pyadm1.core.adm1 import get_state_zero_from_initial_state\nfrom pyadm1.configurator.plant_configurator import PlantConfigurator\n\n# 1. Create feedstock manager\nfeedstock = Feedstock(feeding_freq=48)  # Can change feed every 48 hours\n\n# 2. Load initial state (steady-state values)\ndata_path = Path(\"data/initial_states\")\ninitial_state_file = data_path / \"digester_initial8.csv\"\nadm1_state = get_state_zero_from_initial_state(str(initial_state_file))\n\n# 3. Define substrate feed rates [m\u00b3/day]\n# [corn_silage, manure, rye, grass, wheat, gps, ccm, feed_lime, cow_manure, onions]\nQ_substrates = [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n\n# 4. Create and configure plant\nplant = BiogasPlant(\"My First Biogas Plant\")\nconfigurator = PlantConfigurator(plant, feedstock)\n\nconfigurator.add_digester(\n    digester_id=\"main_digester\",\n    V_liq=2000.0,        # Liquid volume [m\u00b3]\n    V_gas=300.0,         # Gas volume [m\u00b3]\n    T_ad=308.15,         # Temperature [K] = 35\u00b0C\n    Q_substrates=Q_substrates\n)\n\n# 5. Initialize and simulate\nplant.initialize()\n\nresults = plant.simulate(\n    duration=10.0,       # Simulation time [days]\n    dt=1.0/24.0,        # Time step [days] = 1 hour\n    save_interval=1.0   # Save results daily\n)\n\n# 6. View results\nfor result in results:\n    time = result[\"time\"]\n    digester = result[\"components\"][\"main_digester\"]\n\n    print(f\"Day {time:.0f}:\")\n    print(f\"  Biogas:  {digester['Q_gas']:.1f} m\u00b3/d\")\n    print(f\"  Methane: {digester['Q_ch4']:.1f} m\u00b3/d\")\n    print(f\"  pH:      {digester['pH']:.2f}\")\n    print(f\"  VFA:     {digester['VFA']:.2f} g/L\")\n</code></pre> <p>Expected Output: <pre><code>Day 1:\n  Biogas:  1245.3 m\u00b3/d\n  Methane: 748.2 m\u00b3/d\n  pH:      7.32\n  VFA:     2.45 g/L\n...\n</code></pre></p>"},{"location":"user_guide/quickstart/#basic-single-digester","title":"Basic Single Digester","text":"<p>See the complete example in <code>examples/01_basic_digester.py</code>.</p>"},{"location":"user_guide/quickstart/#system-architecture","title":"System Architecture","text":"<p>The basic digester consists of:</p> <pre><code>[Substrate Feed] \u2192 [Digester] \u2192 [Gas Storage] \u2192 [Biogas Output]\n   15 m\u00b3/d corn        2000 m\u00b3      300 m\u00b3         ~1250 m\u00b3/d\n   10 m\u00b3/d manure      @ 35\u00b0C       membrane       60% CH\u2084\n</code></pre>"},{"location":"user_guide/quickstart/#key-features","title":"Key Features","text":"<ul> <li>Single-stage CSTR: Continuously stirred tank reactor</li> <li>Automatic gas storage: Created per digester (low-pressure membrane)</li> <li>Substrate mixing: Corn silage + cattle manure</li> <li>Temperature control: Mesophilic (35\u00b0C)</li> </ul>"},{"location":"user_guide/quickstart/#plant-configuration-details","title":"Plant Configuration Details","text":"<pre><code># The add_digester method automatically creates:\n# 1. Digester component with specified parameters\n# 2. Gas storage (membrane type) sized to V_gas\n# 3. Connection: Digester \u2192 Gas Storage\n\nconfigurator.add_digester(\n    digester_id=\"main_digester\",\n    V_liq=2000.0,               # Liquid volume [m\u00b3]\n    V_gas=300.0,                # Gas volume [m\u00b3]\n    T_ad=308.15,                # 35\u00b0C mesophilic\n    name=\"Main Digester\",\n    load_initial_state=True,    # Load steady-state CSV\n    Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n)\n</code></pre>"},{"location":"user_guide/quickstart/#understanding-the-output","title":"Understanding the Output","text":"<p>Gas Storage Behavior:</p> <pre><code># From results:\n'gas_storage': {\n    'stored_volume_m3': 150.0,      # Current volume [m\u00b3 STP]\n    'pressure_bar': 1.01,            # Current pressure [bar]\n    'vented_volume_m3': 0.0,         # Vented this step [m\u00b3]\n    'utilization': 0.50,             # 50% full\n    'Q_gas_supplied_m3_per_day': 1250.0  # Available for consumers\n}\n</code></pre> <p>When storage fills up: - Pressure increases from 0.95 to 1.05 bar - At 1.05 bar (full), excess gas is vented - Venting prevents overpressure and equipment damage - In real plants, vented gas goes to flare</p>"},{"location":"user_guide/quickstart/#process-stability-indicators","title":"Process Stability Indicators","text":"<pre><code># Check process stability\nfinal = results[-1][\"components\"][\"main_digester\"]\n\n# pH should be 6.8-7.5 for stable operation\nif 6.8 &lt;= final['pH'] &lt;= 7.5:\n    print(\"\u2713 pH stable\")\nelse:\n    print(f\"\u26a0 pH unstable: {final['pH']:.2f}\")\n\n# VFA should be &lt; 5 g/L\nif final['VFA'] &lt; 5.0:\n    print(\"\u2713 VFA acceptable\")\nelse:\n    print(f\"\u26a0 High VFA: {final['VFA']:.2f} g/L\")\n\n# FOS/TAC ratio should be &lt; 0.3\nif final['TAC'] &gt; 0:\n    fos_tac = final['VFA'] / final['TAC']\n    if fos_tac &lt; 0.3:\n        print(f\"\u2713 FOS/TAC stable: {fos_tac:.3f}\")\n    else:\n        print(f\"\u26a0 FOS/TAC high: {fos_tac:.3f}\")\n</code></pre> <p>Typical Performance Metrics:</p> Metric Value Assessment Biogas production ~1250 m\u00b3/d Good Methane content ~60% Typical for agricultural substrates Specific gas yield ~50 m\u00b3/m\u00b3 feed Good for corn silage + manure pH 7.28-7.30 Optimal (stable) VFA 2.3-2.4 g/L Good (&lt; 3 g/L limit) TAC 8.4-8.5 g CaCO\u2083/L Excellent buffer FOS/TAC ~0.27 Stable (&lt; 0.3)"},{"location":"user_guide/quickstart/#complete-plant-with-chp-and-heating","title":"Complete Plant with CHP and Heating","text":"<p>Now let's add power generation and heating to create a complete biogas plant:</p> <pre><code>from pyadm1.configurator.plant_builder import BiogasPlant\nfrom pyadm1.substrates.feedstock import Feedstock\nfrom pyadm1.configurator.plant_configurator import PlantConfigurator\n\n# Setup\nfeedstock = Feedstock(feeding_freq=48)\nplant = BiogasPlant(\"Complete Biogas Plant\")\nconfigurator = PlantConfigurator(plant, feedstock)\n\n# Add digester with automatic gas storage\nconfigurator.add_digester(\n    digester_id=\"main_digester\",\n    V_liq=2000.0,\n    V_gas=300.0,\n    T_ad=308.15,\n    Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n)\n\n# Add CHP unit (automatically creates flare)\nconfigurator.add_chp(\n    chp_id=\"chp_main\",\n    P_el_nom=500.0,      # Electrical power [kW]\n    eta_el=0.40,         # Electrical efficiency 40%\n    eta_th=0.45          # Thermal efficiency 45%\n)\n\n# Add heating system\nconfigurator.add_heating(\n    heating_id=\"heating_main\",\n    target_temperature=308.15,\n    heat_loss_coefficient=0.5\n)\n\n# Connect components automatically\nconfigurator.auto_connect_digester_to_chp(\"main_digester\", \"chp_main\")\nconfigurator.auto_connect_chp_to_heating(\"chp_main\", \"heating_main\")\n\n# Initialize and simulate\nplant.initialize()\nresults = plant.simulate(duration=10.0, dt=1.0/24.0, save_interval=1.0)\n\n# Analyze final results\nfinal = results[-1]\ndigester = final[\"components\"][\"main_digester\"]\nchp = final[\"components\"][\"chp_main\"]\nheating = final[\"components\"][\"heating_main\"]\n\nprint(f\"\\nFinal Results (Day {final['time']:.0f}):\")\nprint(f\"\\nDigester Performance:\")\nprint(f\"  Biogas:  {digester['Q_gas']:.1f} m\u00b3/d\")\nprint(f\"  Methane: {digester['Q_ch4']:.1f} m\u00b3/d\")\nprint(f\"  CH4 Content: {digester['Q_ch4']/digester['Q_gas']*100:.1f}%\")\nprint(f\"\\nCHP Performance:\")\nprint(f\"  Electrical Power: {chp['P_el']:.1f} kW\")\nprint(f\"  Thermal Power:    {chp['P_th']:.1f} kW\")\nprint(f\"  Gas Consumed:     {chp['Q_gas_consumed']:.1f} m\u00b3/d\")\nprint(f\"\\nHeating:\")\nprint(f\"  Heat Supplied:    {heating['Q_heat_supplied']:.1f} kW\")\nprint(f\"  Auxiliary Heat:   {heating['P_aux_heat']:.1f} kW\")\n</code></pre> <p>Automatic Component Creation:</p> <p>PlantConfigurator creates and connects: - Gas Storage: One per digester (membrane, sized to V_gas) - Flare: One per CHP (safety combustion, 98% CH\u2084 destruction)</p> <p>Connection Chain: <pre><code>Digester \u2192 Gas Storage \u2192 CHP \u2192 Flare\n                          \u2193\n                      Heating\n</code></pre></p>"},{"location":"user_guide/quickstart/#two-stage-digestion","title":"Two-Stage Digestion","text":"<p>See the complete example in <code>examples/02_two_stage_plant.py</code>.</p>"},{"location":"user_guide/quickstart/#system-architecture_1","title":"System Architecture","text":"<pre><code>[Feed] \u2192 [Hydrolysis] \u2192 [Storage 1] \u2198\n         500 m\u00b3          304 m\u00b3       \u2192 [CHP] \u2192 [Flare]\n         @ 45\u00b0C                      \u2197  500 kW    98%\n                                    \u2193\n[Effluent] \u2192 [Main] \u2192 [Storage 2] \u2197  [Heat 1] + [Heat 2]\n             1000 m\u00b3    150 m\u00b3        45\u00b0C       35\u00b0C\n             @ 35\u00b0C\n</code></pre>"},{"location":"user_guide/quickstart/#key-features_1","title":"Key Features","text":"<ul> <li>Temperature-phased: Thermophilic (45\u00b0C) + Mesophilic (35\u00b0C)</li> <li>Enhanced hydrolysis: Higher temp in first stage</li> <li>Stable methanogenesis: Optimized conditions in second stage</li> <li>Mechanical components: Pumps and mixers for material handling</li> <li>Energy integration: Combined heat and power with waste heat recovery</li> </ul>"},{"location":"user_guide/quickstart/#configuration","title":"Configuration","text":"<pre><code># Stage 1: Hydrolysis (thermophilic, 45\u00b0C)\nconfigurator.add_digester(\n    digester_id=\"hydrolysis_tank\",\n    V_liq=500.0,\n    V_gas=100.0,\n    T_ad=318.15,  # 45\u00b0C for faster hydrolysis\n    Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n)\n\n# Stage 2: Methanogenesis (mesophilic, 35\u00b0C)\nconfigurator.add_digester(\n    digester_id=\"main_digester\",\n    V_liq=2000.0,\n    V_gas=300.0,\n    T_ad=308.15,  # 35\u00b0C for methanogenesis\n    Q_substrates=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  # Fed from hydrolysis\n)\n\n# Connect in series (liquid flow)\nconfigurator.connect(\"hydrolysis_tank\", \"main_digester\", \"liquid\")\n\n# Add CHP and heating for both stages\nconfigurator.add_chp(\"chp_main\", P_el_nom=500.0)\nconfigurator.add_heating(\"heating_1\", target_temperature=318.15)\nconfigurator.add_heating(\"heating_2\", target_temperature=308.15)\n\n# Connect gas and heat flows\nconfigurator.auto_connect_digester_to_chp(\"hydrolysis_tank\", \"chp_main\")\nconfigurator.auto_connect_digester_to_chp(\"main_digester\", \"chp_main\")\nconfigurator.auto_connect_chp_to_heating(\"chp_main\", \"heating_1\")\nconfigurator.auto_connect_chp_to_heating(\"chp_main\", \"heating_2\")\n\n# Add mechanical components\nfrom pyadm1.components.mechanical import Pump, Mixer\n\n# Feed pump\nfeed_pump = Pump(\n    component_id=\"feed_pump\",\n    pump_type=\"progressive_cavity\",\n    Q_nom=30.0,\n    pressure_head=5.0\n)\nplant.add_component(feed_pump)\n\n# Transfer pump (digester 1 \u2192 digester 2)\ntransfer_pump = Pump(\n    component_id=\"transfer_pump\",\n    pump_type=\"progressive_cavity\",\n    Q_nom=25.0,\n    pressure_head=8.0\n)\nplant.add_component(transfer_pump)\n\n# Mixers for both digesters\nmixer_1 = Mixer(\n    component_id=\"mixer_1\",\n    mixer_type=\"propeller\",\n    tank_volume=500.0,\n    mixing_intensity=\"high\",\n    power_installed=15.0,\n    intermittent=True,\n    on_time_fraction=0.25\n)\nplant.add_component(mixer_1)\n\nmixer_2 = Mixer(\n    component_id=\"mixer_2\",\n    mixer_type=\"propeller\",\n    tank_volume=2000.0,\n    mixing_intensity=\"medium\",\n    power_installed=10.0,\n    intermittent=True,\n    on_time_fraction=0.25\n)\nplant.add_component(mixer_2)\n</code></pre>"},{"location":"user_guide/quickstart/#three-pass-gas-flow-simulation","title":"Three-Pass Gas Flow Simulation","text":"<p>The simulation uses a three-pass execution model for realistic gas management:</p> <p>Pass 1 - Gas Production: <pre><code>Digester 1: Q_gas = 850 m\u00b3/d \u2192 Storage 1\nDigester 2: Q_gas = 400 m\u00b3/d \u2192 Storage 2\n</code></pre></p> <p>Pass 2 - Storage Update: <pre><code>Storage 1: receives 850 m\u00b3/d, updates pressure/volume\nStorage 2: receives 400 m\u00b3/d, updates pressure/volume\n# If full: vent excess to atmosphere\n</code></pre></p> <p>Pass 3 - Gas Consumption: <pre><code>CHP demand: 1150 m\u00b3/d biogas\nStorage 1 supplies: ~675 m\u00b3/d\nStorage 2 supplies: ~475 m\u00b3/d\nCHP operates with actual supply\nExcess to flare: (supply - consumption)\n</code></pre></p>"},{"location":"user_guide/quickstart/#advantages-of-two-stage-design","title":"Advantages of Two-Stage Design","text":"Aspect Single-Stage Two-Stage Improvement Hydrolysis Limited by mesophilic temp Enhanced at 45\u00b0C Faster Methanogenesis Must tolerate VFA spikes Stable, pre-buffered feed More stable OLR capacity 3-4 kg COD/(m\u00b3\u00b7d) 5-8 kg COD/(m\u00b3\u00b7d) +100% Biogas yield 1150 m\u00b3/d 1253 m\u00b3/d +9% CH\u2084 content 58% 60% +3.4%"},{"location":"user_guide/quickstart/#expected-results","title":"Expected Results","text":"<p>Energy Balance:</p> <pre><code>Energy Production:\n  Electrical (gross):       480.5 kW\n  Thermal:                  540.6 kW\n\nParasitic Load:\n  Mixer 1:                    3.75 kW\n  Mixer 2:                    2.50 kW\n  Pumps (estimated):          2.00 kW\n  Total parasitic:            8.25 kW\n\nNet Electrical Output:      472.3 kW\n\nHeat Utilization:\n  Heating demand:           125.4 kW\n  CHP thermal supply:       540.6 kW\n  Heat coverage:            431.0 %\n\nGas Management:\n  Total production:        1253.1 m\u00b3/d\n  CHP consumption:         1150.0 m\u00b3/d\n  To flare:                 103.1 m\u00b3/d (8.2%)\n</code></pre>"},{"location":"user_guide/quickstart/#working-with-different-substrates","title":"Working with Different Substrates","text":""},{"location":"user_guide/quickstart/#available-substrates","title":"Available Substrates","text":"<p>PyADM1 includes 10 pre-configured agricultural substrates:</p> <ol> <li>Corn silage (maize) - Energy crop, high biogas yield</li> <li>Liquid manure (swinemanure) - High nitrogen content</li> <li>Green rye (greenrye) - Early-harvest energy crop</li> <li>Grass silage (grass) - Grassland biomass</li> <li>Wheat (wheat) - Cereal crop</li> <li>GPS (gps) - Whole-crop grain silage</li> <li>CCM (ccm) - Corn-cob-mix</li> <li>Feed lime (futterkalk) - pH buffer additive</li> <li>Cow manure (cowmanure) - Dairy farm manure</li> <li>Onions (onions) - Vegetable waste</li> </ol>"},{"location":"user_guide/quickstart/#substrate-feed-examples","title":"Substrate Feed Examples","text":"<pre><code># High-energy mix (corn + manure)\nQ = [15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n\n# Grass-based (renewable, extensive farming)\nQ = [0, 5, 0, 20, 0, 0, 0, 0, 0, 0]\n\n# Waste-based (manure + vegetables)\nQ = [0, 15, 0, 0, 0, 0, 0, 0, 10, 5]\n\n# Energy crop focus\nQ = [20, 5, 10, 0, 0, 0, 0, 0, 0, 0]\n</code></pre>"},{"location":"user_guide/quickstart/#substrate-information","title":"Substrate Information","text":"<p>Get detailed substrate properties:</p> <pre><code>from pyadm1.substrates.feedstock import Feedstock\n\n# View substrate parameters\nparams = Feedstock.get_substrate_params_string(\"maize\")\nprint(params)\n</code></pre> <p>Output: <pre><code>pH value: 3.93\nDry matter: 31.97 %FM\nVolatile solids content: 96.25 %TS\nParticulate chemical oxygen demand: ...\nBiochemical methane potential: 0.xxx l/gFM\n</code></pre></p>"},{"location":"user_guide/quickstart/#save-and-load-configurations","title":"Save and Load Configurations","text":"<p>Save your plant configuration for reuse:</p> <pre><code># Save configuration\nplant.to_json(\"my_plant_config.json\")\n\n# Load configuration later\nfrom pyadm1.configurator.plant_builder import BiogasPlant\nfrom pyadm1.substrates.feedstock import Feedstock\n\nfeedstock = Feedstock(feeding_freq=48)\nplant = BiogasPlant.from_json(\"my_plant_config.json\", feedstock)\n\n# Continue simulation\nplant.initialize()\nresults = plant.simulate(duration=10.0, dt=1.0/24.0)\n</code></pre>"},{"location":"user_guide/quickstart/#understanding-results","title":"Understanding Results","text":""},{"location":"user_guide/quickstart/#key-output-variables","title":"Key Output Variables","text":""},{"location":"user_guide/quickstart/#digester-outputs","title":"Digester Outputs","text":"<ul> <li><code>Q_gas</code> - Total biogas production [m\u00b3/d]</li> <li><code>Q_ch4</code> - Methane production [m\u00b3/d]</li> <li><code>Q_co2</code> - CO2 production [m\u00b3/d]</li> <li><code>pH</code> - pH value [-]</li> <li><code>VFA</code> - Volatile fatty acids [g HAceq/L]</li> <li><code>TAC</code> - Total alkalinity [g CaCO3/L]</li> </ul>"},{"location":"user_guide/quickstart/#chp-outputs","title":"CHP Outputs","text":"<ul> <li><code>P_el</code> - Electrical power [kW]</li> <li><code>P_th</code> - Thermal power [kW]</li> <li><code>Q_gas_consumed</code> - Gas consumption [m\u00b3/d]</li> <li><code>load_factor</code> - Operating point [0-1]</li> </ul>"},{"location":"user_guide/quickstart/#heating-outputs","title":"Heating Outputs","text":"<ul> <li><code>Q_heat_supplied</code> - Heat delivered [kW]</li> <li><code>P_th_used</code> - CHP heat used [kW]</li> <li><code>P_aux_heat</code> - Auxiliary heat needed [kW]</li> </ul>"},{"location":"user_guide/quickstart/#gas-storage-outputs","title":"Gas Storage Outputs","text":"<ul> <li><code>stored_volume_m3</code> - Current volume [m\u00b3 STP]</li> <li><code>pressure_bar</code> - Current pressure [bar]</li> <li><code>utilization</code> - Fill level [0-1]</li> <li><code>vented_volume_m3</code> - Gas vented [m\u00b3]</li> <li><code>Q_gas_supplied_m3_per_day</code> - Gas available [m\u00b3/d]</li> </ul>"},{"location":"user_guide/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"user_guide/quickstart/#pattern-1-parameter-sweep","title":"Pattern 1: Parameter Sweep","text":"<p>Test different substrate amounts:</p> <pre><code>feed_rates = [10, 15, 20, 25]\nresults_all = []\n\nfor feed in feed_rates:\n    Q = [feed, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    plant = BiogasPlant(f\"Plant_Feed_{feed}\")\n    configurator = PlantConfigurator(plant, feedstock)\n    configurator.add_digester(\"dig1\", V_liq=2000, Q_substrates=Q)\n\n    plant.initialize()\n    results = plant.simulate(duration=10.0, dt=1.0/24.0)\n\n    final = results[-1][\"components\"][\"dig1\"]\n    results_all.append({\n        'feed': feed,\n        'biogas': final['Q_gas'],\n        'methane': final['Q_ch4']\n    })\n\nfor r in results_all:\n    print(f\"Feed {r['feed']} m\u00b3/d \u2192 CH4 {r['methane']:.1f} m\u00b3/d\")\n</code></pre>"},{"location":"user_guide/quickstart/#pattern-2-time-series-analysis","title":"Pattern 2: Time Series Analysis","text":"<p>Track evolution over time:</p> <pre><code>import matplotlib.pyplot as plt\n\n# Extract time series\ntimes = [r['time'] for r in results]\nbiogas = [r['components']['main_digester']['Q_gas'] for r in results]\nmethane = [r['components']['main_digester']['Q_ch4'] for r in results]\npH = [r['components']['main_digester']['pH'] for r in results]\n\n# Plot\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))\n\nax1.plot(times, biogas, 'b-', label='Biogas')\nax1.plot(times, methane, 'g-', label='Methane')\nax1.set_ylabel('Production [m\u00b3/d]')\nax1.legend()\nax1.grid(True)\n\nax2.plot(times, pH, 'r-')\nax2.set_xlabel('Time [days]')\nax2.set_ylabel('pH')\nax2.axhline(y=7.0, color='k', linestyle='--', alpha=0.3)\nax2.grid(True)\n\nplt.tight_layout()\nplt.savefig('simulation_results.png')\n</code></pre>"},{"location":"user_guide/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've run your first simulations:</p> <ol> <li>Learn about components: Components Guide</li> <li>Explore advanced examples:</li> <li><code>examples/01_basic_digester.py</code></li> <li><code>examples/02_two_stage_plant.py</code></li> <li><code>examples/parallel_two_stage_simulation.py</code></li> <li>Try parallel simulations: Multiple scenarios simultaneously</li> <li>Explore MCP server: PyADM1ODE_mcp for LLM-driven plant design</li> <li>Calibrate your model: PyADM1ODE_calibration for parameter fitting</li> <li>Read API documentation: Full reference for all classes</li> </ol>"},{"location":"user_guide/quickstart/#quick-reference","title":"Quick Reference","text":""},{"location":"user_guide/quickstart/#common-commands","title":"Common Commands","text":"<pre><code># Create plant\nplant = BiogasPlant(\"My Plant\")\nconfigurator = PlantConfigurator(plant, feedstock)\n\n# Add components\nconfigurator.add_digester(id, V_liq, V_gas, T_ad, Q_substrates)\nconfigurator.add_chp(id, P_el_nom, eta_el, eta_th)\nconfigurator.add_heating(id, target_temperature)\n\n# Connect\nconfigurator.connect(from_id, to_id, type)\nconfigurator.auto_connect_digester_to_chp(dig_id, chp_id)\nconfigurator.auto_connect_chp_to_heating(chp_id, heat_id)\n\n# Simulate\nplant.initialize()\nresults = plant.simulate(duration, dt, save_interval)\n\n# Save/Load\nplant.to_json(filepath)\nplant = BiogasPlant.from_json(filepath, feedstock)\n</code></pre>"},{"location":"user_guide/quickstart/#temperature-conversions","title":"Temperature Conversions","text":"<pre><code># Common temperatures\nT_mesophilic = 308.15  # 35\u00b0C\nT_thermophilic = 328.15  # 55\u00b0C\nT_psychrophilic = 298.15  # 25\u00b0C\n\n# Convert \u00b0C to K\nT_K = T_celsius + 273.15\n</code></pre>"},{"location":"user_guide/quickstart/#default-parameters","title":"Default Parameters","text":"<pre><code># Typical digester sizes\nV_liq_small = 500      # Small farm [m\u00b3]\nV_liq_medium = 2000    # Medium farm [m\u00b3]\nV_liq_large = 5000     # Large farm [m\u00b3]\n\n# CHP sizes\nP_el_small = 150       # Small [kW]\nP_el_medium = 500      # Medium [kW]\nP_el_large = 1000      # Large [kW]\n\n# Substrate feeds\nQ_low = 10             # Low loading [m\u00b3/d]\nQ_medium = 20          # Medium loading [m\u00b3/d]\nQ_high = 40            # High loading [m\u00b3/d]\n</code></pre>"},{"location":"user_guide/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user_guide/quickstart/#issue-simulation-unstable","title":"Issue: Simulation unstable","text":"<p>Symptoms: pH drops, VFA rises, methane production decreases</p> <p>Solutions: - Reduce substrate feed rate - Increase retention time (larger V_liq) - Add buffer material (feed lime) - Check substrate composition</p>"},{"location":"user_guide/quickstart/#issue-low-gas-production","title":"Issue: Low gas production","text":"<p>Solutions: - Increase substrate feed - Check substrate degradability - Verify temperature is optimal - Ensure adequate mixing (implicit in model)</p>"},{"location":"user_guide/quickstart/#issue-slow-simulation","title":"Issue: Slow simulation","text":"<p>Solutions: - Increase time step <code>dt</code> (but keep &lt; 0.1 days) - Reduce <code>save_interval</code> for less output - Use parallel simulation for parameter sweeps</p> <p>For more help, see the Installation Guide or contact daniel.gaida@th-koeln.de.</p>"},{"location":"user_guide/quickstart/#references","title":"References","text":"<ul> <li>ADM1 Model: Batstone et al. (2002). Anaerobic Digestion Model No. 1. IWA Publishing.</li> <li>Leitfaden Biogas: FNR (2016). https://mediathek.fnr.de/leitfaden-biogas.html</li> </ul>"},{"location":"user_guide/troubleshooting/","title":"Troubleshooting Guide","text":"<p>Diese Seite bietet eine \u00dcbersicht \u00fcber h\u00e4ufige Probleme und deren L\u00f6sungen in PyADM1ODE. Detaillierte Troubleshooting-Anleitungen finden Sie in den jeweiligen Komponentendokumentationen.</p>"},{"location":"user_guide/troubleshooting/#ubersicht","title":"\u00dcbersicht","text":"<p>PyADM1ODE ist ein komplexes System mit biologischen, energetischen und mechanischen Komponenten. Probleme k\u00f6nnen in verschiedenen Bereichen auftreten:</p> <ul> <li>Installation und Setup: Python-Umgebung, Abh\u00e4ngigkeiten, C# DLLs</li> <li>Biologische Prozesse: Fermenter-Instabilit\u00e4t, pH-Probleme, VFA-Akkumulation</li> <li>Energiesystem: BHKW, Heizung, Gasspeicher</li> <li>Mechanische Komponenten: Pumpen, R\u00fchrwerke</li> <li>F\u00fctterungssystem: Substratqualit\u00e4t, Dosiergenauigkeit</li> <li>Simulation und Performance: Laufzeit, Konvergenz, Numerik</li> </ul>"},{"location":"user_guide/troubleshooting/#installation-und-setup","title":"Installation und Setup","text":"<p>F\u00fcr Installationsprobleme siehe:</p> <p>\u2192 Installation Guide - Troubleshooting Section</p> <p>H\u00e4ufige Themen: - C# DLL-Dateien nicht gefunden - pythonnet Import-Fehler - Mono/.NET Framework-Probleme - Erste Import-Verz\u00f6gerungen - Modul-Attributfehler</p>"},{"location":"user_guide/troubleshooting/#biologische-prozesse","title":"Biologische Prozesse","text":""},{"location":"user_guide/troubleshooting/#fermenter-probleme","title":"Fermenter-Probleme","text":"<p>F\u00fcr Diagnose und L\u00f6sung biologischer Prozessprobleme siehe:</p> <p>\u2192 Biological Components - Troubleshooting Section</p> <p>Behandelte Themen:</p>"},{"location":"user_guide/troubleshooting/#niedriger-ph-wert","title":"Niedriger pH-Wert","text":"<ul> <li>Ursachen: Zu hohe organische Raumbelastung, unzureichende Pufferkapazit\u00e4t</li> <li>Diagnose: pH &lt; 6.8, steigende VFA</li> <li>L\u00f6sungen: OLR reduzieren, Kalkpuffer hinzuf\u00fcgen, Substratmischung anpassen</li> </ul>"},{"location":"user_guide/troubleshooting/#schaumbildung","title":"Schaumbildung","text":"<ul> <li>Ursachen: Hoher Proteingehalt, pH-\u00c4nderungen, hohe VFA</li> <li>L\u00f6sungen: Proteinreiche Substrate reduzieren, pH stabilisieren</li> </ul>"},{"location":"user_guide/troubleshooting/#geringe-gasproduktion","title":"Geringe Gasproduktion","text":"<ul> <li>Ursachen: Niedrige OLR, Substratqualit\u00e4t, Inhibition, kurze HRT</li> <li>Diagnose-Tools: Spezifische Gasproduktion, Methangehalt pr\u00fcfen</li> <li>L\u00f6sungen: Substratqualit\u00e4t verbessern, Inhibitoren identifizieren</li> </ul>"},{"location":"user_guide/troubleshooting/#prozessuberwachung","title":"Prozess\u00fcberwachung","text":"<p>\u2192 Biological Components - Process Monitoring</p> <p>Wichtige Prozessindikatoren: - pH-Wert: 6.8-7.5 optimal - VFA/TAC-Verh\u00e4ltnis: &lt; 0.4 - Methangehalt: &gt; 55% - Temperaturstabilit\u00e4t</p>"},{"location":"user_guide/troubleshooting/#energiesystem","title":"Energiesystem","text":""},{"location":"user_guide/troubleshooting/#bhkw-und-warmesysteme","title":"BHKW und W\u00e4rmesysteme","text":"<p>F\u00fcr Energiekomponenten-Probleme siehe:</p> <p>\u2192 Energy Components - Troubleshooting Section</p> <p>Behandelte Themen:</p>"},{"location":"user_guide/troubleshooting/#bhkw-lauft-nicht","title":"BHKW l\u00e4uft nicht","text":"<ul> <li>Diagnose: Gasverf\u00fcgbarkeit, Mindestgasbedarf, Speicherdruck pr\u00fcfen</li> <li>L\u00f6sungen: Gasversorgung sicherstellen, Speicherdruck anpassen</li> </ul>"},{"location":"user_guide/troubleshooting/#ubermaiges-venting","title":"\u00dcberm\u00e4\u00dfiges Venting","text":"<ul> <li>Ursache: Gasproduktion &gt; BHKW-Verbrauch</li> <li>L\u00f6sungen:</li> <li>BHKW-Kapazit\u00e4t erh\u00f6hen</li> <li>Zweites BHKW hinzuf\u00fcgen</li> <li>Gasspeicher vergr\u00f6\u00dfern</li> </ul>"},{"location":"user_guide/troubleshooting/#unzureichende-warme","title":"Unzureichende W\u00e4rme","text":"<ul> <li>Diagnose: Hoher Zusatzheizungsbedarf</li> <li>L\u00f6sungen: Isolierung verbessern, BHKW vergr\u00f6\u00dfern, Fermentertemperatur reduzieren</li> </ul>"},{"location":"user_guide/troubleshooting/#optimierungsstrategien","title":"Optimierungsstrategien","text":"<p>\u2192 Energy Components - Optimization Strategies</p> <p>Themen: - W\u00e4rmenutzungsoptimierung - Lastfolgebetrieb - Gasspeicher-Management</p>"},{"location":"user_guide/troubleshooting/#mechanische-komponenten","title":"Mechanische Komponenten","text":""},{"location":"user_guide/troubleshooting/#pumpen-und-ruhrwerkprobleme","title":"Pumpen- und R\u00fchrwerkprobleme","text":"<p>F\u00fcr mechanische Komponentenprobleme siehe:</p> <p>\u2192 Mechanical Components - Troubleshooting Section</p> <p>Behandelte Themen:</p>"},{"location":"user_guide/troubleshooting/#pumpe-liefert-unzureichenden-durchfluss","title":"Pumpe liefert unzureichenden Durchfluss","text":"<ul> <li>Diagnose: Effizienz, Druckh\u00f6he, Dimensionierung pr\u00fcfen</li> <li>L\u00f6sungen: Pumpengr\u00f6\u00dfe erh\u00f6hen, Reibungsverluste reduzieren, Blockaden pr\u00fcfen</li> </ul>"},{"location":"user_guide/troubleshooting/#ruhrwerk-verbraucht-zu-viel-energie","title":"R\u00fchrwerk verbraucht zu viel Energie","text":"<ul> <li>Diagnose: Spezifische Leistung &gt; 6.0 W/m\u00b3</li> <li>L\u00f6sungen: Intermittierenden Betrieb aktivieren, Intensit\u00e4t reduzieren</li> </ul>"},{"location":"user_guide/troubleshooting/#schlechte-mischqualitat","title":"Schlechte Mischqualit\u00e4t","text":"<ul> <li>Diagnose: Mixing quality &lt; 0.7, lange Mischzeit</li> <li>L\u00f6sungen: Intensit\u00e4t erh\u00f6hen, Einschaltzeit verl\u00e4ngern, gr\u00f6\u00dferes R\u00fchrblatt</li> </ul>"},{"location":"user_guide/troubleshooting/#optimierungsstrategien_1","title":"Optimierungsstrategien","text":"<p>\u2192 Mechanical Components - Optimization Strategies</p> <p>Themen: - Pumpenoptimierung (80-90% Nennlast) - Mischstrategie-Auswahl - Energieminimierung</p>"},{"location":"user_guide/troubleshooting/#futterungssystem","title":"F\u00fctterungssystem","text":""},{"location":"user_guide/troubleshooting/#lager-und-dosierprobleme","title":"Lager- und Dosierprobleme","text":"<p>F\u00fcr F\u00fctterungskomponenten-Probleme siehe:</p> <p>\u2192 Feeding Components - Troubleshooting Section</p> <p>Behandelte Themen:</p>"},{"location":"user_guide/troubleshooting/#schneller-qualitatsverlust","title":"Schneller Qualit\u00e4tsverlust","text":"<ul> <li>Diagnose: Qualit\u00e4tsfaktor &lt; 0.95 bei kurzer Lagerzeit</li> <li>L\u00f6sungen: Lagertyp verbessern, Temperatur reduzieren, schnellere Verwendung</li> </ul>"},{"location":"user_guide/troubleshooting/#dosierer-blockaden","title":"Dosierer-Blockaden","text":"<ul> <li>Diagnose: H\u00e4ufige Blockaden (&gt; 5)</li> <li>L\u00f6sungen: Robusteren Dosierertyp w\u00e4hlen, Substratvorbereitung verbessern</li> </ul>"},{"location":"user_guide/troubleshooting/#inkonsistente-dosierung","title":"Inkonsistente Dosierung","text":"<ul> <li>Diagnose: Durchschnittlicher Dosierfehler &gt; 10%</li> <li>L\u00f6sungen: Pr\u00e4ziseren Dosierertyp erw\u00e4gen, Kalibrierung pr\u00fcfen</li> </ul>"},{"location":"user_guide/troubleshooting/#substratmanagement","title":"Substratmanagement","text":"<p>\u2192 Feeding Components - Optimization Strategies</p> <p>Themen: - Substratmischoptimierung - Bestandsmanagement - Dosiergenauigkeitsoptimierung</p>"},{"location":"user_guide/troubleshooting/#simulation-und-performance","title":"Simulation und Performance","text":""},{"location":"user_guide/troubleshooting/#simulationsprobleme","title":"Simulationsprobleme","text":"<p>F\u00fcr allgemeine Simulationsprobleme siehe:</p> <p>\u2192 Quickstart Guide - Troubleshooting Section</p> <p>Behandelte Themen:</p>"},{"location":"user_guide/troubleshooting/#simulation-instabil","title":"Simulation instabil","text":"<ul> <li>Symptome: pH f\u00e4llt, VFA steigt, Methanproduktion sinkt</li> <li>L\u00f6sungen: Substratf\u00fctterungsrate reduzieren, Verweilzeit erh\u00f6hen, Puffermaterial hinzuf\u00fcgen</li> </ul>"},{"location":"user_guide/troubleshooting/#niedrige-gasproduktion","title":"Niedrige Gasproduktion","text":"<ul> <li>L\u00f6sungen: Substratf\u00fctterung erh\u00f6hen, Abbaubarkeit pr\u00fcfen, Temperatur optimieren</li> </ul>"},{"location":"user_guide/troubleshooting/#langsame-simulation","title":"Langsame Simulation","text":"<ul> <li>L\u00f6sungen: Zeitschritt erh\u00f6hen (dt), save_interval reduzieren, parallele Simulation nutzen</li> </ul>"},{"location":"user_guide/troubleshooting/#best-practices-nach-komponententyp","title":"Best Practices nach Komponententyp","text":""},{"location":"user_guide/troubleshooting/#biologische-komponenten","title":"Biologische Komponenten","text":"<p>\u2192 Biological Components - Best Practices</p> <ol> <li>Mit realistischen Betriebsparametern starten</li> <li>Kritische Parameter \u00fcberwachen</li> <li>Puffersysteme implementieren</li> <li>Zweistufige Systeme f\u00fcr schwierige Substrate nutzen</li> <li>Modell mit realen Daten kalibrieren</li> </ol>"},{"location":"user_guide/troubleshooting/#energiekomponenten","title":"Energiekomponenten","text":"<p>\u2192 Energy Components - Performance Metrics</p> <ul> <li>BHKW-Verf\u00fcgbarkeit berechnen</li> <li>Volllaststunden tracken</li> <li>W\u00e4rmenutzungsgrad optimieren</li> <li>Parasit\u00e4re Last minimieren</li> </ul>"},{"location":"user_guide/troubleshooting/#mechanische-komponenten_1","title":"Mechanische Komponenten","text":"<p>\u2192 Mechanical Components - Best Practices</p> <ol> <li>Pumpen f\u00fcr optimalen Wirkungsgrad dimensionieren (80-90% Nennlast)</li> <li>Intermittierendes Mischen implementieren</li> <li>Regelm\u00e4\u00dfige Wartung</li> <li>Systemdesign optimieren</li> <li>Energieverbrauch \u00fcberwachen</li> </ol>"},{"location":"user_guide/troubleshooting/#futterungskomponenten","title":"F\u00fctterungskomponenten","text":"<p>\u2192 Feeding Components - Best Practices</p> <ol> <li>Qualit\u00e4ts\u00fcberwachung implementieren</li> <li>Bestandssicherheit aufrechterhalten (7-14 Tage)</li> <li>Energieverbrauch optimieren</li> <li>Substratmischung optimieren</li> <li>Wartung planen</li> </ol>"},{"location":"user_guide/troubleshooting/#diagnose-tools-und-checklisten","title":"Diagnose-Tools und Checklisten","text":""},{"location":"user_guide/troubleshooting/#fermenter-gesundheitscheck","title":"Fermenter-Gesundheitscheck","text":"<pre><code>def monitor_digester_health(results):\n    \"\"\"\n    Umfassender Fermenter-Gesundheitscheck\n\n    Siehe: components/biological.md#prozess\u00fcberwachung\n    \"\"\"\n    for result in results:\n        digester_data = result['components']['main_digester']\n\n        # pH-Wert\n        pH = digester_data['pH']\n        if pH &lt; 6.8:\n            print(f\"\u26a0 Niedriger pH ({pH:.2f}) - \u00dcbers\u00e4uerungsrisiko\")\n        elif pH &gt; 8.0:\n            print(f\"\u26a0 Hoher pH ({pH:.2f}) - M\u00f6gliche Ammoniakinhibition\")\n\n        # VFA/TAC-Verh\u00e4ltnis\n        VFA = digester_data['VFA']\n        TAC = digester_data['TAC']\n        VFA_TAC = VFA / TAC if TAC &gt; 0 else 0\n\n        if VFA_TAC &gt; 0.4:\n            print(f\"\u26a0 Hohes VFA/TAC ({VFA_TAC:.2f}) - Prozessinstabilit\u00e4t\")\n\n        # Gasproduktion\n        Q_gas = digester_data['Q_gas']\n        if Q_gas &lt; 500:  # Beispielschwelle\n            print(f\"\u26a0 Niedrige Gasproduktion ({Q_gas:.1f} m\u00b3/d)\")\n</code></pre>"},{"location":"user_guide/troubleshooting/#energiebilanz-analyse","title":"Energiebilanz-Analyse","text":"<pre><code>def energy_balance_check(results):\n    \"\"\"\n    Energiesystem-Diagnose\n\n    Siehe: components/energy.md#vollst\u00e4ndiges-energiesystem\n    \"\"\"\n    final = results[-1]\n    comp = final['components']\n\n    # BHKW-Leistung\n    P_el = comp['chp1']['P_el']\n    P_th = comp['chp1']['P_th']\n\n    # W\u00e4rmebedarf\n    Q_heat = comp['heat1']['Q_heat_supplied']\n    P_aux = comp['heat1']['P_aux_heat']\n\n    # Warnungen\n    if P_aux &gt; 50:\n        print(f\"\u26a0 Hoher Zusatzheizungsbedarf: {P_aux:.1f} kW\")\n        print(\"  \u2192 Isolierung verbessern oder BHKW vergr\u00f6\u00dfern\")\n\n    heat_utilization = Q_heat / P_th if P_th &gt; 0 else 0\n    if heat_utilization &lt; 0.5:\n        print(f\"\u26a0 Niedrige W\u00e4rmenutzung: {heat_utilization:.1%}\")\n        print(\"  \u2192 Zus\u00e4tzliche W\u00e4rmeverbraucher erw\u00e4gen\")\n</code></pre>"},{"location":"user_guide/troubleshooting/#mechanische-energie-audit","title":"Mechanische Energie-Audit","text":"<pre><code>def mechanical_energy_audit(results):\n    \"\"\"\n    Parasit\u00e4re Last-Analyse\n\n    Siehe: components/mechanical.md#integrationsbeispiel\n    \"\"\"\n    final = results[-1]\n    comp = final['components']\n\n    # Gesamtverbrauch\n    pump_energy = comp.get('pump1', {}).get('energy_consumed', 0)\n    mixer_energy = comp.get('mix1', {}).get('energy_consumed', 0)\n    total_parasitic = pump_energy + mixer_energy\n\n    # BHKW-Produktion\n    chp_energy = comp['chp1']['P_el'] * 30 * 24  # kWh\n\n    # Parasit\u00e4re Last\n    parasitic_fraction = total_parasitic / chp_energy if chp_energy &gt; 0 else 0\n\n    if parasitic_fraction &gt; 0.10:\n        print(f\"\u26a0 Hohe parasit\u00e4re Last: {parasitic_fraction:.1%}\")\n        print(\"  \u2192 Intermittierendes Mischen aktivieren\")\n        print(\"  \u2192 Pumpendimensionierung pr\u00fcfen\")\n</code></pre>"},{"location":"user_guide/troubleshooting/#optimale-betriebsbereiche-schnellreferenz","title":"Optimale Betriebsbereiche - Schnellreferenz","text":""},{"location":"user_guide/troubleshooting/#fermenter","title":"Fermenter","text":"Parameter Optimal Akzeptabel Kritisch pH 7.0-7.5 6.8-8.0 &lt;6.8 oder &gt;8.0 VFA [g/L] 0.5-2.0 2.0-4.0 &gt;4.0 VFA/TAC 0.2-0.3 0.3-0.4 &gt;0.4 TAC [g CaCO\u2083/L] 5.0-10.0 4.0-12.0 &lt;4.0 CH\u2084-Gehalt [%] 58-62 55-65 &lt;55 <p>Quelle: Biological Components - Process Monitoring</p>"},{"location":"user_guide/troubleshooting/#energiesystem_1","title":"Energiesystem","text":"Komponente Optimaler Bereich Warnung BHKW-Last 80-100% &lt;40% oder &gt;100% W\u00e4rmenutzung &gt;70% &lt;50% Gasspeicher 30-70% &lt;20% oder &gt;80% Parasit\u00e4re Last &lt;10% der Produktion &gt;15% <p>Quelle: Energy Components - Performance Metrics</p>"},{"location":"user_guide/troubleshooting/#mechanische-komponenten_2","title":"Mechanische Komponenten","text":"Komponente Optimaler Betrieb Ineffizient Pumpe 80-90% Q_nom &lt;50% oder &gt;95% R\u00fchrwerk (kontinuierlich) 5 W/m\u00b3 &gt;8 W/m\u00b3 R\u00fchrwerk (intermittierend) 25% Einschaltzeit &gt;40% Pumpenwirkungsgrad &gt;65% &lt;50% <p>Quelle: Mechanical Components - Dimensioning Guidelines</p>"},{"location":"user_guide/troubleshooting/#haufig-gestellte-fragen-faq","title":"H\u00e4ufig gestellte Fragen (FAQ)","text":""},{"location":"user_guide/troubleshooting/#warum-ist-mein-ph-wert-niedrig","title":"Warum ist mein pH-Wert niedrig?","text":"<p>Antwort: Siehe Biological Components - Niedriger pH-Wert</p> <p>Hauptursachen: \u00dcberf\u00fctterung, unzureichende Pufferung, pl\u00f6tzliche Substrat\u00e4nderungen</p>"},{"location":"user_guide/troubleshooting/#warum-lauft-mein-bhkw-nicht","title":"Warum l\u00e4uft mein BHKW nicht?","text":"<p>Antwort: Siehe Energy Components - BHKW l\u00e4uft nicht</p> <p>Pr\u00fcfen: Gasverf\u00fcgbarkeit, Mindestgasbedarf, Speicherdruck</p>"},{"location":"user_guide/troubleshooting/#warum-verbraucht-mein-ruhrwerk-so-viel-energie","title":"Warum verbraucht mein R\u00fchrwerk so viel Energie?","text":"<p>Antwort: Siehe Mechanical Components - R\u00fchrwerk verbraucht zu viel</p> <p>L\u00f6sung: Intermittierenden Betrieb aktivieren (70% Einsparung)</p>"},{"location":"user_guide/troubleshooting/#warum-verschlechtert-sich-meine-substratqualitat-schnell","title":"Warum verschlechtert sich meine Substratqualit\u00e4t schnell?","text":"<p>Antwort: Siehe Feeding Components - Schneller Qualit\u00e4tsverlust</p> <p>Pr\u00fcfen: Lagertyp, Temperatur, Lagerzeit</p>"},{"location":"user_guide/troubleshooting/#warum-ist-meine-simulation-langsam","title":"Warum ist meine Simulation langsam?","text":"<p>Antwort: Siehe Quickstart - Slow Simulation</p> <p>L\u00f6sungen: Zeitschritt erh\u00f6hen, save_interval reduzieren, parallele Simulation nutzen</p>"},{"location":"user_guide/troubleshooting/#weiterfuhrende-ressourcen","title":"Weiterf\u00fchrende Ressourcen","text":""},{"location":"user_guide/troubleshooting/#komponenten-spezifische-dokumentation","title":"Komponenten-spezifische Dokumentation","text":"<ul> <li>Biological Components: Fermenter, Hydrolyse, Separatoren</li> <li>Energy Components: BHKW, Heizung, Gasspeicher, Fackel</li> <li>Mechanical Components: Pumpen, R\u00fchrwerke</li> <li>Feeding Components: Lager, Dosierer</li> </ul>"},{"location":"user_guide/troubleshooting/#allgemeine-anleitungen","title":"Allgemeine Anleitungen","text":"<ul> <li>Installation Guide: Setup und Plattform-spezifische Probleme</li> <li>Quickstart Guide: Erste Schritte und grundlegende Simulation</li> <li>Components Overview: Architektur und Integrationsmuster</li> </ul>"},{"location":"user_guide/troubleshooting/#externe-ressourcen","title":"Externe Ressourcen","text":"<ul> <li>GitHub Issues: PyADM1ODE Issues</li> <li>Leitfaden Biogas: FNR (2016) - Praktische Betriebsempfehlungen</li> <li>ADM1 Documentation: IWA - Wissenschaftliche Grundlagen</li> </ul>"},{"location":"user_guide/troubleshooting/#support","title":"Support","text":"<p>Wenn Sie in dieser Dokumentation keine L\u00f6sung finden:</p> <ol> <li>Pr\u00fcfen Sie GitHub Issues: Existing Issues</li> <li>Erstellen Sie ein neues Issue mit:</li> <li>Betriebssystem und Version</li> <li>Python-Version</li> <li>Fehlermeldungen und Stack Traces</li> <li>Minimales reproduzierbares Beispiel</li> <li>Kontakt: daniel.gaida@th-koeln.de</li> </ol>"},{"location":"user_guide/troubleshooting/#checkliste-fur-problem-reports","title":"Checkliste f\u00fcr Problem-Reports","text":"<p>Bei der Meldung von Problemen bitte folgende Informationen angeben:</p> <ul> <li>[ ] System-Info: OS, Python-Version (<code>python --version</code>)</li> <li>[ ] PyADM1-Version: <code>import pyadm1; print(pyadm1.__version__)</code></li> <li>[ ] Problemkategorie: Installation, Biologisch, Energie, Mechanisch, etc.</li> <li>[ ] Fehlermeldung: Vollst\u00e4ndiger Stack Trace</li> <li>[ ] Minimales Beispiel: Code, der das Problem reproduziert</li> <li>[ ] Erwartetes Verhalten: Was sollte passieren</li> <li>[ ] Tats\u00e4chliches Verhalten: Was passiert stattdessen</li> <li>[ ] Logs: Relevante Ausgaben oder Logdateien</li> </ul>"},{"location":"user_guide/components/","title":"Components Guide","text":"<p>PyADM1 verwendet eine modulare, komponentenbasierte Architektur. Dieser Leitfaden behandelt alle verf\u00fcgbaren Komponenten, ihre Parameter und Verwendungsmuster.</p>"},{"location":"user_guide/components/#komponentenarchitektur","title":"Komponentenarchitektur","text":""},{"location":"user_guide/components/#basis-komponentenstruktur","title":"Basis-Komponentenstruktur","text":"<p>Alle Komponenten erben von der <code>Component</code> Basisklasse und implementieren:</p> <pre><code>class Component(ABC):\n    def __init__(self, component_id, component_type, name):\n        \"\"\"Initialisiere Komponente mit eindeutiger ID und Typ.\"\"\"\n\n    def initialize(self, initial_state):\n        \"\"\"Setze initialen Zustand vor der Simulation.\"\"\"\n\n    def step(self, t, dt, inputs):\n        \"\"\"F\u00fchre einen Simulationszeitschritt aus.\"\"\"\n\n    def to_dict(self):\n        \"\"\"Serialisiere zu Dictionary f\u00fcr JSON-Export.\"\"\"\n\n    @classmethod\n    def from_dict(cls, config):\n        \"\"\"Erstelle Komponente aus Konfigurations-Dictionary.\"\"\"\n</code></pre>"},{"location":"user_guide/components/#komponentenlebenszyklus","title":"Komponentenlebenszyklus","text":"<pre><code>Erstellen \u2192 Initialisieren \u2192 Simulieren (step-Schleife) \u2192 Speichern/Exportieren\n   \u2193                            \u2191\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        (kann reinitialisiert werden)\n</code></pre>"},{"location":"user_guide/components/#komponentenubersicht","title":"Komponenten\u00fcbersicht","text":"<p>PyADM1 bietet verschiedene Komponentenkategorien:</p>"},{"location":"user_guide/components/#biologische-komponenten","title":"Biologische Komponenten","text":"<p>Komponenten f\u00fcr biologische Umwandlungsprozesse:</p> <ul> <li>Digester: Hauptfermenter mit ADM1-Modell f\u00fcr anaerobe Verg\u00e4rung</li> <li>Hydrolysis: Vorbehandlungstank f\u00fcr Hydrolyseprozesse</li> <li>Separator: Fest-Fl\u00fcssig-Trennung f\u00fcr G\u00e4rrestaufbereitung</li> </ul>"},{"location":"user_guide/components/#energiekomponenten","title":"Energiekomponenten","text":"<p>Komponenten f\u00fcr Energieerzeugung und -speicherung:</p> <ul> <li>CHP: Blockheizkraftwerk zur Strom- und W\u00e4rmeerzeugung</li> <li>Heating: Heizsystem zur Temperaturkontrolle</li> <li>GasStorage: Biogasspeicher mit Druckmanagement</li> <li>Flare: Sicherheitsfackel f\u00fcr \u00dcberschussgas</li> </ul>"},{"location":"user_guide/components/#mechanische-komponenten","title":"Mechanische Komponenten","text":"<p>Mechanische Anlagenkomponenten:</p> <ul> <li>Pump: Pumpen f\u00fcr Substratf\u00f6rderung und Rezirkulation</li> <li>Mixer: R\u00fchrwerke zur Homogenisierung im Fermenter</li> </ul>"},{"location":"user_guide/components/#futterungskomponenten","title":"F\u00fctterungskomponenten","text":"<p>Substrathandhabung und -dosierung:</p> <ul> <li>SubstrateStorage: Substratlagerbeh\u00e4lter mit Qualit\u00e4tsverfolgung</li> <li>Feeder: Automatische Dosiersysteme</li> </ul>"},{"location":"user_guide/components/#sensoren","title":"Sensoren","text":"<p>Mess- und \u00dcberwachungskomponenten (in Entwicklung)</p>"},{"location":"user_guide/components/#verbindungstypen","title":"Verbindungstypen","text":""},{"location":"user_guide/components/#flussigkeitsverbindungen","title":"Fl\u00fcssigkeitsverbindungen","text":"<p>\u00dcbertragen G\u00e4rrest zwischen Fermentern:</p> <pre><code>configurator.connect(\"digester_1\", \"digester_2\", \"liquid\")\n</code></pre> <p>Daten\u00fcbertragung: - <code>Q_out</code>: Fl\u00fcssigkeitsdurchfluss [m\u00b3/d] - <code>state_out</code>: Vollst\u00e4ndiger ADM1-Zustandsvektor</p>"},{"location":"user_guide/components/#gasverbindungen","title":"Gasverbindungen","text":"<p>\u00dcbertragen Biogas vom Speicher zum BHKW:</p> <pre><code>configurator.connect(\"digester_1_storage\", \"chp_1\", \"gas\")\n</code></pre> <p>Daten\u00fcbertragung: - <code>Q_gas_supplied_m3_per_day</code>: Verf\u00fcgbares Gas [m\u00b3/d] - Gaszusammensetzung (CH4%, CO2%)</p>"},{"location":"user_guide/components/#warmeverbindungen","title":"W\u00e4rmeverbindungen","text":"<p>\u00dcbertragen Abw\u00e4rme vom BHKW zur Heizung:</p> <pre><code>configurator.connect(\"chp_1\", \"heating_1\", \"heat\")\n</code></pre> <p>Daten\u00fcbertragung: - <code>P_th</code>: Verf\u00fcgbare thermische Leistung [kW] - Temperaturniveaus</p>"},{"location":"user_guide/components/#auto-verbindungshelfer","title":"Auto-Verbindungshelfer","text":"<pre><code># Automatisches Gas-Routing: Fermenter \u2192 Speicher \u2192 BHKW \u2192 Fackel\nconfigurator.auto_connect_digester_to_chp(\"dig1\", \"chp1\")\n\n# Automatisches W\u00e4rme-Routing: BHKW \u2192 Heizung\nconfigurator.auto_connect_chp_to_heating(\"chp1\", \"heat1\")\n</code></pre>"},{"location":"user_guide/components/#komponentenmuster","title":"Komponentenmuster","text":""},{"location":"user_guide/components/#muster-1-einstufige-anlage","title":"Muster 1: Einstufige Anlage","text":"<pre><code>configurator.add_digester(\"dig1\", V_liq=2000, Q_substrates=[15,10,0,0,0,0,0,0,0,0])\nconfigurator.add_chp(\"chp1\", P_el_nom=500)\nconfigurator.add_heating(\"heat1\", target_temperature=308.15)\n\nconfigurator.auto_connect_digester_to_chp(\"dig1\", \"chp1\")\nconfigurator.auto_connect_chp_to_heating(\"chp1\", \"heat1\")\n</code></pre> <p>Topologie: <pre><code>[Fermenter] \u2192 [Gasspeicher] \u2192 [BHKW] \u2192 [Fackel]\n                                 \u2193\n                             [Heizung]\n</code></pre></p>"},{"location":"user_guide/components/#muster-2-zweistufige-reihe","title":"Muster 2: Zweistufige Reihe","text":"<pre><code># Stufe 1: Hydrolyse (thermophil)\nconfigurator.add_digester(\"hydro\", V_liq=500, T_ad=318.15,\n                         Q_substrates=[15,10,0,0,0,0,0,0,0,0])\n\n# Stufe 2: Methanogenese (mesophil)\nconfigurator.add_digester(\"main\", V_liq=2000, T_ad=308.15,\n                         Q_substrates=[0,0,0,0,0,0,0,0,0,0])\n\n# Verbinde Fl\u00fcssigkeitsstrom\nconfigurator.connect(\"hydro\", \"main\", \"liquid\")\n\n# Einzelnes BHKW f\u00fcr beide\nconfigurator.add_chp(\"chp1\", P_el_nom=500)\nconfigurator.auto_connect_digester_to_chp(\"hydro\", \"chp1\")\nconfigurator.auto_connect_digester_to_chp(\"main\", \"chp1\")\n\n# Separate Heizung f\u00fcr jede Stufe\nconfigurator.add_heating(\"heat1\", target_temperature=318.15)\nconfigurator.add_heating(\"heat2\", target_temperature=308.15)\nconfigurator.auto_connect_chp_to_heating(\"chp1\", \"heat1\")\nconfigurator.auto_connect_chp_to_heating(\"chp1\", \"heat2\")\n</code></pre> <p>Topologie: <pre><code>[Hydrolyse] \u2192 [Speicher] \u2198\n                          \u2192 [BHKW] \u2192 [Heizung 1]\n[Haupt] \u2192 [Speicher] \u2197         \u2193\n                            [Heizung 2]\n</code></pre></p>"},{"location":"user_guide/components/#muster-3-parallele-fermenter","title":"Muster 3: Parallele Fermenter","text":"<pre><code># Mehrere Fermenter speisen ein BHKW\nfor i in range(3):\n    configurator.add_digester(\n        f\"dig{i+1}\",\n        V_liq=1000,\n        Q_substrates=[10, 5, 0, 0, 0, 0, 0, 0, 0, 0]\n    )\n\nconfigurator.add_chp(\"chp1\", P_el_nom=1000)\n\nfor i in range(3):\n    configurator.auto_connect_digester_to_chp(f\"dig{i+1}\", \"chp1\")\n</code></pre>"},{"location":"user_guide/components/#vollstandiges-integrationsbeispiel","title":"Vollst\u00e4ndiges Integrationsbeispiel","text":""},{"location":"user_guide/components/#komplette-futterungskette","title":"Komplette F\u00fctterungskette","text":"<pre><code>from pyadm1.configurator import BiogasPlant, PlantConfigurator\nfrom pyadm1.components.feeding import SubstrateStorage, Feeder\nfrom pyadm1.components.mechanical import Pump, Mixer\nfrom pyadm1.substrates import Feedstock\n\n# Setup\nfeedstock = Feedstock(feeding_freq=48)\nplant = BiogasPlant(\"Komplette Anlage\")\nconfig = PlantConfigurator(plant, feedstock)\n\n# 1. Substratspeicher\nstorage = SubstrateStorage(\n    \"silo1\",\n    storage_type=\"vertical_silo\",\n    substrate_type=\"corn_silage\",\n    capacity=1000,\n    initial_level=800\n)\nplant.add_component(storage)\n\n# 2. Dosierer\nfeeder = Feeder(\n    \"feed1\",\n    feeder_type=\"screw\",\n    Q_max=20.0,\n    substrate_type=\"solid\"\n)\nplant.add_component(feeder)\n\n# 3. F\u00f6rderpumpe\npump = Pump(\n    \"pump1\",\n    pump_type=\"progressive_cavity\",\n    Q_nom=15.0,\n    pressure_head=50.0\n)\nplant.add_component(pump)\n\n# 4. Fermenter\ndigester, _ = config.add_digester(\n    \"main_digester\",\n    V_liq=2000,\n    Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n)\n\n# 5. R\u00fchrwerk\nmixer = Mixer(\n    \"mix1\",\n    mixer_type=\"propeller\",\n    tank_volume=2000,\n    mixing_intensity=\"medium\",\n    intermittent=True,\n    on_time_fraction=0.25\n)\nplant.add_component(mixer)\n\n# 6. BHKW und Heizung\nconfig.add_chp(\"chp1\", P_el_nom=500)\nconfig.add_heating(\"heat1\", target_temperature=308.15)\n\n# Komponenten verbinden\nconfig.connect(\"silo1\", \"feed1\", \"default\")\nconfig.connect(\"feed1\", \"pump1\", \"default\")\nconfig.connect(\"pump1\", \"main_digester\", \"liquid\")\nconfig.auto_connect_digester_to_chp(\"main_digester\", \"chp1\")\nconfig.auto_connect_chp_to_heating(\"chp1\", \"heat1\")\n\n# Initialisieren und simulieren\nplant.initialize()\nresults = plant.simulate(duration=30, dt=1/24, save_interval=1.0)\n\n# Ergebnisse analysieren\nfinal = results[-1]\nprint(\"\\nEndergebnisse:\")\nprint(f\"Speicherstand: {final['components']['silo1']['current_level']:.1f} t\")\nprint(f\"Dosierer-Durchsatz: {final['components']['feed1']['total_mass_fed']:.1f} t\")\nprint(f\"Pumpenenergie: {final['components']['pump1']['energy_consumed']:.1f} kWh\")\nprint(f\"R\u00fchrwerkenergie: {final['components']['mix1']['energy_consumed']:.1f} kWh\")\nprint(f\"Biogas: {final['components']['main_digester']['Q_gas']:.1f} m\u00b3/d\")\n</code></pre>"},{"location":"user_guide/components/#energieanalyse","title":"Energieanalyse","text":"<pre><code>def calculate_parasitic_load(results):\n    \"\"\"Berechne gesamten parasit\u00e4ren Energieverbrauch\"\"\"\n    final = results[-1]\n    components = final['components']\n\n    # Mechanische Komponenten\n    pump_energy = components.get('pump1', {}).get('energy_consumed', 0)\n    mixer_energy = components.get('mix1', {}).get('energy_consumed', 0)\n    feeder_power = components.get('feed1', {}).get('P_consumed', 0)\n\n    # BHKW-Produktion\n    chp_energy = components.get('chp1', {}).get('P_el', 0) * 30 * 24  # kWh\n\n    parasitic_total = pump_energy + mixer_energy\n    parasitic_fraction = parasitic_total / chp_energy\n\n    return {\n        'pump_energy': pump_energy,\n        'mixer_energy': mixer_energy,\n        'total_parasitic': parasitic_total,\n        'chp_production': chp_energy,\n        'parasitic_fraction': parasitic_fraction,\n        'net_energy': chp_energy - parasitic_total\n    }\n\nanalysis = calculate_parasitic_load(results)\nprint(f\"\\nEnergieanalyse:\")\nprint(f\"BHKW-Produktion: {analysis['chp_production']:.0f} kWh\")\nprint(f\"Pumpenverbrauch: {analysis['pump_energy']:.0f} kWh\")\nprint(f\"R\u00fchrwerkverbrauch: {analysis['mixer_energy']:.0f} kWh\")\nprint(f\"Parasit\u00e4re Last: {analysis['parasitic_fraction']:.1%}\")\nprint(f\"Nettoproduktion: {analysis['net_energy']:.0f} kWh\")\n</code></pre>"},{"location":"user_guide/components/#fehlerbehebung","title":"Fehlerbehebung","text":""},{"location":"user_guide/components/#haufige-probleme","title":"H\u00e4ufige Probleme","text":"<p>Problem: Pumpe liefert keinen Durchfluss</p> <p>L\u00f6sung: Pr\u00fcfe Druckh\u00f6he und Drehzahleinstellungen <pre><code>result = pump.step(0, 1/24, {\n    'Q_setpoint': 15.0,\n    'enable_pump': True,\n    'pressure_head': 50.0  # Stelle ausreichende Druckh\u00f6he sicher\n})\n\nif result['Q_actual'] &lt; 0.5 * result['Q_setpoint']:\n    print(\"Pr\u00fcfe: Druckh\u00f6he, Blockaden, Stromversorgung\")\n</code></pre></p> <p>Problem: R\u00fchrwerk verbraucht zu viel Energie</p> <p>L\u00f6sung: Nutze intermittierenden Betrieb <pre><code># Anstelle von kontinuierlich (360 kWh/Tag):\nmixer_continuous = Mixer(\"mix1\", intermittent=False)\n\n# Nutze intermittierend (90 kWh/Tag):\nmixer_optimal = Mixer(\n    \"mix1\",\n    intermittent=True,\n    on_time_fraction=0.25  # 75% Energieeinsparung\n)\n</code></pre></p> <p>Problem: Dosierer-Genauigkeit zu niedrig</p> <p>L\u00f6sung: Nutze pr\u00e4ziseren Dosierertyp oder deaktiviere Rauschen <pre><code># Weniger pr\u00e4zise: Schnecke (\u00b15%)\nfeeder_screw = Feeder(\"feed1\", feeder_type=\"screw\")\n\n# Pr\u00e4ziser: Kolben (\u00b11%)\nfeeder_piston = Feeder(\"feed1\", feeder_type=\"piston\")\n\n# Oder deaktiviere realistisches Rauschen f\u00fcr idealisierte Simulation\nfeeder_ideal = Feeder(\n    \"feed1\",\n    feeder_type=\"screw\",\n    enable_dosing_noise=False\n)\n</code></pre></p> <p>Problem: Lagerqualit\u00e4t verschlechtert sich zu schnell</p> <p>L\u00f6sung: Pr\u00fcfe Temperatur und Lagertyp <pre><code># Schlecht: Miete bei 20\u00b0C\nstorage_poor = SubstrateStorage(\n    \"clamp1\",\n    storage_type=\"clamp\",        # Hohe Degradation\n    temperature=293.15           # Warm\n)\n# Degradation: ~0.003/d \u2192 91% Qualit\u00e4t nach 30 Tagen\n\n# Besser: Silo bei 15\u00b0C\nstorage_good = SubstrateStorage(\n    \"silo1\",\n    storage_type=\"vertical_silo\", # Niedrige Degradation\n    temperature=288.15            # K\u00fchl\n)\n# Degradation: ~0.0005/d \u2192 98.5% Qualit\u00e4t nach 30 Tagen\n</code></pre></p>"},{"location":"user_guide/components/#komponenten-ubersichtstabelle","title":"Komponenten-\u00dcbersichtstabelle","text":"Komponente Zweck Hauptparameter Typische Leistung Hinweise Pump Materialtransfer Q_nom, pressure_head 2-10 kW Dimensionierung f\u00fcr 80-90% max. Durchfluss Mixer Homogenisierung mixing_intensity, on_time 5-20 kW Nutze intermittierend (25% Einschaltzeit) Storage Substratlagerung capacity, storage_type 0 kW \u00dcberwache Qualit\u00e4tsverschlechterung Feeder Dosierung Q_max, feeder_type 1-5 kW Aktiviere Dosierrauschen f\u00fcr Realismus"},{"location":"user_guide/components/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Beispiele: Siehe detaillierte Komponentenguides f\u00fcr vollst\u00e4ndige Implementierungen</li> <li>Optimierung: Nutze Parameterstudien zur Optimierung der Komponentendimensionierung</li> <li>API-Referenz: Siehe detaillierte Klassendokumentation f\u00fcr erweiterte Funktionen</li> </ul>"},{"location":"user_guide/components/#weiterfuhrende-dokumentation","title":"Weiterf\u00fchrende Dokumentation","text":"<ul> <li>Biologische Komponenten</li> <li>Energiekomponenten</li> <li>Mechanische Komponenten</li> <li>F\u00fctterungskomponenten</li> <li>Sensoren</li> </ul>"},{"location":"user_guide/components/biological/","title":"Biologische Komponenten","text":"<p>Komponenten f\u00fcr biologische Umwandlungsprozesse in Biogasanlagen.</p>"},{"location":"user_guide/components/biological/#digester","title":"Digester","text":"<p>Der Hauptfermenter, der das ADM1-Modell f\u00fcr anaerobe Verg\u00e4rung implementiert.</p>"},{"location":"user_guide/components/biological/#parameter","title":"Parameter","text":"<pre><code>from pyadm1.configurator.plant_configurator import PlantConfigurator\n\nconfigurator.add_digester(\n    digester_id=\"main_digester\",      # Eindeutige Kennung\n    V_liq=2000.0,                     # Fl\u00fcssigvolumen [m\u00b3]\n    V_gas=300.0,                      # Gasraum [m\u00b3]\n    T_ad=308.15,                      # Betriebstemperatur [K]\n    name=\"Hauptfermenter\",            # Lesbarer Name\n    load_initial_state=True,          # Lade Steady-State-Initialisierung\n    initial_state_file=None,          # Benutzerdefinierter Anfangszustand CSV (optional)\n    Q_substrates=[15, 10, 0, ...]    # Substrat-F\u00fctterungsraten [m\u00b3/d]\n)\n</code></pre>"},{"location":"user_guide/components/biological/#dimensionierungsrichtlinien","title":"Dimensionierungsrichtlinien","text":"Anlagengr\u00f6\u00dfe V_liq [m\u00b3] V_gas [m\u00b3] F\u00fctterungsrate [m\u00b3/d] HRT [Tage] Klein 300-800 50-120 10-25 20-40 Mittel 1000-3000 150-450 25-75 25-45 Gro\u00df 3000-8000 450-1200 75-200 30-50"},{"location":"user_guide/components/biological/#temperaturoptionen","title":"Temperaturoptionen","text":"<pre><code># Psychrophil (selten in der Praxis)\nT_psychro = 298.15  # 25\u00b0C\n\n# Mesophil (am h\u00e4ufigsten)\nT_meso = 308.15     # 35\u00b0C\n\n# Thermophil (faserreiche Substrate)\nT_thermo = 328.15   # 55\u00b0C\n</code></pre>"},{"location":"user_guide/components/biological/#ausgaben","title":"Ausgaben","text":"<pre><code>outputs = digester.step(t, dt, inputs)\n# R\u00fcckgabe:\n{\n    'Q_out': 25.0,              # Auslaufdurchfluss [m\u00b3/d]\n    'state_out': [...],         # ADM1-Zustand f\u00fcr n\u00e4chsten Fermenter\n    'Q_gas': 1250.5,           # Biogasproduktion [m\u00b3/d]\n    'Q_ch4': 750.3,            # Methanproduktion [m\u00b3/d]\n    'Q_co2': 475.2,            # CO2-Produktion [m\u00b3/d]\n    'pH': 7.32,                # pH-Wert\n    'VFA': 2.45,               # Fl\u00fcchtige Fetts\u00e4uren [g/L]\n    'TAC': 8.50,               # Gesamtalkalinit\u00e4t [g CaCO3/L]\n    'gas_storage': {           # Angeschlossene Gasspeicherinfo\n        'stored_volume_m3': 150.0,\n        'pressure_bar': 1.02,\n        'vented_volume_m3': 0.0\n    }\n}\n</code></pre>"},{"location":"user_guide/components/biological/#erweiterte-verwendung","title":"Erweiterte Verwendung","text":"<p>Mehrere Fermenter in Reihe: <pre><code># Hydrolyse + Methanogenese\nconfigurator.add_digester(\"hydro\", V_liq=500, T_ad=318.15,\n                         Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0])\nconfigurator.add_digester(\"main\", V_liq=2000, T_ad=308.15,\n                         Q_substrates=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\nconfigurator.connect(\"hydro\", \"main\", \"liquid\")\n</code></pre></p> <p>Benutzerdefinierter Anfangszustand: <pre><code>import pandas as pd\n\n# Erstelle benutzerdefinierten Zustand\ninitial = pd.DataFrame({\n    'S_su': [0.01], 'S_aa': [0.001], # ... alle 37 Zustandsvariablen\n})\ninitial.to_csv('custom_state.csv', index=False)\n\n# Verwende im Fermenter\nconfigurator.add_digester(\n    \"dig1\", V_liq=2000,\n    initial_state_file='custom_state.csv'\n)\n</code></pre></p>"},{"location":"user_guide/components/biological/#kalibrierungsparameter","title":"Kalibrierungsparameter","text":"<p>Der Fermenter unterst\u00fctzt die Anwendung von Kalibrierungsparametern zur Modellanpassung:</p> <pre><code>from pyadm1.components.biological import Digester\n\ndigester = Digester(\"dig1\", feedstock, V_liq=2000)\n\n# Kalibrierungsparameter anwenden\ndigester.apply_calibration_parameters({\n    'k_dis': 0.55,      # Desintegrationsrate\n    'Y_su': 0.105,      # Ertragskoeffizient f\u00fcr Zucker\n    'k_hyd_ch': 11.0    # Hydrolyserate f\u00fcr Kohlenhydrate\n})\n\n# Aktuelle Parameter abrufen\nparams = digester.get_calibration_parameters()\nprint(params)\n\n# Parameter l\u00f6schen (zur\u00fcck zu Standardwerten)\ndigester.clear_calibration_parameters()\n</code></pre>"},{"location":"user_guide/components/biological/#hydrolysis","title":"Hydrolysis","text":"<p>Vorbehandlungstank f\u00fcr hydrolysedominierte Prozesse (Stub f\u00fcr zuk\u00fcnftige Implementierung).</p> <pre><code>from pyadm1.components.biological import Hydrolysis\n\nhydrolysis = Hydrolysis(\n    component_id=\"hydro1\",\n    feedstock=feedstock,\n    V_liq=500.0,\n    T_ad=318.15  # H\u00f6here Temperatur f\u00fcr schnellere Hydrolyse\n)\n</code></pre> <p>Anwendung: N\u00fctzlich f\u00fcr Substrate mit hohem lignozellulosem Gehalt, kann bei anderen Temperaturen und Verweilzeiten als der Hauptfermenter betrieben werden.</p>"},{"location":"user_guide/components/biological/#separator","title":"Separator","text":"<p>Fest-Fl\u00fcssig-Trennung f\u00fcr G\u00e4rrestverarbeitung (Stub f\u00fcr zuk\u00fcnftige Implementierung).</p> <pre><code>from pyadm1.components.biological import Separator\n\nseparator = Separator(\n    component_id=\"sep1\",\n    separation_efficiency=0.95  # 95% Feststoffabtrennung\n)\n</code></pre> <p>Anwendung: Modelliert mechanische (Schneckenpresse, Zentrifuge) oder Schwerkrafttrennung mit konfigurierbarer Trenneffizienz.</p>"},{"location":"user_guide/components/biological/#beispiel-zweistufiges-vergarungssystem","title":"Beispiel: Zweistufiges Verg\u00e4rungssystem","text":"<pre><code>from pyadm1.configurator import BiogasPlant, PlantConfigurator\nfrom pyadm1.substrates import Feedstock\n\n# Setup\nfeedstock = Feedstock(feeding_freq=48)\nplant = BiogasPlant(\"Zweistufige Anlage\")\nconfig = PlantConfigurator(plant, feedstock)\n\n# Stufe 1: Thermophile Hydrolyse\nhydro, hydro_storage = config.add_digester(\n    \"hydrolysis\",\n    V_liq=500,\n    V_gas=75,\n    T_ad=328.15,  # 55\u00b0C\n    Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n)\n\n# Stufe 2: Mesophile Methanogenese\nmain, main_storage = config.add_digester(\n    \"methanogenesis\",\n    V_liq=2000,\n    V_gas=300,\n    T_ad=308.15,  # 35\u00b0C\n    Q_substrates=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  # Nur Input aus Stufe 1\n)\n\n# Verbinde Fermenter\nconfig.connect(\"hydrolysis\", \"methanogenesis\", \"liquid\")\n\n# Energiesystem\nconfig.add_chp(\"chp1\", P_el_nom=500)\nconfig.add_heating(\"heat_hydro\", target_temperature=328.15, heat_loss_coefficient=0.3)\nconfig.add_heating(\"heat_main\", target_temperature=308.15, heat_loss_coefficient=0.5)\n\n# Auto-Verbindungen\nconfig.auto_connect_digester_to_chp(\"hydrolysis\", \"chp1\")\nconfig.auto_connect_digester_to_chp(\"methanogenesis\", \"chp1\")\nconfig.auto_connect_chp_to_heating(\"chp1\", \"heat_hydro\")\nconfig.auto_connect_chp_to_heating(\"chp1\", \"heat_main\")\n\n# Simulieren\nplant.initialize()\nresults = plant.simulate(duration=100, dt=1/24, save_interval=1.0)\n\n# Ergebnisse analysieren\nfinal = results[-1]\nprint(f\"Hydrolyse-Biogas: {final['components']['hydrolysis']['Q_gas']:.1f} m\u00b3/d\")\nprint(f\"Haupt-Biogas: {final['components']['methanogenesis']['Q_gas']:.1f} m\u00b3/d\")\nprint(f\"Gesamt-Methan: {final['components']['hydrolysis']['Q_ch4'] + final['components']['methanogenesis']['Q_ch4']:.1f} m\u00b3/d\")\nprint(f\"pH Hydrolyse: {final['components']['hydrolysis']['pH']:.2f}\")\nprint(f\"pH Haupt: {final['components']['methanogenesis']['pH']:.2f}\")\n</code></pre>"},{"location":"user_guide/components/biological/#prozessuberwachung","title":"Prozess\u00fcberwachung","text":""},{"location":"user_guide/components/biological/#wichtige-prozessindikatoren","title":"Wichtige Prozessindikatoren","text":"<pre><code>def monitor_digester_health(results):\n    \"\"\"\u00dcberwache Fermentergesundheit anhand von Prozessindikatoren\"\"\"\n\n    for result in results:\n        digester_data = result['components']['main_digester']\n\n        # pH-Wert pr\u00fcfen\n        pH = digester_data['pH']\n        if pH &lt; 6.8:\n            print(f\"Warnung: Niedriger pH ({pH:.2f}) - \u00dcbers\u00e4uerungsrisiko\")\n        elif pH &gt; 8.0:\n            print(f\"Warnung: Hoher pH ({pH:.2f}) - M\u00f6gliche Ammoniakinhibition\")\n\n        # VFA/TAC-Verh\u00e4ltnis\n        VFA = digester_data['VFA']  # g HAc-eq/L\n        TAC = digester_data['TAC']  # g CaCO3-eq/L\n\n        # Umrechnung f\u00fcr VFA/TAC-Verh\u00e4ltnis\n        VFA_TAC = VFA / TAC if TAC &gt; 0 else 0\n\n        if VFA_TAC &gt; 0.4:\n            print(f\"Warnung: Hohes VFA/TAC-Verh\u00e4ltnis ({VFA_TAC:.2f}) - Prozessinstabilit\u00e4t\")\n\n        # Gasproduktion\n        Q_gas = digester_data['Q_gas']\n        if Q_gas &lt; 500:  # Beispielschwelle\n            print(f\"Warnung: Niedrige Gasproduktion ({Q_gas:.1f} m\u00b3/d)\")\n\nmonitor_digester_health(results)\n</code></pre>"},{"location":"user_guide/components/biological/#optimale-betriebsbereiche","title":"Optimale Betriebsbereiche","text":"Parameter Optimal Akzeptabel Kritisch pH 7.0-7.5 6.8-8.0 &lt;6.8 oder &gt;8.0 VFA [g/L] 0.5-2.0 2.0-4.0 &gt;4.0 VFA/TAC 0.2-0.3 0.3-0.4 &gt;0.4 TAC [g CaCO3/L] 5.0-10.0 4.0-12.0 &lt;4.0 Temp. mesophil [\u00b0C] 35-38 32-40 &lt;30 oder &gt;42 Temp. thermophil [\u00b0C] 52-55 48-58 &lt;45 oder &gt;60"},{"location":"user_guide/components/biological/#fehlerbehebung","title":"Fehlerbehebung","text":""},{"location":"user_guide/components/biological/#niedriger-ph-wert","title":"Niedriger pH-Wert","text":"<p>Ursachen: - Zu hohe organische Raumbelastung (OLR) - Unzureichende Pufferkapazit\u00e4t - Pl\u00f6tzliche Substrat\u00e4nderung</p> <p>L\u00f6sungen: <pre><code># Reduziere organische Belastung\nQ = [10, 8, 0, 0, 0, 0, 0, 0, 0, 0]  # Reduziert von [15, 10, ...]\n\n# Oder f\u00fcge Kalkpuffer hinzu\nQ = [15, 10, 0, 0, 0, 0, 0, 1, 0, 0]  # 1 m\u00b3/d Kalk\n</code></pre></p>"},{"location":"user_guide/components/biological/#schaumbildung","title":"Schaumbildung","text":"<p>Ursachen: - Zu hoher Proteingehalt im Substrat - Pl\u00f6tzliche pH-\u00c4nderungen - Hohe VFA-Konzentrationen</p> <p>L\u00f6sungen: - Reduziere proteinreiche Substrate - Stabilisiere pH-Wert durch Pufferung - Implementiere Anti-Schaum-Ma\u00dfnahmen</p>"},{"location":"user_guide/components/biological/#geringe-gasproduktion","title":"Geringe Gasproduktion","text":"<p>Ursachen: - Niedrige organische Belastung - Substrat niedriger Qualit\u00e4t - Inhibition (NH3, H2S, Schwermetalle) - Zu kurze Verweilzeit</p> <p>Diagnose: <pre><code>def diagnose_low_gas_production(digester_outputs):\n    \"\"\"Diagnostiziere Ursachen f\u00fcr niedrige Gasproduktion\"\"\"\n\n    Q_gas = digester_outputs['Q_gas']\n    Q_in = sum(Q_substrates)  # Gesamter Input\n\n    # Spezifische Gasproduktion\n    specific_gas = Q_gas / Q_in if Q_in &gt; 0 else 0\n\n    if specific_gas &lt; 0.5:  # m\u00b3 Biogas / m\u00b3 Input\n        print(\"Niedrige spezifische Gasausbeute - m\u00f6gliche Ursachen:\")\n        print(\"- Substrat niedriger Qualit\u00e4t\")\n        print(\"- Inhibition\")\n        print(\"- Prozessinstabilit\u00e4t\")\n\n    # Pr\u00fcfe Methangehalt\n    CH4_content = digester_outputs['Q_ch4'] / Q_gas if Q_gas &gt; 0 else 0\n\n    if CH4_content &lt; 0.55:\n        print(f\"Niedriger Methangehalt ({CH4_content:.1%}) - m\u00f6gliche Lufteintr\u00e4ge oder CO2-Stripping\")\n\ndiagnose_low_gas_production(digester.outputs_data)\n</code></pre></p>"},{"location":"user_guide/components/biological/#best-practices","title":"Best Practices","text":"<ol> <li>Starten Sie mit realistischen Betriebsparametern</li> <li>Nutze typische HRT-Werte (30-40 Tage)</li> <li> <p>Beginne mit moderater OLR (2-4 kg VS/m\u00b3/d)</p> </li> <li> <p>\u00dcberwache kritische Parameter</p> </li> <li>pH-Wert sollte stabil sein (\u00b10.2)</li> <li>VFA/TAC-Verh\u00e4ltnis &lt; 0.4</li> <li> <p>Methangehalt &gt; 55%</p> </li> <li> <p>Implementiere Puffersysteme</p> </li> <li>F\u00fcge Kalk oder andere Puffer bei niedrigem pH hinzu</li> <li> <p>Halte TAC &gt; 4 g CaCO3/L</p> </li> <li> <p>Nutze zweistufige Systeme f\u00fcr schwierige Substrate</p> </li> <li>Thermophile Hydrolyse f\u00fcr faserreiche Substrate</li> <li> <p>Mesophile Methanogenese f\u00fcr stabile Gasproduktion</p> </li> <li> <p>Kalibriere das Modell mit realen Daten</p> </li> <li>Nutze Kalibrierungsparameter f\u00fcr genauere Vorhersagen</li> <li>Validiere mit Betriebsdaten</li> </ol>"},{"location":"user_guide/components/biological/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Energiekomponenten: BHKW und W\u00e4rmesysteme</li> <li>Mechanische Komponenten: Pumpen und R\u00fchrwerke</li> <li>F\u00fctterungskomponenten: Lagerung und Dosierung</li> <li>API-Referenz: Detaillierte Klassendokumentation</li> </ul>"},{"location":"user_guide/components/energy/","title":"Energiekomponenten","text":"<p>Komponenten f\u00fcr Energieerzeugung, -umwandlung und -speicherung in Biogasanlagen.</p>"},{"location":"user_guide/components/energy/#chp-combined-heat-and-power","title":"CHP (Combined Heat and Power)","text":"<p>Blockheizkraftwerk zur Umwandlung von Biogas in Strom und W\u00e4rme.</p>"},{"location":"user_guide/components/energy/#parameter","title":"Parameter","text":"<pre><code>configurator.add_chp(\n    chp_id=\"chp_main\",\n    P_el_nom=500.0,        # Elektrische Nennleistung [kW]\n    eta_el=0.40,           # Elektrischer Wirkungsgrad (40%)\n    eta_th=0.45,           # Thermischer Wirkungsgrad (45%)\n    name=\"Haupt-BHKW\"\n)\n</code></pre>"},{"location":"user_guide/components/energy/#typische-bhkw-spezifikationen","title":"Typische BHKW-Spezifikationen","text":"Typ Gr\u00f6\u00dfe [kW_el] \u03b7_el \u03b7_th Gasbedarf [m\u00b3/d @ 60% CH4] Klein 100-250 0.38 0.48 600-1500 Mittel 250-750 0.40 0.45 1500-4500 Gro\u00df 750-2000 0.42 0.43 4500-12000"},{"location":"user_guide/components/energy/#technologieoptionen","title":"Technologieoptionen","text":"<pre><code># Gasmotor (am h\u00e4ufigsten)\nchp_engine = configurator.add_chp(\n    \"chp1\", P_el_nom=500, eta_el=0.40, eta_th=0.45\n)\n\n# Mikroturbine (100-500 kW)\nchp_turbine = configurator.add_chp(\n    \"chp2\", P_el_nom=250, eta_el=0.30, eta_th=0.55\n)\n\n# Hocheffizient (&gt;1 MW)\nchp_large = configurator.add_chp(\n    \"chp3\", P_el_nom=1500, eta_el=0.42, eta_th=0.43\n)\n</code></pre>"},{"location":"user_guide/components/energy/#ausgaben","title":"Ausgaben","text":"<pre><code>{\n    'P_el': 450.0,              # Elektrische Leistung [kW]\n    'P_th': 506.3,              # Thermische Leistung [kW]\n    'Q_gas_consumed': 2700.0,   # Gasverbrauch [m\u00b3/d]\n    'load_factor': 0.90         # Betriebspunkt (0-1)\n}\n</code></pre>"},{"location":"user_guide/components/energy/#erweiterte-bhkw-steuerung","title":"Erweiterte BHKW-Steuerung","text":"<pre><code># Variable Laststeuerung\ninputs = {\n    'Q_ch4': 800.0,           # Verf\u00fcgbares Methan [m\u00b3/d]\n    'load_setpoint': 0.75     # Betrieb bei 75% Kapazit\u00e4t\n}\nresult = chp.step(t, dt, inputs)\n</code></pre>"},{"location":"user_guide/components/energy/#leistungsberechnung","title":"Leistungsberechnung","text":"<p>BHKW berechnen Leistung basierend auf verf\u00fcgbarem Methan:</p> <pre><code># Methan-Energieinhalt: ~10 kWh/m\u00b3\nE_ch4 = 10.0  # kWh/m\u00b3\n\n# Verf\u00fcgbare Leistung aus Methan\nP_available = Q_ch4_available / 24.0 * E_ch4  # kW\n\n# Elektrische Leistung\nP_el = min(P_el_nom, P_available * eta_el)\n\n# Thermische Leistung\nP_th = P_el * eta_th / eta_el\n\n# Gasverbrauch\nQ_ch4_consumed = P_el / eta_el * 24.0 / E_ch4  # m\u00b3/d\n</code></pre>"},{"location":"user_guide/components/energy/#heizsystem","title":"Heizsystem","text":"<p>H\u00e4lt Fermentertemperatur mittels BHKW-Abw\u00e4rme und Zusatzheizung.</p>"},{"location":"user_guide/components/energy/#parameter_1","title":"Parameter","text":"<pre><code>configurator.add_heating(\n    heating_id=\"heating_main\",\n    target_temperature=308.15,      # Zieltemperatur [K]\n    heat_loss_coefficient=0.5,      # W\u00e4rmeverlustkoeffizient [kW/K]\n    name=\"Hauptfermenter-Heizung\"\n)\n</code></pre>"},{"location":"user_guide/components/energy/#warmeverlustkoeffizienten","title":"W\u00e4rmeverlustkoeffizienten","text":"Isolierung k [kW/K] Beschreibung Ausgezeichnet 0.3-0.4 Modern, gut isoliert Gut 0.4-0.6 Standard-Isolierung Schlecht 0.6-1.0 Alt oder minimale Isolierung"},{"location":"user_guide/components/energy/#ausgaben_1","title":"Ausgaben","text":"<pre><code>{\n    'Q_heat_supplied': 125.5,    # Gesamt bereitgestellte W\u00e4rme [kW]\n    'P_th_used': 110.0,          # Genutzte BHKW-W\u00e4rme [kW]\n    'P_aux_heat': 15.5           # Ben\u00f6tigte Zusatzheizung [kW]\n}\n</code></pre>"},{"location":"user_guide/components/energy/#warmebedarfsberechnung","title":"W\u00e4rmebedarfsberechnung","text":"<pre><code># W\u00e4rmebedarf = W\u00e4rmeverlust + Prozessw\u00e4rme\nQ_loss = k * (T_target - T_ambient)  # [kW]\nQ_process = Q_feed * c_p * \u0394T        # [kW]\nQ_total = Q_loss + Q_process         # [kW]\n\n# Nutze zuerst BHKW-W\u00e4rme, dann Zusatzheizung\nif Q_total &lt;= P_th_available:\n    P_aux = 0\nelse:\n    P_aux = Q_total - P_th_available\n</code></pre>"},{"location":"user_guide/components/energy/#beispiel-mehrstufige-heizung","title":"Beispiel: Mehrstufige Heizung","text":"<pre><code>from pyadm1.configurator import BiogasPlant, PlantConfigurator\nfrom pyadm1.substrates import Feedstock\n\nfeedstock = Feedstock(feeding_freq=48)\nplant = BiogasPlant(\"Zweistufige Anlage\")\nconfig = PlantConfigurator(plant, feedstock)\n\n# Zwei Fermenter mit unterschiedlichen Temperaturen\nconfig.add_digester(\"hydro\", V_liq=500, T_ad=328.15)  # 55\u00b0C\nconfig.add_digester(\"main\", V_liq=2000, T_ad=308.15)  # 35\u00b0C\n\n# Ein BHKW\nconfig.add_chp(\"chp1\", P_el_nom=500)\n\n# Separate Heizungen f\u00fcr jeden Fermenter\nconfig.add_heating(\"heat_hydro\", target_temperature=328.15, heat_loss_coefficient=0.3)\nconfig.add_heating(\"heat_main\", target_temperature=308.15, heat_loss_coefficient=0.5)\n\n# Verbinde BHKW mit beiden Heizungen\nconfig.auto_connect_chp_to_heating(\"chp1\", \"heat_hydro\")\nconfig.auto_connect_chp_to_heating(\"chp1\", \"heat_main\")\n\n# Simulieren\nplant.initialize()\nresults = plant.simulate(duration=30, dt=1/24, save_interval=1.0)\n\n# Analysiere W\u00e4rmeverteilung\nfinal = results[-1]\nprint(f\"Hydrolyse-Heizung: {final['components']['heat_hydro']['Q_heat_supplied']:.1f} kW\")\nprint(f\"Haupt-Heizung: {final['components']['heat_main']['Q_heat_supplied']:.1f} kW\")\nprint(f\"Zusatzheizung Hydrolyse: {final['components']['heat_hydro']['P_aux_heat']:.1f} kW\")\nprint(f\"Zusatzheizung Haupt: {final['components']['heat_main']['P_aux_heat']:.1f} kW\")\n</code></pre>"},{"location":"user_guide/components/energy/#gasspeicher","title":"Gasspeicher","text":"<p>Biogasspeicher mit Druckmanagement (wird automatisch pro Fermenter erstellt).</p>"},{"location":"user_guide/components/energy/#typen","title":"Typen","text":"<pre><code>from pyadm1.components.energy import GasStorage\n\n# Niederdruckmembranspeicher (am h\u00e4ufigsten)\nstorage_membrane = GasStorage(\n    component_id=\"storage1\",\n    storage_type=\"membrane\",\n    capacity_m3=1000.0,      # Kapazit\u00e4t bei STP [m\u00b3]\n    p_min_bar=0.95,          # Minimaldruck [bar]\n    p_max_bar=1.05,          # Maximaldruck [bar]\n    initial_fill_fraction=0.1\n)\n\n# Domespeicher\nstorage_dome = GasStorage(\n    component_id=\"storage2\",\n    storage_type=\"dome\",\n    capacity_m3=500.0,\n    p_min_bar=0.98,\n    p_max_bar=1.02\n)\n\n# Hochdruck-Komprimiertspeicher\nstorage_compressed = GasStorage(\n    component_id=\"storage3\",\n    storage_type=\"compressed\",\n    capacity_m3=100.0,\n    p_min_bar=10.0,\n    p_max_bar=200.0\n)\n</code></pre>"},{"location":"user_guide/components/energy/#ausgaben_2","title":"Ausgaben","text":"<pre><code>{\n    'stored_volume_m3': 450.0,       # Aktueller Speicherstand [m\u00b3 STP]\n    'pressure_bar': 1.01,            # Aktueller Druck [bar]\n    'utilization': 0.45,             # F\u00fcllstand (0-1)\n    'vented_volume_m3': 0.0,         # Abgefackeltes Gas dieses Schritts [m\u00b3]\n    'Q_gas_supplied_m3_per_day': 2700.0  # Bereitgestelltes Gas [m\u00b3/d]\n}\n</code></pre>"},{"location":"user_guide/components/energy/#druckmodell","title":"Druckmodell","text":"<p>Der Speicher sch\u00e4tzt den Druck basierend auf gespeichertem Volumen:</p> <p>Niederdruck (membrane/dome): <pre><code>p = p_atm + frac * (p_max - p_atm)\n</code></pre></p> <p>Hochdruck (compressed): <pre><code>p = p_min + frac^\u03b1 * (p_max - p_min)  # \u03b1 &gt; 1 f\u00fcr nichtlinearen Anstieg\n</code></pre></p>"},{"location":"user_guide/components/energy/#sicherheitsventing","title":"Sicherheitsventing","text":"<p>Bei \u00dcberdruck wird Gas automatisch zur Fackel geleitet:</p> <pre><code># Speicher \u00fcberwacht Druck\nif pressure &gt; p_max:\n    # Berechne zu entfernendes Volumen\n    vent = stored_volume - target_volume\n    # Leite zur Fackel\n    vented_volume += vent\n</code></pre>"},{"location":"user_guide/components/energy/#fackel","title":"Fackel","text":"<p>Sicherheitssystem zur Verbrennung von \u00fcbersch\u00fcssigem Biogas.</p> <pre><code>from pyadm1.components.energy import Flare\n\nflare = Flare(\n    component_id=\"flare1\",\n    destruction_efficiency=0.98,  # 98% CH4 zerst\u00f6rt\n    name=\"Notfackel\"\n)\n</code></pre>"},{"location":"user_guide/components/energy/#ausgaben_3","title":"Ausgaben","text":"<pre><code>{\n    'vented_volume_m3': 0.0,         # Verbranntes Volumen dieses Schritts [m\u00b3]\n    'cumulative_vented_m3': 125.5,   # Kumulativ verbranntes Volumen [m\u00b3]\n    'CH4_destroyed_m3': 0.0          # Zerst\u00f6rtes CH4 dieses Schritts [m\u00b3]\n}\n</code></pre>"},{"location":"user_guide/components/energy/#fackelsteuerung","title":"Fackelsteuerung","text":"<p>Die Fackel wird automatisch aktiviert, wenn: - Gasspeicher \u00dcberdruck erreicht - BHKW weniger Gas verbraucht als produziert - Notabschaltung erforderlich ist</p> <pre><code># Gas vom Speicher zur Fackel\nflare_inputs = {\n    'Q_gas_in_m3_per_day': vented_gas,\n    'CH4_fraction': 0.6  # 60% Methan im Biogas\n}\n\nresult = flare.step(t, dt, flare_inputs)\nprint(f\"Zerst\u00f6rtes CH4: {result['CH4_destroyed_m3']:.2f} m\u00b3\")\n</code></pre>"},{"location":"user_guide/components/energy/#vollstandiges-energiesystem","title":"Vollst\u00e4ndiges Energiesystem","text":""},{"location":"user_guide/components/energy/#integrierte-energiekette","title":"Integrierte Energiekette","text":"<pre><code>from pyadm1.configurator import BiogasPlant, PlantConfigurator\nfrom pyadm1.substrates import Feedstock\n\n# Setup\nfeedstock = Feedstock(feeding_freq=48)\nplant = BiogasPlant(\"Energieoptimierte Anlage\")\nconfig = PlantConfigurator(plant, feedstock)\n\n# Fermenter\ndigester, storage = config.add_digester(\n    \"main_digester\",\n    V_liq=2000,\n    V_gas=300,\n    Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n)\n\n# BHKW\nconfig.add_chp(\"chp1\", P_el_nom=500, eta_el=0.40, eta_th=0.45)\n\n# Heizung\nconfig.add_heating(\"heat1\", target_temperature=308.15, heat_loss_coefficient=0.5)\n\n# Auto-Verbindungen (erstellt auch automatisch Fackel)\nconfig.auto_connect_digester_to_chp(\"main_digester\", \"chp1\")\nconfig.auto_connect_chp_to_heating(\"chp1\", \"heat1\")\n\n# Simulieren\nplant.initialize()\nresults = plant.simulate(duration=30, dt=1/24, save_interval=1.0)\n\n# Energiebilanz\ndef energy_balance(results):\n    \"\"\"Berechne Energiebilanz der Anlage\"\"\"\n    final = results[-1]\n    comp = final['components']\n\n    # Gasproduktion\n    Q_gas = comp['main_digester']['Q_gas']  # m\u00b3/d\n    Q_ch4 = comp['main_digester']['Q_ch4']  # m\u00b3/d\n    E_gas = Q_ch4 * 10.0  # kWh/d (10 kWh/m\u00b3 CH4)\n\n    # BHKW-Ausgabe\n    P_el = comp['chp1']['P_el']  # kW\n    P_th = comp['chp1']['P_th']  # kW\n    E_el = P_el * 24  # kWh/d\n    E_th = P_th * 24  # kWh/d\n\n    # W\u00e4rmebedarf\n    Q_heat = comp['heat1']['Q_heat_supplied']  # kW\n    E_heat_needed = Q_heat * 24  # kWh/d\n\n    # Wirkungsgrade\n    eta_el_actual = E_el / E_gas if E_gas &gt; 0 else 0\n    eta_th_actual = E_th / E_gas if E_gas &gt; 0 else 0\n    eta_total = (E_el + E_th) / E_gas if E_gas &gt; 0 else 0\n\n    # W\u00e4rmenutzung\n    heat_utilization = E_heat_needed / E_th if E_th &gt; 0 else 0\n\n    return {\n        'E_gas': E_gas,\n        'E_el': E_el,\n        'E_th': E_th,\n        'E_heat_needed': E_heat_needed,\n        'eta_el': eta_el_actual,\n        'eta_th': eta_th_actual,\n        'eta_total': eta_total,\n        'heat_utilization': heat_utilization,\n        'excess_heat': max(0, E_th - E_heat_needed)\n    }\n\nbalance = energy_balance(results)\nprint(\"\\nEnergiebilanz:\")\nprint(f\"Gasenergie: {balance['E_gas']:.0f} kWh/d\")\nprint(f\"Strom: {balance['E_el']:.0f} kWh/d (\u03b7={balance['eta_el']:.1%})\")\nprint(f\"W\u00e4rme: {balance['E_th']:.0f} kWh/d (\u03b7={balance['eta_th']:.1%})\")\nprint(f\"Gesamtwirkungsgrad: {balance['eta_total']:.1%}\")\nprint(f\"W\u00e4rmenutzung: {balance['heat_utilization']:.1%}\")\nprint(f\"\u00dcberschussw\u00e4rme: {balance['excess_heat']:.0f} kWh/d\")\n</code></pre>"},{"location":"user_guide/components/energy/#optimierungsstrategien","title":"Optimierungsstrategien","text":""},{"location":"user_guide/components/energy/#1-warmenutzungsoptimierung","title":"1. W\u00e4rmenutzungsoptimierung","text":"<pre><code>def optimize_heat_utilization(plant, results):\n    \"\"\"Optimiere W\u00e4rmenutzung durch Lastmanagement\"\"\"\n\n    # Analysiere W\u00e4rme\u00fcberschuss\n    excess_heat = []\n    for result in results:\n        P_th = result['components']['chp1']['P_th']\n        Q_heat = result['components']['heat1']['Q_heat_supplied']\n        excess_heat.append(max(0, P_th - Q_heat))\n\n    avg_excess = sum(excess_heat) / len(excess_heat)\n\n    if avg_excess &gt; 50:  # kW\n        print(f\"Durchschnittlicher W\u00e4rme\u00fcberschuss: {avg_excess:.1f} kW\")\n        print(\"Optimierungsoptionen:\")\n        print(\"- Reduziere BHKW-Gr\u00f6\u00dfe\")\n        print(\"- F\u00fcge zus\u00e4tzliche W\u00e4rmenutzung hinzu (Trocknung, etc.)\")\n        print(\"- Nutze W\u00e4rmespeicher\")\n\n    return avg_excess\n\noptimize_heat_utilization(plant, results)\n</code></pre>"},{"location":"user_guide/components/energy/#2-lastfolgebetrieb","title":"2. Lastfolgebetrieb","text":"<pre><code># BHKW-Laststeuerung basierend auf Gasproduktion\ndef load_following_control(Q_gas_available, P_el_nom):\n    \"\"\"Passe BHKW-Last an verf\u00fcgbares Gas an\"\"\"\n\n    # Minimale Last: 40% f\u00fcr stabile Verbrennung\n    min_load = 0.4\n\n    # Berechne optimale Last\n    E_gas = Q_gas_available / 24 * 10  # kW\n    load = min(1.0, max(min_load, E_gas / (P_el_nom / 0.40)))\n\n    return load\n\n# In Simulation anwenden\nload_setpoint = load_following_control(Q_gas_available, 500)\nchp_inputs = {\n    'Q_gas_supplied_m3_per_day': Q_gas_available,\n    'load_setpoint': load_setpoint\n}\n</code></pre>"},{"location":"user_guide/components/energy/#3-gasspeicher-management","title":"3. Gasspeicher-Management","text":"<pre><code>def manage_gas_storage(storage_state, chp_demand):\n    \"\"\"Optimiere Gasspeicher-F\u00fcllstand\"\"\"\n\n    utilization = storage_state['utilization']\n    pressure = storage_state['pressure_bar']\n\n    # Ziel: 30-70% F\u00fcllstand f\u00fcr Flexibilit\u00e4t\n    if utilization &lt; 0.3:\n        print(\"Niedriger Speicherstand - erh\u00f6he Gasproduktion oder reduziere BHKW-Last\")\n        adjust_load = 0.8\n    elif utilization &gt; 0.7:\n        print(\"Hoher Speicherstand - erh\u00f6he BHKW-Last oder bereite Venting vor\")\n        adjust_load = 1.2\n    else:\n        adjust_load = 1.0\n\n    return adjust_load\n\n# In Simulation anwenden\nload_adjustment = manage_gas_storage(storage.outputs_data, chp_demand)\n</code></pre>"},{"location":"user_guide/components/energy/#leistungsmetriken","title":"Leistungsmetriken","text":""},{"location":"user_guide/components/energy/#bhkw-verfugbarkeit","title":"BHKW-Verf\u00fcgbarkeit","text":"<pre><code>def calculate_chp_availability(results):\n    \"\"\"Berechne BHKW-Verf\u00fcgbarkeit und Nutzung\"\"\"\n\n    total_hours = len(results) / 24  # Tage * 24 h\n    running_hours = sum(1 for r in results if r['components']['chp1']['P_el'] &gt; 0) / 24\n\n    availability = running_hours / total_hours\n\n    # Lastfaktor\n    load_factors = [r['components']['chp1']['load_factor'] for r in results]\n    avg_load = sum(load_factors) / len(load_factors)\n\n    return {\n        'availability': availability,\n        'running_hours': running_hours,\n        'avg_load': avg_load,\n        'full_load_hours': running_hours * avg_load\n    }\n\nmetrics = calculate_chp_availability(results)\nprint(f\"BHKW-Verf\u00fcgbarkeit: {metrics['availability']:.1%}\")\nprint(f\"Betriebsstunden: {metrics['running_hours']:.0f} h\")\nprint(f\"Durchschn. Last: {metrics['avg_load']:.1%}\")\nprint(f\"Volllaststunden: {metrics['full_load_hours']:.0f} h\")\n</code></pre>"},{"location":"user_guide/components/energy/#fehlerbehebung","title":"Fehlerbehebung","text":""},{"location":"user_guide/components/energy/#problem-bhkw-lauft-nicht","title":"Problem: BHKW l\u00e4uft nicht","text":"<p>Diagnose: <pre><code>chp_outputs = chp.step(t, dt, inputs)\n\nif chp_outputs['P_el'] == 0:\n    print(\"BHKW l\u00e4uft nicht - pr\u00fcfe:\")\n    print(f\"- Verf\u00fcgbares Gas: {inputs.get('Q_gas_supplied_m3_per_day', 0):.1f} m\u00b3/d\")\n    print(f\"- Mindestgasbedarf: {P_el_nom / eta_el * 24 / 10:.1f} m\u00b3/d\")\n    print(f\"- Speicherdruck: {storage.outputs_data['pressure_bar']:.2f} bar\")\n</code></pre></p>"},{"location":"user_guide/components/energy/#problem-ubermaiges-venting","title":"Problem: \u00dcberm\u00e4\u00dfiges Venting","text":"<p>Ursache: Gasproduktion &gt; BHKW-Verbrauch</p> <p>L\u00f6sung: <pre><code># Option 1: Erh\u00f6he BHKW-Kapazit\u00e4t\nconfig.add_chp(\"chp1\", P_el_nom=750)  # Von 500 auf 750 kW\n\n# Option 2: F\u00fcge zweites BHKW hinzu\nconfig.add_chp(\"chp2\", P_el_nom=250)\n\n# Option 3: Vergr\u00f6\u00dfere Gasspeicher\nstorage = GasStorage(\"storage1\", capacity_m3=1500)  # Von 1000 auf 1500\n</code></pre></p>"},{"location":"user_guide/components/energy/#problem-unzureichende-warme","title":"Problem: Unzureichende W\u00e4rme","text":"<p>Diagnose: <pre><code>heat_outputs = heating.step(t, dt, inputs)\n\nif heat_outputs['P_aux_heat'] &gt; 50:  # kW Zusatzheizung\n    print(\"Hoher Zusatzheizungsbedarf:\")\n    print(f\"- BHKW-W\u00e4rme: {heat_outputs['P_th_used']:.1f} kW\")\n    print(f\"- Zusatzheizung: {heat_outputs['P_aux_heat']:.1f} kW\")\n    print(\"L\u00f6sungen:\")\n    print(\"- Verbessere Isolierung (reduziere k)\")\n    print(\"- Vergr\u00f6\u00dfere BHKW\")\n    print(\"- Reduziere Fermentertemperatur\")\n</code></pre></p>"},{"location":"user_guide/components/energy/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Biologische Komponenten: Fermenter und Prozesssteuerung</li> <li>Mechanische Komponenten: Pumpen und R\u00fchrwerke</li> <li>F\u00fctterungskomponenten: Lagerung und Dosierung</li> <li>API-Referenz: Detaillierte Klassendokumentation</li> </ul>"},{"location":"user_guide/components/feeding/","title":"F\u00fctterungskomponenten","text":"<p>Komponenten f\u00fcr Substrathandhabung, Lagerung und Dosierung in Biogasanlagen.</p>"},{"location":"user_guide/components/feeding/#substratestorage","title":"SubstrateStorage","text":"<p>Lagerbeh\u00e4lter f\u00fcr verschiedene Substrattypen mit Bestandsverfolgung und Qualit\u00e4tsmanagement.</p>"},{"location":"user_guide/components/feeding/#parameter","title":"Parameter","text":"<pre><code>from pyadm1.components.feeding import SubstrateStorage\n\nstorage = SubstrateStorage(\n    component_id=\"silo1\",\n    storage_type=\"vertical_silo\",    # Siehe Tabelle unten\n    substrate_type=\"corn_silage\",    # Siehe Tabelle unten\n    capacity=1000.0,                 # Max. Kapazit\u00e4t [t oder m\u00b3]\n    initial_level=800.0,             # Anfangsbestand\n    degradation_rate=None,           # Auto-berechnet\n    temperature=288.15,              # Lagertemperatur [K] (15\u00b0C)\n    name=\"Maissilagelager\"\n)\n</code></pre>"},{"location":"user_guide/components/feeding/#lagertypen","title":"Lagertypen","text":"Typ Degradation [1/d] Beste Anwendung Typische Gr\u00f6\u00dfe Investition Vertical Silo 0.0005 Mais-/Grassilage 500-2000 t Hoch Horizontal Silo 0.0008 Gro\u00dfbetriebe 1000-3000 t Mittel Bunker Silo 0.001 \u00dcberfahrbarer Zugang 1000-5000 t Mittel Clamp 0.0025 Saisonale Lagerung 500-2000 t Niedrig Above-ground Tank 0.0002 Fl\u00fcssigg\u00fclle 500-3000 m\u00b3 Hoch Below-ground Tank 0.0001 Fl\u00fcssige Lagerung 1000-5000 m\u00b3 Sehr hoch"},{"location":"user_guide/components/feeding/#substrattypen","title":"Substrattypen","text":"Substrat Dichte [kg/m\u00b3] TM [%] oTS [% der TM] Typische Lagerung Maissilage 650 35 95 Silo Grassilage 700 30 92 Silo Ganzpflanzensilage 680 32 94 Silo/Bunker Fl\u00fcssigg\u00fclle 1020 8 80 Tank Festmist 850 25 75 Miete Bioabfall 1000 20 90 Tank"},{"location":"user_guide/components/feeding/#qualitatsverschlechterung","title":"Qualit\u00e4tsverschlechterung","text":"<p>Lagerqualit\u00e4t verschlechtert sich \u00fcber Zeit:</p> <pre><code># Qualit\u00e4tsfaktor zum Zeitpunkt t:\nquality(t) = quality(0) \u00d7 exp(-k \u00d7 t)\n\n# Wobei:\n# k = degradation_rate [1/d]\n# t = storage_time [Tage]\n\n# Beispiel: Maissilage im Hochsilo\n# Nach 30 Tagen: quality = 1.0 \u00d7 exp(-0.0005 \u00d7 30) = 0.985 (98.5%)\n# Nach 90 Tagen: quality = 1.0 \u00d7 exp(-0.0005 \u00d7 90) = 0.956 (95.6%)\n</code></pre> <p>Temperatureffekt:</p> <p>Temperatur beeinflusst Degradation (Q10 = 2):</p> <pre><code># Degradation steigt mit Temperatur\nT_ref = 288.15  # 15\u00b0C Referenz\nk_ref = 0.0005  # Basisrate\n\n# Bei 20\u00b0C (293.15 K):\nk_20C = k_ref \u00d7 2^((293.15-288.15)/10) = 0.0007\n\n# Bei 10\u00b0C (283.15 K):\nk_10C = k_ref \u00d7 2^((283.15-288.15)/10) = 0.0004\n</code></pre>"},{"location":"user_guide/components/feeding/#ausgaben","title":"Ausgaben","text":"<pre><code>{\n    'current_level': 750.0,      # Bestand [t oder m\u00b3]\n    'utilization': 0.75,         # F\u00fcllstand (0-1)\n    'quality_factor': 0.95,      # Qualit\u00e4t (0-1)\n    'available_mass': 712.5,     # Nutzbare Masse\n    'degradation_rate': 0.0005,  # Aktuelle Rate\n    'losses_this_step': 0.4,     # Verluste [t oder m\u00b3]\n    'withdrawn_this_step': 15.0, # Entnommen [t oder m\u00b3]\n    'is_empty': False,\n    'is_full': False,\n    'storage_time': 25.5,        # Tage gelagert\n    'dry_matter': 35.0,          # TM [%]\n    'vs_content': 95.0           # oTS [% der TM]\n}\n</code></pre>"},{"location":"user_guide/components/feeding/#verwendungsbeispiel","title":"Verwendungsbeispiel","text":"<pre><code># Maissilagelagerung\nstorage = SubstrateStorage(\n    component_id=\"silo1\",\n    storage_type=\"vertical_silo\",\n    substrate_type=\"corn_silage\",\n    capacity=1000,\n    initial_level=800\n)\n\nstorage.initialize()\n\n# T\u00e4glicher Betrieb\nresult = storage.step(\n    t=10,\n    dt=1,\n    inputs={\n        'withdrawal_rate': 15,    # m\u00b3/d oder t/d\n        'refill_amount': 0,\n        'temperature': 288.15\n    }\n)\n\nprint(f\"F\u00fcllstand: {result['current_level']:.1f} t\")\nprint(f\"Qualit\u00e4t: {result['quality_factor']:.3f}\")\nprint(f\"Verf\u00fcgbar: {result['available_mass']:.1f} t\")\nprint(f\"Verluste: {result['losses_this_step']:.2f} t\")\n</code></pre>"},{"location":"user_guide/components/feeding/#lagermanagement-strategie","title":"Lagermanagement-Strategie","text":"<pre><code>def should_refill(storage_result, safety_days=7):\n    \"\"\"Bestimme ob Nachf\u00fcllung erforderlich ist\"\"\"\n    level = storage_result['current_level']\n    daily_usage = 15  # t/d\n    days_remaining = level / daily_usage\n\n    return days_remaining &lt; safety_days\n\ndef check_quality(storage_result, min_quality=0.90):\n    \"\"\"Alarm bei zu niedriger Qualit\u00e4t\"\"\"\n    quality = storage_result['quality_factor']\n    if quality &lt; min_quality:\n        print(f\"Warnung: Qualit\u00e4t bei {quality:.1%}\")\n        return False\n    return True\n</code></pre>"},{"location":"user_guide/components/feeding/#feeder","title":"Feeder","text":"<p>Automatische Dosiersysteme f\u00fcr pr\u00e4zise Substratf\u00fctterung.</p>"},{"location":"user_guide/components/feeding/#parameter_1","title":"Parameter","text":"<pre><code>from pyadm1.components.feeding import Feeder\n\nfeeder = Feeder(\n    component_id=\"feed1\",\n    feeder_type=\"screw\",             # Auto-gew\u00e4hlt wenn None\n    Q_max=20.0,                      # Max. Durchfluss [m\u00b3/d oder t/d]\n    substrate_type=\"solid\",          # \"solid\", \"slurry\", \"liquid\", \"fibrous\"\n    dosing_accuracy=None,            # Auto-berechnet\n    power_installed=None,            # Auto-berechnet\n    enable_dosing_noise=True,        # Realistische Varianz\n    name=\"Schneckendosierer\"\n)\n</code></pre>"},{"location":"user_guide/components/feeding/#dosierertypen","title":"Dosierertypen","text":"Typ Genauigkeit [\u00b1%] Beste Anwendung Drehzahlregelung Leistung [kW/m\u00b3/h] Screw 5 Feste Substrate Gut 0.8 Twin Screw 3 Bessere Kontrolle Ausgezeichnet 1.0 Progressive Cavity 2 Viskose Schl\u00e4mme Gut 1.2 Piston 1 Pr\u00e4zise Dosierung Ausgezeichnet 1.5 Centrifugal Pump 8 Niedrige Viskosit\u00e4t Mittelm\u00e4\u00dfig 0.5 Mixer Wagon 10 Chargen-F\u00fctterung N/A 2.0"},{"location":"user_guide/components/feeding/#dosiergenauigkeit","title":"Dosiergenauigkeit","text":"<p>Echte Dosierer haben Varianz um Sollwerte:</p> <pre><code># Mit aktiviertem dosing_noise:\n# Tats\u00e4chlicher Durchfluss = Sollwert + Rauschen\n# Wobei Rauschen ~ Normal(0, accuracy \u00d7 Sollwert)\n\n# Beispiel: Schneckendosierer (5% Genauigkeit) bei 15 m\u00b3/d\n# Typischer Bereich: 14.25 - 15.75 m\u00b3/d\n# Gelegentlich: 13.5 - 16.5 m\u00b3/d (\u00b12\u03c3)\n\nfeeder = Feeder(\"feed1\", Q_max=20, dosing_accuracy=0.05)\n</code></pre>"},{"location":"user_guide/components/feeding/#leistungsanforderungen","title":"Leistungsanforderungen","text":"<p>Leistung h\u00e4ngt vom Substrattyp ab:</p> Substrat Basisleistung [kW/m\u00b3/h] Modifikator Gesamt Fl\u00fcssig 0.5 \u00d70.7 0.35 Schl\u00e4mme 0.8 \u00d71.0 0.80 Fest 0.8 \u00d71.4 1.12 Faserreich 0.8 \u00d71.8 1.44 <pre><code># Beispiel: 15 m\u00b3/h Schneckendosierer f\u00fcr faserreiches Substrat\nQ_nom_h = 15 / 24  # = 0.625 m\u00b3/h\nP = 0.8 * 0.625 * 1.8 * 1.3  # [Basis \u00d7 Q \u00d7 Modifikator \u00d7 Sicherheit]\n  = 1.17 kW\n</code></pre>"},{"location":"user_guide/components/feeding/#ausgaben_1","title":"Ausgaben","text":"<pre><code>{\n    'Q_actual': 14.8,            # Tats\u00e4chlicher Durchfluss [m\u00b3/d]\n    'is_running': True,\n    'load_factor': 0.74,         # Last (0-1)\n    'P_consumed': 2.5,           # Leistung [kW]\n    'blockage_detected': False,  # Alarm\n    'dosing_error': 1.3,         # Fehler [%]\n    'speed_fraction': 0.95,      # Drehzahl (0-1)\n    'dosing_accuracy': 0.05,     # Genauigkeit\n    'total_mass_fed': 1250.0     # Kumulativ [t]\n}\n</code></pre>"},{"location":"user_guide/components/feeding/#verwendungsbeispiel_1","title":"Verwendungsbeispiel","text":"<pre><code># Schneckendosierer f\u00fcr feste Substrate\nfeeder = Feeder(\n    component_id=\"feed1\",\n    feeder_type=\"screw\",\n    Q_max=20.0,\n    substrate_type=\"solid\",\n    enable_dosing_noise=True\n)\n\nfeeder.initialize()\n\nresult = feeder.step(\n    t=0,\n    dt=1/24,\n    inputs={\n        'Q_setpoint': 15.0,\n        'enable_feeding': True,\n        'substrate_available': 500,\n        'speed_setpoint': 1.0\n    }\n)\n\nprint(f\"Ziel: 15.0 m\u00b3/d\")\nprint(f\"Tats\u00e4chlich: {result['Q_actual']:.2f} m\u00b3/d\")\nprint(f\"Fehler: {result['dosing_error']:.1f}%\")\nprint(f\"Leistung: {result['P_consumed']:.2f} kW\")\n</code></pre>"},{"location":"user_guide/components/feeding/#blockadenerkennung","title":"Blockadenerkennung","text":"<p>Dosierer k\u00f6nnen Blockaden erkennen und handhaben:</p> <pre><code># Automatische Handhabung\nif result['blockage_detected']:\n    print(\"Blockade erkannt!\")\n    # Dosierer reduziert automatisch Durchfluss auf 10%\n    # Weiter \u00fcberwachen\n\n# \u00dcberwache kumulative Blockaden\nprint(f\"Gesamt-Blockaden: {feeder.state['n_blockages']}\")\n</code></pre>"},{"location":"user_guide/components/feeding/#vollstandige-futterungskette","title":"Vollst\u00e4ndige F\u00fctterungskette","text":""},{"location":"user_guide/components/feeding/#integriertes-system","title":"Integriertes System","text":"<pre><code>from pyadm1.configurator import BiogasPlant, PlantConfigurator\nfrom pyadm1.components.feeding import SubstrateStorage, Feeder\nfrom pyadm1.components.mechanical import Pump\nfrom pyadm1.substrates import Feedstock\n\n# Setup\nfeedstock = Feedstock(feeding_freq=48)\nplant = BiogasPlant(\"Komplettes F\u00fctterungssystem\")\nconfig = PlantConfigurator(plant, feedstock)\n\n# 1. Mehrfache Substratlagerbeh\u00e4lter\ncorn_storage = SubstrateStorage(\n    \"corn_silo\",\n    storage_type=\"vertical_silo\",\n    substrate_type=\"corn_silage\",\n    capacity=1000,\n    initial_level=800\n)\nplant.add_component(corn_storage)\n\nmanure_storage = SubstrateStorage(\n    \"manure_tank\",\n    storage_type=\"above_ground_tank\",\n    substrate_type=\"manure_liquid\",\n    capacity=500,\n    initial_level=400\n)\nplant.add_component(manure_storage)\n\n# 2. Dosierer f\u00fcr jedes Substrat\ncorn_feeder = Feeder(\n    \"corn_feeder\",\n    feeder_type=\"screw\",\n    Q_max=15.0,\n    substrate_type=\"solid\"\n)\nplant.add_component(corn_feeder)\n\nmanure_feeder = Feeder(\n    \"manure_feeder\",\n    feeder_type=\"progressive_cavity\",\n    Q_max=10.0,\n    substrate_type=\"slurry\"\n)\nplant.add_component(manure_feeder)\n\n# 3. Mischpumpe\nmix_pump = Pump(\n    \"mix_pump\",\n    pump_type=\"progressive_cavity\",\n    Q_nom=25.0,\n    pressure_head=50.0\n)\nplant.add_component(mix_pump)\n\n# 4. Fermenter\ndigester, storage = config.add_digester(\n    \"main_digester\",\n    V_liq=2000,\n    Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n)\n\n# 5. Energiesystem\nconfig.add_chp(\"chp1\", P_el_nom=500)\nconfig.add_heating(\"heat1\", target_temperature=308.15)\n\n# Verbindungen\nconfig.connect(\"corn_silo\", \"corn_feeder\", \"default\")\nconfig.connect(\"manure_tank\", \"manure_feeder\", \"default\")\nconfig.connect(\"corn_feeder\", \"mix_pump\", \"default\")\nconfig.connect(\"manure_feeder\", \"mix_pump\", \"default\")\nconfig.connect(\"mix_pump\", \"main_digester\", \"liquid\")\nconfig.auto_connect_digester_to_chp(\"main_digester\", \"chp1\")\nconfig.auto_connect_chp_to_heating(\"chp1\", \"heat1\")\n\n# Simulieren\nplant.initialize()\nresults = plant.simulate(duration=30, dt=1/24, save_interval=1.0)\n\n# F\u00fctterungsanalyse\ndef feeding_system_analysis(results):\n    \"\"\"Analysiere F\u00fctterungssystem-Leistung\"\"\"\n    final = results[-1]\n    comp = final['components']\n\n    # Lagerbestand\n    corn_level = comp['corn_silo']['current_level']\n    manure_level = comp['manure_tank']['current_level']\n\n    # Qualit\u00e4t\n    corn_quality = comp['corn_silo']['quality_factor']\n    manure_quality = comp['manure_tank']['quality_factor']\n\n    # Durchsatz\n    corn_fed = comp['corn_feeder']['total_mass_fed']\n    manure_fed = comp['manure_feeder']['total_mass_fed']\n\n    # Energieverbrauch\n    corn_feeder_energy = comp['corn_feeder'].get('energy_consumed', 0)\n    manure_feeder_energy = comp['manure_feeder'].get('energy_consumed', 0)\n    pump_energy = comp['mix_pump']['energy_consumed']\n\n    total_feed_energy = corn_feeder_energy + manure_feeder_energy + pump_energy\n\n    return {\n        'corn_remaining': corn_level,\n        'manure_remaining': manure_level,\n        'corn_quality': corn_quality,\n        'manure_quality': manure_quality,\n        'total_corn_fed': corn_fed,\n        'total_manure_fed': manure_fed,\n        'feeding_energy': total_feed_energy\n    }\n\nanalysis = feeding_system_analysis(results)\nprint(\"\\nF\u00fctterungssystem-Analyse:\")\nprint(f\"Mais verbleibend: {analysis['corn_remaining']:.0f} t (Qualit\u00e4t: {analysis['corn_quality']:.1%})\")\nprint(f\"G\u00fclle verbleibend: {analysis['manure_remaining']:.0f} m\u00b3 (Qualit\u00e4t: {analysis['manure_quality']:.1%})\")\nprint(f\"Gesamt Mais gef\u00fcttert: {analysis['total_corn_fed']:.0f} t\")\nprint(f\"Gesamt G\u00fclle gef\u00fcttert: {analysis['total_manure_fed']:.0f} m\u00b3\")\nprint(f\"F\u00fctterungsenergie: {analysis['feeding_energy']:.0f} kWh\")\n</code></pre>"},{"location":"user_guide/components/feeding/#optimierungsstrategien","title":"Optimierungsstrategien","text":""},{"location":"user_guide/components/feeding/#1-substratmischoptimierung","title":"1. Substratmischoptimierung","text":"<pre><code>def optimize_substrate_mix(available_substrates, target_vs_loading):\n    \"\"\"Optimiere Substratmischung f\u00fcr Ziel-oTS-Belastung\"\"\"\n\n    # Beispiel-Substrate\n    substrates = {\n        'corn_silage': {'vs': 0.33, 'cost': 30},  # 33% oTS, 30 \u20ac/t\n        'manure': {'vs': 0.06, 'cost': 0},        # 6% oTS, kostenlos\n        'biowaste': {'vs': 0.17, 'cost': -20}     # 17% oTS, Gate Fee\n    }\n\n    # Einfache Mischberechnung (kann erweitert werden f\u00fcr Optimierung)\n    corn_fraction = 0.60\n    manure_fraction = 0.30\n    biowaste_fraction = 0.10\n\n    mix_vs = (corn_fraction * substrates['corn_silage']['vs'] +\n              manure_fraction * substrates['manure']['vs'] +\n              biowaste_fraction * substrates['biowaste']['vs'])\n\n    mix_cost = (corn_fraction * substrates['corn_silage']['cost'] +\n                manure_fraction * substrates['manure']['cost'] +\n                biowaste_fraction * substrates['biowaste']['cost'])\n\n    print(f\"Optimierte Mischung:\")\n    print(f\"- Mais: {corn_fraction:.0%}\")\n    print(f\"- G\u00fclle: {manure_fraction:.0%}\")\n    print(f\"- Bioabfall: {biowaste_fraction:.0%}\")\n    print(f\"Resultierende oTS: {mix_vs:.1%}\")\n    print(f\"Kosten: {mix_cost:.1f} \u20ac/t\")\n\n    return {\n        'corn': corn_fraction,\n        'manure': manure_fraction,\n        'biowaste': biowaste_fraction,\n        'total_vs': mix_vs,\n        'cost': mix_cost\n    }\n\noptimized_mix = optimize_substrate_mix({}, 0.20)\n</code></pre>"},{"location":"user_guide/components/feeding/#2-bestandsmanagement","title":"2. Bestandsmanagement","text":"<pre><code>def manage_inventory(storage_results, forecast_days=30):\n    \"\"\"Verwalte Lagerbestand mit Vorhersage\"\"\"\n\n    for name, result in storage_results.items():\n        level = result['current_level']\n        capacity = result.get('capacity', 1000)\n        daily_usage = 15  # Beispiel\n\n        days_remaining = level / daily_usage\n\n        print(f\"\\n{name}:\")\n        print(f\"- Aktueller Bestand: {level:.0f} ({level/capacity:.1%} Kapazit\u00e4t)\")\n        print(f\"- Verbleibende Tage: {days_remaining:.1f}\")\n\n        if days_remaining &lt; 7:\n            print(\"- AKTION: Dringend nachf\u00fcllen!\")\n            refill_amount = capacity * 0.8 - level\n            print(f\"- Empfohlene Nachf\u00fcllung: {refill_amount:.0f}\")\n        elif days_remaining &lt; 14:\n            print(\"- WARNUNG: Nachf\u00fcllung planen\")\n\n        # Qualit\u00e4tspr\u00fcfung\n        quality = result['quality_factor']\n        if quality &lt; 0.90:\n            print(f\"- QUALIT\u00c4T: Niedrig ({quality:.1%}) - erw\u00e4ge Verwendungsreihenfolge\")\n\n# Beispielverwendung\nstorage_results = {\n    'corn_silo': final['components']['corn_silo'],\n    'manure_tank': final['components']['manure_tank']\n}\nmanage_inventory(storage_results)\n</code></pre>"},{"location":"user_guide/components/feeding/#3-dosiergenauigkeitsoptimierung","title":"3. Dosiergenauigkeitsoptimierung","text":"<pre><code>def optimize_dosing_accuracy(substrate_value, process_sensitivity):\n    \"\"\"W\u00e4hle Dosierertyp basierend auf Anforderungen\"\"\"\n\n    # Hochwertige Substrate oder sensible Prozesse ben\u00f6tigen hohe Genauigkeit\n    if substrate_value &gt; 40 or process_sensitivity == \"high\":\n        recommended_type = \"piston\"\n        accuracy = 0.01\n    elif substrate_value &gt; 20 or process_sensitivity == \"medium\":\n        recommended_type = \"progressive_cavity\"\n        accuracy = 0.02\n    else:\n        recommended_type = \"screw\"\n        accuracy = 0.05\n\n    print(f\"Empfohlener Dosierertyp: {recommended_type}\")\n    print(f\"Erwartete Genauigkeit: \u00b1{accuracy:.0%}\")\n\n    return recommended_type, accuracy\n\n# Beispiel: Hochwertige Energiepflanzen\nfeeder_type, accuracy = optimize_dosing_accuracy(substrate_value=35,\n                                                  process_sensitivity=\"medium\")\n</code></pre>"},{"location":"user_guide/components/feeding/#fehlerbehebung","title":"Fehlerbehebung","text":""},{"location":"user_guide/components/feeding/#problem-schneller-qualitatsverlust","title":"Problem: Schneller Qualit\u00e4tsverlust","text":"<p>Diagnose: <pre><code>storage_result = storage.step(t, dt, inputs)\n\nif storage_result['quality_factor'] &lt; 0.95 and storage_result['storage_time'] &lt; 30:\n    print(\"Schneller Qualit\u00e4tsverlust erkannt:\")\n    print(f\"- Qualit\u00e4t: {storage_result['quality_factor']:.1%}\")\n    print(f\"- Lagerzeit: {storage_result['storage_time']:.1f} Tage\")\n    print(f\"- Degradationsrate: {storage_result['degradation_rate']:.4f} 1/d\")\n    print(f\"- Temperatur: {storage.temperature:.1f} K\")\n</code></pre></p> <p>L\u00f6sungen: <pre><code># Option 1: Verbessere Lagertyp\nstorage_improved = SubstrateStorage(\n    \"silo1\",\n    storage_type=\"vertical_silo\",  # Von \"clamp\"\n    substrate_type=\"corn_silage\",\n    capacity=1000\n)\n\n# Option 2: Reduziere Temperatur\nstorage.temperature = 283.15  # 10\u00b0C statt 15\u00b0C\n\n# Option 3: Schnellere Verwendung (reduziere Lagerzeit)\nincrease_daily_usage = True\n</code></pre></p>"},{"location":"user_guide/components/feeding/#problem-dosierer-blockaden","title":"Problem: Dosierer-Blockaden","text":"<p>Diagnose: <pre><code>if feeder.state['n_blockages'] &gt; 5:\n    print(f\"H\u00e4ufige Blockaden erkannt: {feeder.state['n_blockages']}\")\n    print(\"M\u00f6gliche Ursachen:\")\n    print(\"- Faserreiches Substrat f\u00fcr Dosierertyp ungeeignet\")\n    print(\"- Fremdk\u00f6rper im Substrat\")\n    print(\"- Verschlei\u00df oder Wartung erforderlich\")\n</code></pre></p> <p>L\u00f6sungen: - Wechsle zu robusterem Dosierertyp (Twin Screw) - Verbessere Substratvorbereitung - Implementiere Wartungsplan</p>"},{"location":"user_guide/components/feeding/#problem-inkonsistente-dosierung","title":"Problem: Inkonsistente Dosierung","text":"<p>Diagnose: <pre><code>dosing_errors = [r['components']['feed1']['dosing_error']\n                for r in results]\navg_error = sum(dosing_errors) / len(dosing_errors)\n\nif avg_error &gt; 10:\n    print(f\"Hoher durchschn. Dosierfehler: {avg_error:.1f}%\")\n    print(\"Empfehlungen:\")\n    print(\"- Erw\u00e4ge pr\u00e4ziseren Dosierertyp\")\n    print(\"- Pr\u00fcfe Kalibrierung\")\n    print(\"- Deaktiviere dosing_noise f\u00fcr idealisierte Simulation\")\n</code></pre></p>"},{"location":"user_guide/components/feeding/#best-practices","title":"Best Practices","text":"<ol> <li>Qualit\u00e4ts\u00fcberwachung implementieren</li> <li>Verfolge quality_factor \u00fcber Zeit</li> <li>Alarmiere bei &lt;90% Qualit\u00e4t</li> <li> <p>Plane FIFO-Rotation</p> </li> <li> <p>Bestandssicherheit aufrechterhalten</p> </li> <li>7-14 Tage Mindestsicherheitsbestand</li> <li>Plane Nachf\u00fcllungen im Voraus</li> <li> <p>Ber\u00fccksichtige saisonale Verf\u00fcgbarkeit</p> </li> <li> <p>Optimiere Energieverbrauch</p> </li> <li>Nutze FU f\u00fcr variable Dosierung</li> <li>Minimiere Leerl aufzeiten</li> <li> <p>Richtige Dosierer-Dimensionierung</p> </li> <li> <p>Substratmischung optimieren</p> </li> <li>Ausgewogene oTS-Belastung</li> <li>Kostenoptimierung</li> <li> <p>N\u00e4hrstoffbilanzierung</p> </li> <li> <p>Wartung planen</p> </li> <li>\u00dcberwache Verschlei\u00dfteile</li> <li>Pr\u00e4ventive Wartung f\u00fcr Dosierer</li> <li>Lagerbeh\u00e4lter-Inspektionen</li> </ol>"},{"location":"user_guide/components/feeding/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Biologische Komponenten: Fermenter und Prozesssteuerung</li> <li>Energiekomponenten: BHKW und W\u00e4rmesysteme</li> <li>Mechanische Komponenten: Pumpen und R\u00fchrwerke</li> <li>API-Referenz: Detaillierte Klassendokumentation</li> </ul>"},{"location":"user_guide/components/mechanical/","title":"Mechanische Komponenten","text":"<p>Mechanische Anlagenkomponenten f\u00fcr Materialhandhabung und Prozesssteuerung.</p>"},{"location":"user_guide/components/mechanical/#pump","title":"Pump","text":"<p>Pumpen f\u00fcr Substratf\u00f6rderung, Rezirkulation und G\u00e4rrestverarbeitung in Biogasanlagen.</p>"},{"location":"user_guide/components/mechanical/#parameter","title":"Parameter","text":"<pre><code>from pyadm1.components.mechanical import Pump\n\npump = Pump(\n    component_id=\"pump1\",\n    pump_type=\"progressive_cavity\",  # oder \"centrifugal\", \"piston\"\n    Q_nom=15.0,                      # Nenn-Durchflussrate [m\u00b3/h]\n    pressure_head=50.0,              # Auslegungsdruck [m]\n    efficiency=None,                 # Auto-berechnet wenn None\n    motor_efficiency=0.90,           # Motorwirkungsgrad (0-1)\n    fluid_density=1020.0,            # Fluiddichte [kg/m\u00b3]\n    speed_control=True,              # Frequenzumrichter\n    name=\"F\u00f6rderpumpe\"\n)\n</code></pre>"},{"location":"user_guide/components/mechanical/#pumpentypen-vergleich","title":"Pumpentypen-Vergleich","text":"Typ Beste Anwendung Wirkungsgrad Vorteile Nachteile Kreiselpumpe Niederviskose Fl\u00fcssigkeiten 65-75% \u2022 Hohe Durchflussraten\u2022 Robust\u2022 Wartungsarm \u2022 Nicht selbstansaugend\u2022 Schlecht bei hoher Viskosit\u00e4t\u2022 Wirkungsgrad sinkt bei Feststoffen Exzenterschneckenpumpe Viskose Schl\u00e4mme 50-70% \u2022 Handhabt hohe Feststoffgehalte\u2022 Selbstansaugend\u2022 Schonende F\u00f6rderung \u2022 Niedrigerer Wirkungsgrad\u2022 H\u00f6herer Wartungsaufwand\u2022 Drehzahlabh\u00e4ngiger Druck Kolbenpumpe Hochdruckanwendungen 70-85% \u2022 Hohe Druckf\u00e4higkeit\u2022 Pr\u00e4zise Durchflusskontrolle\u2022 Guter Wirkungsgrad \u2022 H\u00f6here Kosten\u2022 Komplexer\u2022 Empfindlich gegen Feststoffe"},{"location":"user_guide/components/mechanical/#dimensionierungsrichtlinien","title":"Dimensionierungsrichtlinien","text":"<p>Durchflussraten-Auswahl:</p> Anlagengr\u00f6\u00dfe Substratf\u00fctterung [m\u00b3/d] Pumpe Q_nom [m\u00b3/h] Typischer Druck [m] Klein 10-25 5-15 30-50 Mittel 25-75 15-40 40-60 Gro\u00df 75-200 40-100 50-80 <p>Druckh\u00f6hen-\u00dcberlegungen:</p> <pre><code># Berechne erforderliche Druckh\u00f6he\nH_static = 5.0      # Vertikaler Hub [m]\nH_friction = 8.0    # Rohrreibungsverluste [m]\nH_process = 2.0     # Prozessdruck [m]\nH_safety = 1.2      # Sicherheitsfaktor\n\nH_required = (H_static + H_friction + H_process) * H_safety\n# = 18.0 m\n\npump = Pump(\"pump1\", Q_nom=15, pressure_head=H_required)\n</code></pre>"},{"location":"user_guide/components/mechanical/#ausgaben","title":"Ausgaben","text":"<pre><code>{\n    'P_consumed': 8.5,           # Leistungsaufnahme [kW]\n    'Q_actual': 10.0,            # Tats\u00e4chliche Durchflussrate [m\u00b3/h]\n    'is_running': True,          # Betriebszustand\n    'efficiency': 0.68,          # Aktueller Wirkungsgrad\n    'pressure_actual': 48.5,     # Tats\u00e4chlicher Druck [m]\n    'speed_fraction': 1.0,       # Drehzahl (0-1)\n    'specific_energy': 0.85      # Energie pro Volumen [kWh/m\u00b3]\n}\n</code></pre>"},{"location":"user_guide/components/mechanical/#verwendungsbeispiel","title":"Verwendungsbeispiel","text":"<pre><code># Exzenterschneckenpumpe f\u00fcr Substratf\u00f6rderung\npump = Pump(\n    component_id=\"feed_pump\",\n    pump_type=\"progressive_cavity\",\n    Q_nom=15.0,\n    pressure_head=50.0,\n    speed_control=True\n)\n\npump.initialize()\n\n# Betrieb bei 80% Kapazit\u00e4t\nresult = pump.step(\n    t=0,\n    dt=1/24,\n    inputs={\n        'Q_setpoint': 12.0,\n        'enable_pump': True,\n        'fluid_density': 1020,\n        'pressure_head': 50\n    }\n)\n\nprint(f\"Leistung: {result['P_consumed']:.1f} kW\")\nprint(f\"Durchfluss: {result['Q_actual']:.1f} m\u00b3/h\")\nprint(f\"Wirkungsgrad: {result['efficiency']:.1%}\")\n</code></pre>"},{"location":"user_guide/components/mechanical/#leistungsaufnahme","title":"Leistungsaufnahme","text":"<p>Pumpen berechnen Leistung basierend auf hydraulischer Formel:</p> <pre><code>P_hydraulic = \u03c1 \u00d7 g \u00d7 Q \u00d7 H / 1000  [kW]\nP_shaft = P_hydraulic / \u03b7_pump\nP_electrical = P_shaft / \u03b7_motor\n</code></pre> <p>Wobei: - \u03c1 = Fluiddichte [kg/m\u00b3] - g = 9.81 m/s\u00b2 - Q = Durchflussrate [m\u00b3/s] - H = Druckh\u00f6he [m] - \u03b7 = Wirkungsgrad</p> <p>Typische Leistungsaufnahme:</p> Durchfluss [m\u00b3/h] Druckh\u00f6he [m] Pumpentyp Leistung [kW] 10 30 Kreiselpumpe 2.5 10 50 Exzenterschnecke 4.5 15 50 Exzenterschnecke 6.8 20 60 Kolbenpumpe 10.5"},{"location":"user_guide/components/mechanical/#mixer","title":"Mixer","text":"<p>R\u00fchrwerke und Agitatoren zur Aufrechterhaltung der Homogenit\u00e4t in anaeroben Fermentern.</p>"},{"location":"user_guide/components/mechanical/#parameter_1","title":"Parameter","text":"<pre><code>from pyadm1.components.mechanical import Mixer\n\nmixer = Mixer(\n    component_id=\"mix1\",\n    mixer_type=\"propeller\",          # oder \"paddle\", \"jet\"\n    tank_volume=2000.0,              # Tankvolumen [m\u00b3]\n    tank_diameter=None,              # Auto-berechnet wenn None\n    mixing_intensity=\"medium\",       # \"low\", \"medium\", \"high\"\n    power_installed=None,            # Auto-berechnet wenn None\n    intermittent=True,               # Intermittierender Betrieb\n    on_time_fraction=0.25,           # 25% Einschaltzeit\n    name=\"Hauptr\u00fchrwerk\"\n)\n</code></pre>"},{"location":"user_guide/components/mechanical/#ruhrwerkstypen","title":"R\u00fchrwerkstypen","text":"Typ Str\u00f6mungsmuster Beste Anwendung Leistungsfaktor Typische Drehzahl [rpm] Propeller Axial Gro\u00dfe Tanks, fl\u00fcssige Substrate 1.0\u00d7 40-100 Paddelr\u00fchrwerk Radial Hohe Feststoffe, faseriges Material 1.2\u00d7 20-60 Strahlmischer Hydraulisch Rezirkulationsmischung 1.5\u00d7 N/A (Pumpe)"},{"location":"user_guide/components/mechanical/#mischintensitat","title":"Mischintensit\u00e4t","text":"Intensit\u00e4t Spezifische Leistung [W/m\u00b3] Mischzeit [min] Anwendung Niedrig 3 15-30 Fl\u00fcssige G\u00fclle, niedrige Feststoffe Mittel 5 8-15 Standardbetrieb, Energiepflanzen Hoch 8 3-8 Hohe Feststoffe, faserreiche Substrate"},{"location":"user_guide/components/mechanical/#dimensionierungsbeispiel","title":"Dimensionierungsbeispiel","text":"<pre><code># F\u00fcr 2000 m\u00b3 Fermenter mit mittlerer Intensit\u00e4t\ntank_volume = 2000  # m\u00b3\nspecific_power = 5  # W/m\u00b3 f\u00fcr mittlere Intensit\u00e4t\n\nP_required = (tank_volume * specific_power) / 1000  # kW\nP_required *= 1.2  # Sicherheitsfaktor f\u00fcr faserreiches Material\n# = 12 kW\n\nmixer = Mixer(\n    \"mix1\",\n    tank_volume=2000,\n    mixing_intensity=\"medium\",\n    power_installed=15  # Auf Standardgr\u00f6\u00dfe aufrunden\n)\n</code></pre>"},{"location":"user_guide/components/mechanical/#ausgaben_1","title":"Ausgaben","text":"<pre><code>{\n    'P_consumed': 12.5,          # Aktuelle Leistung [kW]\n    'P_average': 3.1,            # Zeitgemittelt [kW]\n    'is_running': True,          # Betriebszustand\n    'mixing_quality': 0.85,      # Qualit\u00e4tsindex (0-1)\n    'reynolds_number': 15000,    # Str\u00f6mungsregime-Indikator\n    'power_number': 0.32,        # Dimensionslose Leistungszahl\n    'mixing_time': 8.5,          # Zeit bis Homogenit\u00e4t [min]\n    'shear_rate': 45.2,          # Durchschn. Scherrate [1/s]\n    'specific_power': 6.25,      # Leistungsdichte [kW/m\u00b3]\n    'tip_speed': 2.8             # R\u00fchrblatt-Spitzengeschwindigkeit [m/s]\n}\n</code></pre>"},{"location":"user_guide/components/mechanical/#verwendungsbeispiel_1","title":"Verwendungsbeispiel","text":"<pre><code># Propellerr\u00fchrwerk mittlerer Intensit\u00e4t\nmixer = Mixer(\n    component_id=\"mix1\",\n    mixer_type=\"propeller\",\n    tank_volume=2000,\n    mixing_intensity=\"medium\",\n    intermittent=True,\n    on_time_fraction=0.25  # 6 Stunden pro Tag\n)\n\nmixer.initialize()\n\nresult = mixer.step(\n    t=0,\n    dt=1/24,\n    inputs={\n        'enable_mixing': True,\n        'speed_setpoint': 1.0,\n        'fluid_viscosity': 0.05  # Pa\u00b7s\n    }\n)\n\nprint(f\"Leistung: {result['P_consumed']:.1f} kW\")\nprint(f\"Durchschn. Leistung: {result['P_average']:.1f} kW\")\nprint(f\"Mischqualit\u00e4t: {result['mixing_quality']:.2f}\")\nprint(f\"Mischzeit: {result['mixing_time']:.1f} min\")\n</code></pre>"},{"location":"user_guide/components/mechanical/#intermittierender-betrieb","title":"Intermittierender Betrieb","text":"<p>Intermittierende Mischung reduziert Energieverbrauch:</p> <pre><code># Vergleich kontinuierlich vs. intermittierend\n# Kontinuierlich: 15 kW \u00d7 24 h = 360 kWh/Tag\n# Intermittierend (25%): 15 kW \u00d7 6 h = 90 kWh/Tag\n# Einsparung: 270 kWh/Tag (75%)\n\nmixer_continuous = Mixer(\n    \"mix_cont\",\n    tank_volume=2000,\n    intermittent=False\n)\n\nmixer_intermittent = Mixer(\n    \"mix_int\",\n    tank_volume=2000,\n    intermittent=True,\n    on_time_fraction=0.25\n)\n\n# Beide erreichen \u00e4hnliche Mischqualit\u00e4t\n</code></pre> <p>Empfohlene Einschaltzeiten:</p> Substrattyp Einschaltzeit Gesamtstunden/Tag Energieeinsparung Fl\u00fcssige G\u00fclle 15-20% 3.6-4.8 h 80-85% Energiepflanzen 20-30% 4.8-7.2 h 70-80% Hohe Feststoffe 25-35% 6.0-8.4 h 65-75% Faserreiches Material 30-40% 7.2-9.6 h 60-70%"},{"location":"user_guide/components/mechanical/#mischleistungsberechnung","title":"Mischleistungsberechnung","text":"<p>R\u00fchrwerke berechnen Leistung basierend auf Leistungszahl-Korrelation:</p> <pre><code># Mechanische Leistung aus Leistungszahl-Korrelation\n# P = Np * \u03c1 * N\u00b3 * D\u2075\n\nN = operating_speed / 60.0  # Hz (Umdrehungen/s)\nD = impeller_diameter       # m\n\nP_mech = power_number * fluid_density * N**3 * D**5 / 1000.0  # kW\n\n# Ber\u00fccksichtige Motorwirkungsgrad (typisch 85-95%)\nmotor_efficiency = 0.90\nP_electrical = P_mech / motor_efficiency\n\n# Limitiere auf installierte Leistung\nP_actual = min(P_electrical, power_installed)\n</code></pre> <p>Reynolds-Zahl f\u00fcr Mischen: <pre><code>Re = \u03c1 * N * D\u00b2 / \u03bc\n\nwobei:\n- \u03c1 = Fluiddichte [kg/m\u00b3]\n- N = Drehzahl [Hz]\n- D = R\u00fchrblattdurchmesser [m]\n- \u03bc = Viskosit\u00e4t [Pa\u00b7s]\n</code></pre></p> <p>Leistungszahl (abh\u00e4ngig von R\u00fchrwerkstyp und Reynolds-Zahl):</p> <ul> <li>Propeller:</li> <li>Laminar (Re &lt; 100): Np = 14.0 * Re^(-0.67)</li> <li>\u00dcbergang (100 &lt; Re &lt; 10000): Np = 1.2 * Re^(-0.15)</li> <li> <p>Turbulent (Re &gt; 10000): Np = 0.32</p> </li> <li> <p>Paddelr\u00fchrwerk:</p> </li> <li>Laminar (Re &lt; 10): Np = 300.0 / Re</li> <li>\u00dcbergang (10 &lt; Re &lt; 10000): Np = 8.0 * Re^(-0.25)</li> <li>Turbulent (Re &gt; 10000): Np = 5.0</li> </ul>"},{"location":"user_guide/components/mechanical/#mischzeit-schatzung","title":"Mischzeit-Sch\u00e4tzung","text":"<p>Basierend auf Nienow-Korrelation:</p> <pre><code>\u03b8_mix = C * (D_T/D)^\u03b1 * (H/D_T)^\u03b2 / N\n\nwobei:\n- C, \u03b1, \u03b2 = konstanten abh\u00e4ngig vom R\u00fchrwerkstyp\n- D_T = Tankdurchmesser [m]\n- D = R\u00fchrblattdurchmesser [m]\n- H = Tankh\u00f6he [m]\n- N = Drehzahl [Hz]\n</code></pre> <p>Typische Konstanten:</p> R\u00fchrwerkstyp C \u03b1 \u03b2 Propeller 5.3 2.0 0.5 Paddelr\u00fchrwerk 6.5 2.5 0.7 Strahlmischer 4.0 1.5 0.3"},{"location":"user_guide/components/mechanical/#integrationsbeispiel","title":"Integrationsbeispiel","text":""},{"location":"user_guide/components/mechanical/#komplette-pumpen-und-mischkette","title":"Komplette Pumpen- und Mischkette","text":"<pre><code>from pyadm1.configurator import BiogasPlant, PlantConfigurator\nfrom pyadm1.components.mechanical import Pump, Mixer\nfrom pyadm1.substrates import Feedstock\n\n# Setup\nfeedstock = Feedstock(feeding_freq=48)\nplant = BiogasPlant(\"Mechanische Systemanlage\")\nconfig = PlantConfigurator(plant, feedstock)\n\n# 1. Substratf\u00f6rderungspumpe\nfeed_pump = Pump(\n    \"feed_pump\",\n    pump_type=\"progressive_cavity\",\n    Q_nom=15.0,\n    pressure_head=50.0,\n    speed_control=True\n)\nplant.add_component(feed_pump)\n\n# 2. Fermenter\ndigester, storage = config.add_digester(\n    \"main_digester\",\n    V_liq=2000,\n    Q_substrates=[15, 10, 0, 0, 0, 0, 0, 0, 0, 0]\n)\n\n# 3. Hauptr\u00fchrwerk\nmain_mixer = Mixer(\n    \"main_mixer\",\n    mixer_type=\"propeller\",\n    tank_volume=2000,\n    mixing_intensity=\"medium\",\n    intermittent=True,\n    on_time_fraction=0.25\n)\nplant.add_component(main_mixer)\n\n# 4. Rezirkulationspumpe\nrecirc_pump = Pump(\n    \"recirc_pump\",\n    pump_type=\"centrifugal\",\n    Q_nom=50.0,  # H\u00f6herer Durchfluss f\u00fcr Rezirkulation\n    pressure_head=10.0,  # Niedrigerer Druck\n    speed_control=True\n)\nplant.add_component(recirc_pump)\n\n# 5. G\u00e4rrestpumpe\ndigestate_pump = Pump(\n    \"digestate_pump\",\n    pump_type=\"progressive_cavity\",\n    Q_nom=20.0,\n    pressure_head=30.0\n)\nplant.add_component(digestate_pump)\n\n# Energiesystem\nconfig.add_chp(\"chp1\", P_el_nom=500)\nconfig.add_heating(\"heat1\", target_temperature=308.15)\n\n# Verbindungen\nconfig.connect(\"feed_pump\", \"main_digester\", \"liquid\")\nconfig.auto_connect_digester_to_chp(\"main_digester\", \"chp1\")\nconfig.auto_connect_chp_to_heating(\"chp1\", \"heat1\")\n\n# Simulieren\nplant.initialize()\nresults = plant.simulate(duration=30, dt=1/24, save_interval=1.0)\n\n# Mechanische Energieanalyse\ndef mechanical_energy_analysis(results):\n    \"\"\"Analysiere mechanischen Energieverbrauch\"\"\"\n    final = results[-1]\n    comp = final['components']\n\n    # Pumpenenergie\n    feed_pump_energy = comp['feed_pump']['energy_consumed']\n    recirc_pump_energy = comp['recirc_pump']['energy_consumed']\n    digestate_pump_energy = comp['digestate_pump']['energy_consumed']\n    total_pump_energy = feed_pump_energy + recirc_pump_energy + digestate_pump_energy\n\n    # R\u00fchrwerkenergie\n    mixer_energy = comp['main_mixer']['energy_consumed']\n\n    # Gesamtmechanische Energie\n    total_mech_energy = total_pump_energy + mixer_energy\n\n    # BHKW-Produktion\n    chp_energy = comp['chp1']['P_el'] * 30 * 24  # kWh\n\n    # Parasit\u00e4re Last\n    parasitic_fraction = total_mech_energy / chp_energy if chp_energy &gt; 0 else 0\n\n    return {\n        'feed_pump': feed_pump_energy,\n        'recirc_pump': recirc_pump_energy,\n        'digestate_pump': digestate_pump_energy,\n        'total_pump': total_pump_energy,\n        'mixer': mixer_energy,\n        'total_mechanical': total_mech_energy,\n        'chp_production': chp_energy,\n        'parasitic_fraction': parasitic_fraction,\n        'net_energy': chp_energy - total_mech_energy\n    }\n\nanalysis = mechanical_energy_analysis(results)\nprint(\"\\nMechanische Energieanalyse:\")\nprint(f\"F\u00f6rderpumpe: {analysis['feed_pump']:.0f} kWh\")\nprint(f\"Rezirkulationspumpe: {analysis['recirc_pump']:.0f} kWh\")\nprint(f\"G\u00e4rrestpumpe: {analysis['digestate_pump']:.0f} kWh\")\nprint(f\"Gesamt Pumpen: {analysis['total_pump']:.0f} kWh\")\nprint(f\"R\u00fchrwerk: {analysis['mixer']:.0f} kWh\")\nprint(f\"Gesamt mechanisch: {analysis['total_mechanical']:.0f} kWh\")\nprint(f\"Parasit\u00e4re Last: {analysis['parasitic_fraction']:.1%}\")\nprint(f\"Nettoenergieproduktion: {analysis['net_energy']:.0f} kWh\")\n</code></pre>"},{"location":"user_guide/components/mechanical/#optimierungsstrategien","title":"Optimierungsstrategien","text":""},{"location":"user_guide/components/mechanical/#1-pumpenoptimierung","title":"1. Pumpenoptimierung","text":"<pre><code>def optimize_pump_sizing(Q_required, H_required, pump_type=\"progressive_cavity\"):\n    \"\"\"Optimiere Pumpendimensionierung f\u00fcr Effizienz\"\"\"\n\n    # Dimensioniere f\u00fcr 80-90% Nennlast (h\u00f6chster Wirkungsgrad)\n    Q_nom = Q_required / 0.85\n\n    # F\u00fcge Sicherheitsmarge f\u00fcr Druckh\u00f6he hinzu\n    H_nom = H_required * 1.2\n\n    pump = Pump(\n        \"optimized_pump\",\n        pump_type=pump_type,\n        Q_nom=Q_nom,\n        pressure_head=H_nom,\n        speed_control=True  # FU f\u00fcr Teillastoptimierung\n    )\n\n    return pump\n\n# Beispiel: 12 m\u00b3/h erforderlich bei 40 m Druckh\u00f6he\noptimized = optimize_pump_sizing(12.0, 40.0)\nprint(f\"Optimierte Pumpengr\u00f6\u00dfe: {optimized.Q_nom:.1f} m\u00b3/h\")\n</code></pre>"},{"location":"user_guide/components/mechanical/#2-mischoptimierung","title":"2. Mischoptimierung","text":"<pre><code>def optimize_mixing_strategy(substrate_type, tank_volume):\n    \"\"\"W\u00e4hle optimale Mischstrategie basierend auf Substrat\"\"\"\n\n    strategies = {\n        'liquid_manure': {\n            'intensity': 'low',\n            'on_time_fraction': 0.20,\n            'mixer_type': 'propeller'\n        },\n        'energy_crops': {\n            'intensity': 'medium',\n            'on_time_fraction': 0.25,\n            'mixer_type': 'propeller'\n        },\n        'high_solids': {\n            'intensity': 'medium',\n            'on_time_fraction': 0.30,\n            'mixer_type': 'paddle'\n        },\n        'fibrous': {\n            'intensity': 'high',\n            'on_time_fraction': 0.35,\n            'mixer_type': 'paddle'\n        }\n    }\n\n    strategy = strategies.get(substrate_type, strategies['energy_crops'])\n\n    mixer = Mixer(\n        \"optimized_mixer\",\n        mixer_type=strategy['mixer_type'],\n        tank_volume=tank_volume,\n        mixing_intensity=strategy['intensity'],\n        intermittent=True,\n        on_time_fraction=strategy['on_time_fraction']\n    )\n\n    return mixer, strategy\n\n# Beispiel: Faserreiche Substrate\nmixer, strategy = optimize_mixing_strategy('fibrous', 2000)\nprint(f\"Optimierte Mischstrategie:\")\nprint(f\"- Typ: {strategy['mixer_type']}\")\nprint(f\"- Intensit\u00e4t: {strategy['intensity']}\")\nprint(f\"- Einschaltzeit: {strategy['on_time_fraction']:.0%}\")\n</code></pre>"},{"location":"user_guide/components/mechanical/#3-energieminimierung","title":"3. Energieminimierung","text":"<pre><code>def minimize_mechanical_energy(plant_config):\n    \"\"\"Strategien zur Minimierung mechanischer Energie\"\"\"\n\n    strategies = []\n\n    # 1. Nutze intermittierend Mischen\n    strategies.append({\n        'name': 'Intermittierendes Mischen',\n        'saving': 0.70,  # 70% Einsparung\n        'implementation': 'on_time_fraction=0.25'\n    })\n\n    # 2. Frequenzumrichter f\u00fcr Pumpen\n    strategies.append({\n        'name': 'FU f\u00fcr Teillastbetrieb',\n        'saving': 0.30,  # 30% Einsparung bei Teillast\n        'implementation': 'speed_control=True'\n    })\n\n    # 3. Richtige Dimensionierung\n    strategies.append({\n        'name': 'Optimale Dimensionierung',\n        'saving': 0.15,  # 15% durch Wirkungsgradoptimierung\n        'implementation': 'Q_nom = Q_required / 0.85'\n    })\n\n    # 4. Niedrigere Mischintensit\u00e4t wo m\u00f6glich\n    strategies.append({\n        'name': 'Angepasste Mischintensit\u00e4t',\n        'saving': 0.40,  # 40% durch niedrigere Intensit\u00e4t\n        'implementation': 'mixing_intensity=\"low\" f\u00fcr Fl\u00fcssigsubstrate'\n    })\n\n    total_potential = sum(s['saving'] for s in strategies)\n\n    print(\"Energieminimierungsstrategien:\")\n    for s in strategies:\n        print(f\"- {s['name']}: {s['saving']:.0%} Einsparung\")\n        print(f\"  Umsetzung: {s['implementation']}\")\n\n    return strategies\n\nstrategies = minimize_mechanical_energy({})\n</code></pre>"},{"location":"user_guide/components/mechanical/#fehlerbehebung","title":"Fehlerbehebung","text":""},{"location":"user_guide/components/mechanical/#problem-pumpe-liefert-unzureichenden-durchfluss","title":"Problem: Pumpe liefert unzureichenden Durchfluss","text":"<p>Diagnose: <pre><code>pump_result = pump.step(0, 1/24, {'Q_setpoint': 15, 'enable_pump': True})\n\nif pump_result['Q_actual'] &lt; 0.8 * pump_result.get('Q_setpoint', 15):\n    print(\"Niedriger Pumpendurchfluss - pr\u00fcfe:\")\n    print(f\"- Aktuelle Effizienz: {pump_result['efficiency']:.1%}\")\n    print(f\"- Druckh\u00f6he: {pump_result['pressure_actual']:.1f} m\")\n    print(f\"- Ist Pumpe richtig dimensioniert f\u00fcr Anwendung?\")\n\n    # Pr\u00fcfe ob \u00dcberlast\n    if pump.speed_fraction &gt; 1.0:\n        print(\"- WARNUNG: Pumpe \u00fcberlastet!\")\n</code></pre></p> <p>L\u00f6sungen: - Erh\u00f6he Pumpengr\u00f6\u00dfe wenn konsistent \u00fcberlastet - Reduziere Reibungsverluste in Rohrleitungen - Pr\u00fcfe auf Blockaden oder Verschlei\u00df</p>"},{"location":"user_guide/components/mechanical/#problem-ruhrwerk-verbraucht-zu-viel-energie","title":"Problem: R\u00fchrwerk verbraucht zu viel Energie","text":"<p>Diagnose: <pre><code>mixer_result = mixer.step(0, 1/24, {})\n\nspecific_power = mixer_result['P_consumed'] / mixer.tank_volume  # kW/m\u00b3\n\nif specific_power &gt; 6.0:  # Obergrenze f\u00fcr mittlere Intensit\u00e4t\n    print(f\"Hohe spezifische Leistung: {specific_power:.1f} W/m\u00b3\")\n    print(\"Optimierungsoptionen:\")\n\n    if not mixer.intermittent:\n        print(\"- Aktiviere intermittierenden Betrieb (70% Einsparung)\")\n\n    if mixer.mixing_intensity == \"high\":\n        print(\"- Reduziere auf mittlere Intensit\u00e4t wenn m\u00f6glich\")\n</code></pre></p> <p>L\u00f6sungen: <pre><code># Implementiere intermittierenden Betrieb\nmixer_optimized = Mixer(\n    \"mix1\",\n    tank_volume=mixer.tank_volume,\n    mixing_intensity=\"medium\",\n    intermittent=True,\n    on_time_fraction=0.25  # 75% Energieeinsparung\n)\n</code></pre></p>"},{"location":"user_guide/components/mechanical/#problem-schlechte-mischqualitat","title":"Problem: Schlechte Mischqualit\u00e4t","text":"<p>Diagnose: <pre><code>if mixer_result['mixing_quality'] &lt; 0.7:\n    print(f\"Niedrige Mischqualit\u00e4t: {mixer_result['mixing_quality']:.2f}\")\n    print(f\"Mischzeit: {mixer_result['mixing_time']:.1f} min\")\n    print(f\"Reynolds-Zahl: {mixer_result['reynolds_number']:.0f}\")\n\n    if mixer_result['reynolds_number'] &lt; 1000:\n        print(\"- Laminare Str\u00f6mung - erh\u00f6he Drehzahl oder R\u00fchrblattgr\u00f6\u00dfe\")\n\n    if mixer_result['mixing_time'] &gt; 30:\n        print(\"- Lange Mischzeit - erh\u00f6he Intensit\u00e4t oder Einschaltzeit\")\n</code></pre></p> <p>L\u00f6sungen: - Erh\u00f6he Mischintensit\u00e4t f\u00fcr schwierige Substrate - Verl\u00e4ngere Einschaltzeit bei intermittierendem Betrieb - Erw\u00e4ge gr\u00f6\u00dferes R\u00fchrblatt oder h\u00f6here Drehzahl</p>"},{"location":"user_guide/components/mechanical/#best-practices","title":"Best Practices","text":"<ol> <li>Pumpen f\u00fcr optimalen Wirkungsgrad dimensionieren</li> <li>Betreibe bei 80-90% Nennlast</li> <li> <p>Nutze FU f\u00fcr variable Lastanforderungen</p> </li> <li> <p>Implementiere intermittierendes Mischen</p> </li> <li>25% Einschaltzeit f\u00fcr die meisten Anwendungen</li> <li> <p>Passe an Substrattyp an</p> </li> <li> <p>Regelm\u00e4\u00dfige Wartung</p> </li> <li>\u00dcberwache Pumpenwirkungsgrad \u00fcber Zeit</li> <li> <p>Pr\u00fcfe R\u00fchrwerkverschlei\u00df</p> </li> <li> <p>Optimiere Systemdesign</p> </li> <li>Minimiere Rohrleitungsverlu ste</li> <li> <p>Richtige Pumpenplatzierung</p> </li> <li> <p>\u00dcberwache Energieverbrauch</p> </li> <li>Verfolge parasit\u00e4re Last</li> <li>Ziel: &lt;10% der BHKW-Produktion</li> </ol>"},{"location":"user_guide/components/mechanical/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Biologische Komponenten: Fermenter und Prozesssteuerung</li> <li>Energiekomponenten: BHKW und W\u00e4rmesysteme</li> <li>F\u00fctterungskomponenten: Lagerung und Dosierung</li> <li>API-Referenz: Detaillierte Klassendokumentation</li> </ul>"},{"location":"user_guide/components/sensors/","title":"Sensoren","text":"<p>Mess- und \u00dcberwachungskomponenten f\u00fcr Biogasanlagen (in Entwicklung).</p>"},{"location":"user_guide/components/sensors/#ubersicht","title":"\u00dcbersicht","text":"<p>PyADM1 wird in Zukunft ein umfassendes Sensormodul f\u00fcr realistische Prozess\u00fcberwachung und -steuerung enthalten. Diese Komponenten werden realistische Messcharakteristiken modellieren, einschlie\u00dflich Rauschen, Drift und Ansprechzeiten.</p>"},{"location":"user_guide/components/sensors/#geplante-sensorkategorien","title":"Geplante Sensorkategorien","text":""},{"location":"user_guide/components/sensors/#physikalische-sensoren","title":"Physikalische Sensoren","text":"<p>Sensoren f\u00fcr physikalische Eigenschaften:</p> <ul> <li>pH-Elektroden: Mit Kalibrierungsdrift und Temperaturkompensation</li> <li>Temperatursensoren: PT100, Thermoelemente mit Genauigkeitsspezifikationen</li> <li>Drucksensoren: F\u00fcr Gas- und Fl\u00fcssigkeitsdruck</li> <li>F\u00fcllstandssensoren: Ultraschall, Radar, hydrostatisch</li> <li>Durchflussmesser: Magnetisch-induktiv, Ultraschall, Coriolis</li> </ul>"},{"location":"user_guide/components/sensors/#chemische-sensoren","title":"Chemische Sensoren","text":"<p>Sensoren f\u00fcr Prozessfl\u00fcssigkeitsanalyse:</p> <ul> <li>VFA-Analysatoren: Online-Titration, GC-Analyse</li> <li>Ammoniak-Sensoren: Ionenselektive Elektroden</li> <li>CSB-Analysatoren: Online-Spektroskopie</li> <li>N\u00e4hrstoffanalysatoren: N, P, K-Messung</li> </ul>"},{"location":"user_guide/components/sensors/#gas-analysatoren","title":"Gas-Analysatoren","text":"<p>Sensoren f\u00fcr Biogaszusammensetzung:</p> <ul> <li>Methan-Sensoren: Infrarot, kalorimetrisch</li> <li>CO2-Sensoren: NDIR-Technologie</li> <li>H2S-Sensoren: Elektrochemisch</li> <li>Sauerstoff-Sensoren: F\u00fcr Leckageerkennung</li> <li>Spurengas-Analysatoren: Mit Nachweisgrenzen</li> </ul>"},{"location":"user_guide/components/sensors/#beispiel-konzept","title":"Beispiel-Konzept","text":"<pre><code># Zuk\u00fcnftige Implementierung (konzeptionell)\nfrom pyadm1.components.sensors import PhysicalSensor, ChemicalSensor, GasSensor\n\n# pH-Sensor mit realistischem Rauschen\nph_sensor = PhysicalSensor(\n    \"ph1\",\n    sensor_type=\"pH\",\n    measurement_noise=0.05,    # \u00b10.05 pH Einheiten\n    drift_rate=0.01,           # Kalibrierungsdrift pro Tag\n    response_time=30.0,        # Sekunden\n    calibration_interval=7     # Tage zwischen Kalibrierungen\n)\n\n# VFA-Analysator mit Messungsverz\u00f6gerung\nvfa_sensor = ChemicalSensor(\n    \"vfa1\",\n    sensor_type=\"VFA\",\n    measurement_delay=5,       # Minuten Verz\u00f6gerung\n    accuracy=0.1,              # \u00b110% Genauigkeit\n    detection_limit=0.1,       # g/L untere Grenze\n    sampling_interval=60       # Minuten zwischen Proben\n)\n\n# Methan-Analysator\nch4_sensor = GasSensor(\n    \"ch4_1\",\n    sensor_type=\"CH4\",\n    measurement_range=(0, 100),  # % CH4\n    accuracy=0.5,                # \u00b10.5%\n    drift=0.1,                   # % pro Woche\n    cross_sensitivity={'CO2': 0.01}  # Kreuzempfindlichkeit\n)\n</code></pre>"},{"location":"user_guide/components/sensors/#sensor-charakteristiken","title":"Sensor-Charakteristiken","text":""},{"location":"user_guide/components/sensors/#rauschen-und-genauigkeit","title":"Rauschen und Genauigkeit","text":"<p>Realistische Sensoren weisen verschiedene Fehlerquellen auf:</p> <pre><code># Gemessener Wert = Wahrer Wert + Systematischer Fehler + Zuf\u00e4lliges Rauschen + Drift\n\nmeasured_value = (\n    true_value * (1 + systematic_error) +\n    random.normal(0, noise_level) +\n    drift_accumulated\n)\n</code></pre> <p>Typische Genauigkeiten:</p> Sensor Messbereich Genauigkeit Drift pH 0-14 \u00b10.05 pH 0.01 pH/Tag Temperatur (PT100) -50 bis 200\u00b0C \u00b10.1\u00b0C &lt;0.01\u00b0C/Jahr Druck 0-2 bar \u00b10.5% FS &lt;0.1% FS/Jahr VFA 0-20 g/L \u00b15% \u00b10.1 g/L/Woche CH4 0-100% \u00b10.5% \u00b10.1%/Woche"},{"location":"user_guide/components/sensors/#ansprechzeit","title":"Ansprechzeit","text":"<p>Sensoren haben charakteristische Ansprechzeiten:</p> <pre><code># First-order response\nsensor_value(t) = true_value * (1 - exp(-t/\u03c4))\n\n# wobei \u03c4 = Zeitkonstante (63.2% Response-Zeit)\n</code></pre> <p>Typische Ansprechzeiten:</p> Sensor \u03c4 (Zeit bis 63% Response) t95 (Zeit bis 95% Response) pH-Elektrode 10-30 s 30-90 s Thermoelement 0.1-5 s 0.3-15 s CH4-Sensor (IR) 5-10 s 15-30 s VFA-Analysator 2-5 min 6-15 min"},{"location":"user_guide/components/sensors/#kalibrierung-und-wartung","title":"Kalibrierung und Wartung","text":"<p>Sensoren ben\u00f6tigen regelm\u00e4\u00dfige Kalibrierung:</p> <pre><code># Kalibrierungsdrift-Modell\ndrift(t) = drift_rate * (t - last_calibration)\n\nif (t - last_calibration) &gt; calibration_interval:\n    # Kalibrierung erforderlich\n    perform_calibration()\n    last_calibration = t\n    accumulated_drift = 0\n</code></pre>"},{"location":"user_guide/components/sensors/#sensor-platzierung","title":"Sensor-Platzierung","text":""},{"location":"user_guide/components/sensors/#fermenter-uberwachung","title":"Fermenter-\u00dcberwachung","text":"<p>Empfohlene Sensoren f\u00fcr Fermenter:</p> <pre><code># Minimale Instrumentierung\nsensors_minimum = {\n    'temperature': ['T1'],           # Fermentertemperatur\n    'pH': ['pH1'],                   # Prozess-pH\n    'gas_flow': ['Q_gas'],           # Gasproduktion\n    'gas_composition': ['CH4_CO2']   # Methangehalt\n}\n\n# Standard-Instrumentierung\nsensors_standard = {\n    'temperature': ['T1', 'T2'],     # Fermenter + Umgebung\n    'pH': ['pH1'],\n    'VFA': ['VFA1'],                 # VFA-Konzentration\n    'gas_flow': ['Q_gas'],\n    'gas_composition': ['CH4_CO2', 'H2S'],\n    'level': ['L1']                  # F\u00fcllstand\n}\n\n# Erweiterte Instrumentierung\nsensors_advanced = {\n    'temperature': ['T1', 'T2', 'T3'],  # Multiple Punkte\n    'pH': ['pH1', 'pH2'],                # Redundanz\n    'VFA': ['VFA1'],\n    'ammonia': ['NH3'],                  # Inhibitions\u00fcberwachung\n    'gas_flow': ['Q_gas'],\n    'gas_composition': ['CH4_CO2', 'H2S', 'O2'],\n    'pressure': ['P_gas'],               # Gasspeicherdruck\n    'level': ['L1'],\n    'conductivity': ['EC1']              # Prozessstabilit\u00e4t\n}\n</code></pre>"},{"location":"user_guide/components/sensors/#datenverarbeitung","title":"Datenverarbeitung","text":""},{"location":"user_guide/components/sensors/#filterung-und-glattung","title":"Filterung und Gl\u00e4ttung","text":"<p>Rohe Sensordaten ben\u00f6tigen oft Filterung:</p> <pre><code># Exponentielles Gl\u00e4tten\ndef exponential_smoothing(measurements, alpha=0.3):\n    \"\"\"\n    Gl\u00e4tte Sensormessungen\n\n    alpha: Gl\u00e4ttungsfaktor (0-1)\n           0 = keine Gl\u00e4ttung\n           1 = nur aktueller Wert\n    \"\"\"\n    smoothed = [measurements[0]]\n    for m in measurements[1:]:\n        s = alpha * m + (1 - alpha) * smoothed[-1]\n        smoothed.append(s)\n    return smoothed\n\n# Moving Average\ndef moving_average(measurements, window=5):\n    \"\"\"Gleitender Durchschnitt\"\"\"\n    return [\n        sum(measurements[max(0, i-window):i+1]) /\n        min(window, i+1)\n        for i in range(len(measurements))\n    ]\n</code></pre>"},{"location":"user_guide/components/sensors/#ausreier-erkennung","title":"Ausrei\u00dfer-Erkennung","text":"<pre><code>def detect_outliers(measurements, threshold=3.0):\n    \"\"\"\n    Erkenne Ausrei\u00dfer mit Z-Score\n\n    threshold: Standardabweichungen f\u00fcr Ausrei\u00dfer\n    \"\"\"\n    mean = sum(measurements) / len(measurements)\n    std = (sum((x - mean)**2 for x in measurements) / len(measurements))**0.5\n\n    outliers = []\n    for i, m in enumerate(measurements):\n        z_score = abs(m - mean) / std if std &gt; 0 else 0\n        if z_score &gt; threshold:\n            outliers.append(i)\n\n    return outliers\n</code></pre>"},{"location":"user_guide/components/sensors/#prozesssteuerung-mit-sensoren","title":"Prozesssteuerung mit Sensoren","text":""},{"location":"user_guide/components/sensors/#ph-regelung","title":"pH-Regelung","text":"<pre><code># Zuk\u00fcnftiges Beispiel: pH-Steuerung\ndef ph_control(ph_measurement, setpoint=7.2, tolerance=0.2):\n    \"\"\"\n    Einfache pH-Regelung\n\n    Returns: Kalk-Dosierungsrate [kg/d]\n    \"\"\"\n    error = setpoint - ph_measurement\n\n    if error &gt; tolerance:\n        # pH zu niedrig, f\u00fcge Kalk hinzu\n        dosing_rate = min(100, error * 50)  # Proportionale Regelung\n    elif error &lt; -tolerance:\n        # pH zu hoch, reduziere Kalk\n        dosing_rate = 0\n    else:\n        # Innerhalb Toleranz\n        dosing_rate = 0\n\n    return dosing_rate\n</code></pre>"},{"location":"user_guide/components/sensors/#futterungssteuerung-basierend-auf-vfa","title":"F\u00fctterungssteuerung basierend auf VFA","text":"<pre><code>def adaptive_feeding_control(vfa_measurement, vfa_limit=4.0,\n                             current_feed_rate=15.0):\n    \"\"\"\n    Passe F\u00fctterungsrate basierend auf VFA an\n\n    vfa_limit: VFA-Grenzwert [g/L]\n    current_feed_rate: Aktuelle Rate [m\u00b3/d]\n\n    Returns: Angepasste F\u00fctterungsrate [m\u00b3/d]\n    \"\"\"\n    if vfa_measurement &gt; vfa_limit:\n        # \u00dcbers\u00e4uerungsrisiko - reduziere F\u00fctterung\n        reduction_factor = vfa_limit / vfa_measurement\n        new_rate = current_feed_rate * reduction_factor\n        print(f\"VFA hoch ({vfa_measurement:.2f} g/L) - Reduziere auf {new_rate:.1f} m\u00b3/d\")\n    elif vfa_measurement &lt; vfa_limit * 0.5:\n        # Stabil - kann F\u00fctterung erh\u00f6hen\n        increase_factor = 1.05  # 5% Erh\u00f6hung\n        new_rate = min(current_feed_rate * increase_factor, 20.0)  # Max 20 m\u00b3/d\n        print(f\"VFA stabil ({vfa_measurement:.2f} g/L) - Erh\u00f6he auf {new_rate:.1f} m\u00b3/d\")\n    else:\n        # Innerhalb optimalen Bereichs\n        new_rate = current_feed_rate\n\n    return new_rate\n</code></pre>"},{"location":"user_guide/components/sensors/#alarme-und-benachrichtigungen","title":"Alarme und Benachrichtigungen","text":""},{"location":"user_guide/components/sensors/#alarm-system","title":"Alarm-System","text":"<pre><code>class SensorAlarm:\n    \"\"\"Sensor-Alarmsystem\"\"\"\n\n    def __init__(self, sensor_id, alarm_type, threshold, hysteresis=0.1):\n        self.sensor_id = sensor_id\n        self.alarm_type = alarm_type  # 'high', 'low', 'rate_of_change'\n        self.threshold = threshold\n        self.hysteresis = hysteresis\n        self.is_active = False\n        self.last_value = None\n\n    def check(self, current_value):\n        \"\"\"Pr\u00fcfe Alarmbedingung\"\"\"\n\n        if self.alarm_type == 'high':\n            if not self.is_active and current_value &gt; self.threshold:\n                self.is_active = True\n                return f\"ALARM: {self.sensor_id} hoch ({current_value:.2f})\"\n            elif self.is_active and current_value &lt; (self.threshold - self.hysteresis):\n                self.is_active = False\n                return f\"OK: {self.sensor_id} normal ({current_value:.2f})\"\n\n        elif self.alarm_type == 'low':\n            if not self.is_active and current_value &lt; self.threshold:\n                self.is_active = True\n                return f\"ALARM: {self.sensor_id} niedrig ({current_value:.2f})\"\n            elif self.is_active and current_value &gt; (self.threshold + self.hysteresis):\n                self.is_active = False\n                return f\"OK: {self.sensor_id} normal ({current_value:.2f})\"\n\n        elif self.alarm_type == 'rate_of_change':\n            if self.last_value is not None:\n                rate = abs(current_value - self.last_value)\n                if not self.is_active and rate &gt; self.threshold:\n                    self.is_active = True\n                    return f\"ALARM: {self.sensor_id} schnelle \u00c4nderung ({rate:.2f}/h)\"\n            self.last_value = current_value\n\n        return None\n\n# Beispielverwendung\nalarms = {\n    'pH_low': SensorAlarm('pH1', 'low', 6.8, hysteresis=0.1),\n    'pH_high': SensorAlarm('pH1', 'high', 8.0, hysteresis=0.1),\n    'VFA_high': SensorAlarm('VFA1', 'high', 4.0, hysteresis=0.5),\n    'temp_deviation': SensorAlarm('T1', 'rate_of_change', 2.0)  # 2\u00b0C/h\n}\n\n# In Simulationsschleife\nfor measurement in ph_measurements:\n    for alarm in alarms.values():\n        message = alarm.check(measurement)\n        if message:\n            print(message)\n</code></pre>"},{"location":"user_guide/components/sensors/#datalogging","title":"Datalogging","text":""},{"location":"user_guide/components/sensors/#sensordaten-protokollierung","title":"Sensordaten-Protokollierung","text":"<pre><code>import csv\nfrom datetime import datetime\n\nclass SensorDataLogger:\n    \"\"\"Protokolliere Sensordaten\"\"\"\n\n    def __init__(self, filename):\n        self.filename = filename\n        self.file = None\n        self.writer = None\n\n    def open(self, sensor_ids):\n        \"\"\"\u00d6ffne Logdatei\"\"\"\n        self.file = open(self.filename, 'w', newline='')\n        self.writer = csv.writer(self.file)\n        # Header\n        self.writer.writerow(['timestamp', 'time_days'] + sensor_ids)\n\n    def log(self, time_days, sensor_values):\n        \"\"\"Protokolliere einen Zeitpunkt\"\"\"\n        timestamp = datetime.now().isoformat()\n        row = [timestamp, time_days] + sensor_values\n        self.writer.writerow(row)\n\n    def close(self):\n        \"\"\"Schlie\u00dfe Logdatei\"\"\"\n        if self.file:\n            self.file.close()\n\n# Verwendung\nlogger = SensorDataLogger('sensor_data.csv')\nlogger.open(['pH', 'T', 'VFA', 'Q_gas', 'CH4'])\n\n# In Simulation\nfor t in range(simulation_steps):\n    # ... Simulation ...\n    sensor_values = [\n        digester.outputs_data['pH'],\n        digester.T_ad,\n        digester.outputs_data['VFA'],\n        digester.outputs_data['Q_gas'],\n        digester.outputs_data['Q_ch4']\n    ]\n    logger.log(t, sensor_values)\n\nlogger.close()\n</code></pre>"},{"location":"user_guide/components/sensors/#aktuelle-implementierung","title":"Aktuelle Implementierung","text":"<p>W\u00e4hrend dedizierte Sensorkomponenten noch in Entwicklung sind, k\u00f6nnen Fermenter-Ausgaben bereits zur Prozess\u00fcberwachung verwendet werden:</p> <pre><code>from pyadm1.components.biological import Digester\n\n# Fermenter liefert bereits Prozessindikatoren\ndigester = Digester(\"dig1\", feedstock, V_liq=2000)\nresult = digester.step(t, dt, inputs)\n\n# Verf\u00fcgbare \"Sensor\"-Werte\nmonitoring_data = {\n    'pH': result['pH'],\n    'VFA': result['VFA'],            # g/L\n    'TAC': result['TAC'],            # g CaCO3/L\n    'Q_gas': result['Q_gas'],        # m\u00b3/d\n    'Q_ch4': result['Q_ch4'],        # m\u00b3/d\n    'Q_co2': result['Q_co2']         # m\u00b3/d\n}\n\n# Einfache Prozess\u00fcberwachung\nif monitoring_data['pH'] &lt; 6.8:\n    print(\"Warnung: Niedriger pH\")\n\nif monitoring_data['VFA'] / monitoring_data['TAC'] &gt; 0.4:\n    print(\"Warnung: Hohes VFA/TAC-Verh\u00e4ltnis\")\n</code></pre>"},{"location":"user_guide/components/sensors/#zukunftige-entwicklung","title":"Zuk\u00fcnftige Entwicklung","text":"<p>Das Sensormodul wird erweitert um:</p> <ol> <li>Realistische Sensor-Modelle</li> <li>Rauschen und Drift</li> <li>Kalibrierungszyklen</li> <li> <p>Ausfallmodelle</p> </li> <li> <p>Erweiterte Prozesssteuerung</p> </li> <li>PID-Regler</li> <li>Modellpr\u00e4diktive Regelung (MPC)</li> <li> <p>Adaptive Steuerung</p> </li> <li> <p>Datenanalyse-Tools</p> </li> <li>Trendanalyse</li> <li>Anomalie-Erkennung</li> <li> <p>Pr\u00e4diktive Wartung</p> </li> <li> <p>Visualisierung</p> </li> <li>Echtzeit-Dashboards</li> <li>Historische Trends</li> <li>Alarm-\u00dcbersichten</li> </ol>"},{"location":"user_guide/components/sensors/#nachste-schritte","title":"N\u00e4chste Schritte","text":"<ul> <li>Biologische Komponenten: Fermenter und Prozesssteuerung</li> <li>Energiekomponenten: BHKW und W\u00e4rmesysteme</li> <li>Mechanische Komponenten: Pumpen und R\u00fchrwerke</li> <li>F\u00fctterungskomponenten: Lagerung und Dosierung</li> <li>API-Referenz: Detaillierte Klassendokumentation (wenn verf\u00fcgbar)</li> </ul>"}]}